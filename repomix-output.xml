This file is a merged representation of a subset of the codebase, containing specifically included files and files not matching ignore patterns, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of a subset of the repository's contents that is considered the most important context.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Only files matching these patterns are included: src/**/*, package.json, index.html, vite.config.js, src/config/theme.js, style.css, .spec/**/*
- Files matching these patterns are excluded: **/*.log, dist/**, public/**, src/assets/**, .spec/prompt.md
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
.spec/active-context.md
.spec/feature-ruler-interaction.md
.spec/project-charter.md
.spec/system-patterns.md
index.html
package.json
src/api/ai.js
src/App.vue
src/components/common/CanvasContextMenu.vue
src/components/common/FloatingObjectMenu.vue
src/components/common/LoadingOverlay.vue
src/components/common/Modal.vue
src/components/common/ShortcutsPanel.vue
src/components/layout/EditorLayout.vue
src/components/layout/LeftSidebar.vue
src/components/layout/NavBar.vue
src/components/modules/adjust/AdjustColor.vue
src/components/modules/adjust/AdjustColorOverlay.vue
src/components/modules/adjust/AdjustCrop.vue
src/components/modules/adjust/AdjustFilters.vue
src/components/modules/adjust/AdjustInpaint.vue
src/components/modules/adjust/AdjustMosaic.vue
src/components/modules/adjust/AdjustRembg.vue
src/components/modules/adjust/AdjustResize.vue
src/components/modules/adjust/AdjustRuler.vue
src/components/modules/adjust/AdjustWhite.vue
src/components/modules/adjust/index.vue
src/components/modules/adjust/useCanvasColor.js
src/components/modules/adjust/useCanvasColorOverlay.js
src/components/modules/adjust/useCanvasCrop.js
src/components/modules/adjust/useCanvasFilters.js
src/components/modules/adjust/useCanvasInpaint.js
src/components/modules/adjust/useCanvasMosaic.js
src/components/modules/adjust/useCanvasResize.js
src/components/modules/adjust/useCanvasRuler.js
src/components/modules/adjust/useCanvasWhite.js
src/components/modules/ai/AiExpand.vue
src/components/modules/ai/AiGenerate.vue
src/components/modules/ai/index.vue
src/components/modules/border/index.vue
src/components/modules/draw/DrawBrush.vue
src/components/modules/draw/DrawShape.vue
src/components/modules/draw/index.vue
src/components/modules/material/index.vue
src/components/modules/puzzle/config.js
src/components/modules/puzzle/index.vue
src/components/modules/puzzle/useCanvasPuzzle.js
src/components/modules/text/index.vue
src/components/modules/text/TextAdd.vue
src/components/modules/text/TextStyle.vue
src/components/modules/watermark/index.vue
src/components/panels/ToolPanel.vue
src/components/Workspace.vue
src/composables/useCanvas.js
src/composables/useConstraint.js
src/composables/useEditorState.js
src/composables/useKeyboardShortcuts.js
src/composables/useObjectActions.js
src/composables/useOffscreenHelper.js
src/config/shortcuts.js
src/config/theme.js
src/index.js
src/main.js
src/style.css
src/utils/toast.js
vite.config.js
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path=".spec/system-patterns.md">
"注意：在大秘美图中，Fabric 的 Canvas 必须用 markRaw 包装，否则会导致 Vue 响应式卡死。之前在 2024-12 遇到过这个问题。"
</file>

<file path="src/components/common/CanvasContextMenu.vue">
<template>
  <div 
    v-show="visible" 
    class="context-menu"
    :style="{ left: position.x + 'px', top: position.y + 'px' }"
    @contextmenu.prevent 
  >
    <div 
      class="menu-item" 
      :class="{ disabled: !clipboardState.hasContent }"
      @click="handlePaste"
    >
      <span class="icon">
        <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M16 4h2a2 2 0 0 1 2 2v14a2 2 0 0 1-2 2H6a2 2 0 0 1-2-2V6a2 2 0 0 1 2-2h2"></path><rect x="8" y="2" width="8" height="4" rx="1" ry="1"></rect></svg>
      </span>
      <span>粘贴</span>
      <span class="shortcut">Ctrl+V</span>
    </div>

    </div>
</template>

<script setup>
import { inject } from 'vue';
import { useObjectActions } from '@/composables/useObjectActions';

// 接收 Props 控制显示
const props = defineProps({
  visible: Boolean,
  position: {
    type: Object,
    default: () => ({ x: 0, y: 0 })
  }
});

const emit = defineEmits(['close', 'paste']);

const actions = useObjectActions();
const clipboardState = actions.clipboardState;

const handlePaste = () => {
  if (!clipboardState.hasContent) return;
  emit('paste'); // 通知父组件进行粘贴
  emit('close'); // 关闭菜单
};
</script>

<style scoped>
.context-menu {
  position: fixed; /* 使用 fixed 避免受父容器 overflow 影响 */
  z-index: 3000;
  background: #ffffff;
  border: 1px solid #ebeef5;
  border-radius: 6px;
  box-shadow: 0 4px 16px rgba(0, 0, 0, 0.1);
  padding: 4px 0;
  width: 140px;
  min-width: 120px;
}

.menu-item {
  display: flex;
  align-items: center;
  padding: 8px 12px;
  font-size: 13px;
  color: #606266;
  cursor: pointer;
  transition: background 0.1s;
}

.menu-item:hover {
  background: #f5f7fa;
  color: var(--ie-primary-color);
}

.menu-item.disabled {
  color: #c0c4cc;
  cursor: not-allowed;
  background: transparent !important;
}

.icon {
  display: flex;
  align-items: center;
  margin-right: 8px;
  width: 16px;
}

.shortcut {
  margin-left: auto;
  font-size: 12px;
  color: #909399;
}
</style>
</file>

<file path="src/components/common/FloatingObjectMenu.vue">
<template>
  <div 
    v-show="isVisible" 
    class="floating-wrapper"
    :style="{ left: position.left + 'px', top: position.top + 'px' }"
  >
    <button 
      class="trigger-btn" 
      @click.stop="toggleMenu" 
      :class="{ active: isMenuOpen }"
      title="更多操作"
    >
      <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
        <circle cx="12" cy="12" r="1"></circle>
        <circle cx="19" cy="12" r="1"></circle>
        <circle cx="5" cy="12" r="1"></circle>
      </svg>
    </button>

    <div v-if="isMenuOpen" class="main-menu">
      
      <div class="menu-item" @click="handleAction(actions.copyActive)">
        <span class="icon">
           <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><rect x="9" y="9" width="13" height="13" rx="2" ry="2"></rect><path d="M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1"></path></svg>
        </span>
        <span class="label">复制</span>
        <span class="shortcut">Ctrl+C</span>
      </div>

      <div class="menu-item" @click="handleAction(actions.cutActive)">
        <span class="icon">
           <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><circle cx="6" cy="6" r="3"></circle><circle cx="6" cy="18" r="3"></circle><line x1="20" y1="4" x2="8.12" y2="15.88"></line><line x1="14.47" y1="14.48" x2="20" y2="20"></line><line x1="8.12" y1="8.12" x2="12" y2="12"></line></svg>
        </span>
        <span class="label">剪切</span>
        <span class="shortcut">Ctrl+X</span>
      </div>

      <div class="menu-item" @click="handleLock">
        <span class="icon">
          <svg v-if="isLocked" width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><rect x="3" y="11" width="18" height="11" rx="2" ry="2"></rect><path d="M7 11V7a5 5 0 0 1 10 0v4"></path></svg>
          <svg v-else width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><rect x="3" y="11" width="18" height="11" rx="2" ry="2"></rect><path d="M7 11V7a5 5 0 0 1 9.9-1"></path></svg>
        </span>
        <span class="label">{{ isLocked ? '解锁' : '锁定' }}</span>
        <span class="shortcut">Shift+Ctrl+L</span>
      </div>

      <div class="menu-item has-submenu">
        <span class="icon">
          <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><polyline points="2 17 12 22 22 17"></polyline><polyline points="2 12 12 17 22 12"></polyline><polyline points="2 7 12 12 22 7"></polyline></svg>
        </span>
        <span class="label">图层顺序</span>
        <span class="arrow-right">
          <svg width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><polyline points="9 18 15 12 9 6"></polyline></svg>
        </span>

        <div class="submenu">
           <div class="menu-item" @click="handleAction(() => actions.moveLayer('forward'))">
             <span class="label">上一层</span>
             <span class="shortcut">]</span>
           </div>
           <div class="menu-item" @click="handleAction(() => actions.moveLayer('backward'))">
             <span class="label">下一层</span>
             <span class="shortcut">[</span>
           </div>
           <div class="divider"></div>
           <div class="menu-item" @click="handleAction(() => actions.moveLayer('front'))">
             <span class="label">置顶</span>
             <span class="shortcut">Shift+]</span>
           </div>
           <div class="menu-item" @click="handleAction(() => actions.moveLayer('back'))">
             <span class="label">置底</span>
             <span class="shortcut">Shift+[</span>
           </div>
        </div>
      </div>

      <div class="divider"></div>

      <div class="menu-item delete" @click="handleAction(actions.deleteActive)">
        <span class="icon">
          <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><polyline points="3 6 5 6 21 6"></polyline><path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"></path></svg>
        </span>
        <span class="label">删除</span>
        <span class="shortcut">Del</span>
      </div>

      <div v-if="$slots.extra">
          <div class="divider"></div>
          <slot name="extra"></slot>
      </div>

    </div>
  </div>
</template>

<script setup>
import { ref, inject, onMounted, onUnmounted, unref } from 'vue';
import { useObjectActions } from '@/composables/useObjectActions';

const canvasAPI = inject('canvasAPI');
const actions = useObjectActions();

const isVisible = ref(false);
const isMenuOpen = ref(false); 
const isLocked = ref(false);
const position = ref({ left: 0, top: 0 });

const toggleMenu = () => {
  isMenuOpen.value = !isMenuOpen.value;
};

const handleAction = (actionFn) => {
  actionFn();
  isMenuOpen.value = false; 
};

const handleLock = () => {
  const locked = actions.toggleLock();
  isLocked.value = locked;
};

// 更新菜单位置
const updatePosition = () => {
  const canvas = unref(canvasAPI.canvas);
  const activeObj = canvas?.getActiveObject();

  if (!activeObj || activeObj.isMainImage) {
    isVisible.value = false;
    isMenuOpen.value = false;
    return;
  }

  const coords = activeObj.getBoundingRect(true, true);
  const containerWidth = canvas.getElement().parentElement.offsetWidth;
  const menuWidth = 40; 
  
  let newLeft = coords.left + coords.width + 40; 

  if (newLeft + menuWidth > containerWidth) {
      newLeft = coords.left - menuWidth + 76;
  }

  position.value = {
    left: newLeft,
    top: coords.top + 5
  };

  isVisible.value = true;
  isLocked.value = !!activeObj.lockMovementX;
};

const bindEvents = () => {
  const canvas = unref(canvasAPI.canvas);
  if (!canvas) return;

  const events = [
    'selection:created', 'selection:updated', 'object:moving', 
    'object:scaling', 'object:rotating', 'object:modified'
  ];
  events.forEach(evt => canvas.on(evt, updatePosition));
  
  canvas.on('selection:cleared', () => { 
    isVisible.value = false; 
    isMenuOpen.value = false;
  });
};

const unbindEvents = () => {
  const canvas = unref(canvasAPI.canvas);
  if (!canvas) return;
  canvas.off('selection:cleared');
  const events = [
    'selection:created', 'selection:updated', 'object:moving', 
    'object:scaling', 'object:rotating', 'object:modified'
  ];
  events.forEach(evt => canvas.off(evt));
};

onMounted(() => setTimeout(bindEvents, 200));
onUnmounted(unbindEvents);
</script>

<style scoped>
/* 悬浮容器 */
.floating-wrapper {
  position: absolute;
  z-index: 2000;
  pointer-events: auto;
}

/* 1. 触发按钮 */
.trigger-btn {
  width: 24px;
  height: 24px;
  border-radius: 8px;
  background: #ffffff;
  border: 1px solid #e4e7ed;
  box-shadow: 0 2px 8px rgba(0,0,0,0.1);
  display: flex;
  align-items: center;
  justify-content: center;
  cursor: pointer;
  color: #606266;
  transition: all 0.2s;
  padding: 0 !important;
}

.trigger-btn:hover, .trigger-btn.active {
  background: #ecf5ff;
  color: var(--ie-primary-color);
  border-color: var(--ie-primary-color);
}

/* 2. 主菜单 */
.main-menu {
  position: absolute;
  top: 15px;
  left: 22px;
  width: 180px; /* 加宽一点以容纳快捷键 */
  background: #ffffff;
  border: 1px solid #ebeef5;
  border-radius: 8px;
  box-shadow: 0 4px 16px rgba(0,0,0,0.1);
  padding: 4px 0;
  display: flex;
  flex-direction: column;
}

/* 菜单项布局优化 */
.menu-item {
  position: relative;
  display: flex;
  align-items: center;
  padding: 8px 12px;
  font-size: 13px;
  color: #606266;
  cursor: pointer;
  transition: background 0.1s;
}

.menu-item:hover {
  background: #f5f7fa;
  color: var(--ie-primary-color);
}

.menu-item.delete:hover {
  background: #fef0f0;
  color: #f56c6c;
}

.icon {
  display: flex;
  align-items: center;
  margin-right: 8px;
  width: 16px;
  opacity: 0.8;
}

.label {
  flex: 1; /* 撑开中间，把快捷键挤到右边 */
}

/* ✨ 快捷键样式 */
.shortcut {
  font-size: 11px;
  color: #bfa; /* 这个绿色是示例，实际建议用浅灰色 */
  color: #909399; /* 修正为浅灰色，更专业 */
  margin-left: 8px;
  font-family: monospace; /* 等宽字体更好看 */
  opacity: 0.8;
}

.arrow-right {
  margin-left: auto;
  opacity: 0.5;
  display: flex;
  align-items: center;
}

.divider {
  height: 1px;
  background: #ebeef5;
  margin: 4px 0;
}

/* 3. 二级菜单 */
.submenu {
  display: none;
  position: absolute;
  left: 100%;
  top: -4px;
  width: 140px; /* 也稍微加宽 */
  background: #ffffff;
  border: 1px solid #ebeef5;
  border-radius: 8px;
  box-shadow: 0 4px 16px rgba(0,0,0,0.1);
  padding: 4px 0;
  margin-left: 4px;
}

.menu-item.has-submenu:hover .submenu {
  display: block;
}

.menu-item.has-submenu::after {
  content: '';
  position: absolute;
  top: 0;
  right: -10px;
  width: 10px;
  height: 100%;
}
</style>
</file>

<file path="src/components/common/LoadingOverlay.vue">
<template>
    <div v-if="state.isLoading" class="loading-overlay">
        <div class="loading-content">
            <div class="spinner"></div>
            <p class="loading-text">{{ state.loadingText }}</p>
        </div>
    </div>
</template>

<script setup>
import { useEditorState } from '@/composables/useEditorState';

// 直接连接全局状态
const { state } = useEditorState();
</script>

<style scoped>
.loading-overlay {
    position: fixed;
    top: 0;
    left: 0;
    width: 100vw;
    height: 100vh;
    background-color: rgba(0, 0, 0, 0.7);
    /* 半透明黑色背景 */
    z-index: 9999;
    /* 确保层级最高，遮挡所有操作 */
    display: flex;
    justify-content: center;
    align-items: center;
    backdrop-filter: blur(2px);
    /* 轻微模糊背景 */
}

.loading-content {
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 16px;
}

.spinner {
    width: 40px;
    height: 40px;
    border: 4px solid rgba(255, 255, 255, 0.3);
    border-radius: 50%;
    border-top-color: #ffffff;
    animation: spin 1s ease-in-out infinite;
}

.loading-text {
    color: #ffffff;
    font-size: 16px;
    font-weight: 500;
    letter-spacing: 0.5px;
}

@keyframes spin {
    to {
        transform: rotate(360deg);
    }
}
</style>
</file>

<file path="src/components/common/ShortcutsPanel.vue">
<template>
  <Teleport to="body">
    <Transition name="fade">
      <div v-if="visible" class="shortcut-overlay" @click="close"></div>
    </Transition>

    <Transition name="slide">
      <div v-if="visible" class="shortcut-drawer">
        <div class="drawer-header">
          <h3>快捷键列表</h3>
          <button class="close-btn" @click="close">
            <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><line x1="18" y1="6" x2="6" y2="18"></line><line x1="6" y1="6" x2="18" y2="18"></line></svg>
          </button>
        </div>
        
        <div class="drawer-content">
          <div v-for="(group, index) in groups" :key="index" class="group-section">
            <h4 class="group-title">{{ group.title }}</h4>
            <div class="shortcut-list">
              <div v-for="(item, idx) in group.items" :key="idx" class="shortcut-item">
                <span class="label">{{ item.label }}</span>
                <div class="keys">
                  <span v-for="(key, kIdx) in item.keys" :key="kIdx" class="keycap">
                    {{ key }}
                  </span>
                </div>
              </div>
            </div>
          </div>
        </div>
      </div>
    </Transition>
  </Teleport>
</template>

<script setup>
import { defineProps, defineEmits } from 'vue';
import { SHORTCUT_GROUPS } from '@/config/shortcuts';

defineProps({
  visible: Boolean
});

const emit = defineEmits(['close']);
const groups = SHORTCUT_GROUPS;

const close = () => {
  emit('close');
};
</script>

<style scoped>
/* 遮罩层 */
.shortcut-overlay {
  position: fixed;
  top: 0;
  left: 0;
  width: 100vw;
  height: 100vh;
  background: rgba(0, 0, 0, 0.4);
  z-index: 3000;
  backdrop-filter: blur(2px);
}

/* 抽屉面板 */
.shortcut-drawer {
  position: fixed;
  top: 0;
  right: 0;
  width: 320px;
  height: 100vh;
  background: white;
  z-index: 3001;
  box-shadow: -4px 0 20px rgba(0, 0, 0, 0.1);
  display: flex;
  flex-direction: column;
}

/* 头部 */
.drawer-header {
  padding: 20px;
  border-bottom: 1px solid #ebeef5;
  display: flex;
  justify-content: space-between;
  align-items: center;
}

.drawer-header h3 {
  margin: 0;
  font-size: 18px;
  color: #303133;
}

.close-btn {
  background: none;
  border: none;
  cursor: pointer;
  color: #909399;
  padding: 4px;
  border-radius: 4px;
  transition: background 0.2s;
  display: flex;
}
.close-btn:hover {
  background: #f5f7fa;
  color: #606266;
}

/* 内容区 */
.drawer-content {
  flex: 1;
  overflow-y: auto;
  padding: 20px;
}

.group-section {
  margin-bottom: 24px;
}

.group-title {
  font-size: 14px;
  color: #909399;
  margin: 0 0 12px 0;
  font-weight: 600;
}

.shortcut-item {
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: 12px;
  font-size: 14px;
  color: #606266;
}

/* ✨ Keycap 风格核心代码 */
.keys {
  display: flex;
  gap: 4px;
}

.keycap {
  display: inline-block;
  padding: 2px 8px;
  font-size: 12px;
  font-family: 'SF Mono', 'Roboto Mono', Monaco, monospace;
  color: #303133;
  background: #fdfdfd; /* 稍微白一点 */
  border: 1px solid #dcdfe6;
  border-bottom-width: 3px; /* 底部加厚模拟立体感 */
  border-radius: 6px;
  min-width: 20px;
  text-align: center;
  box-shadow: 0 1px 2px rgba(0,0,0,0.05);
}

/* 动画 */
.fade-enter-active, .fade-leave-active {
  transition: opacity 0.3s ease;
}
.fade-enter-from, .fade-leave-to {
  opacity: 0;
}

.slide-enter-active, .slide-leave-active {
  transition: transform 0.3s cubic-bezier(0.16, 1, 0.3, 1);
}
.slide-enter-from, .slide-leave-to {
  transform: translateX(100%);
}
</style>
</file>

<file path="src/components/modules/adjust/AdjustFilters.vue">
<template>
  <div class="tool-group">
    <div class="tool-item" :class="{ 'is-expanded': isExpanded }" @click="$emit('toggle')">
      <div class="left">
        <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
          <path d="m19 2 2 2-2 2-2-2Z"/><path d="m13 2 2 2-2 2-2-2Z"/><path d="m6 6 2 2-2 2-2-2Z"/>
          <path d="m3 21 9-9"/><path d="M12.22 7.28a3 3 0 0 0-4.24 0L3.5 11.76a3 3 0 0 0 0 4.24l4.48 4.48a3 3 0 0 0 4.24 0l4.48-4.48a3 3 0 0 0 0-4.24Z"/>
        </svg>
        <span>滤镜效果</span>
      </div>
      <div class="right-icon">
        <svg class="arrow" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
          <path d="m9 18 6-6-6-6"/>
        </svg>
      </div>
    </div>

    <div v-if="isExpanded" class="tool-content filter-panel">
      <div v-for="cat in categories" :key="cat.name" class="filter-category">
        <div class="cat-title">{{ cat.name }}</div>
        <div class="filter-grid">
          <div 
            v-for="item in cat.list" 
            :key="item.key" 
            class="filter-item"
            :class="{ active: currentFilter === item.key }"
            @click="selectFilter(item.key)"
          >
            <div class="thumb-container">
              <img v-if="thumbnailMap[item.key]" :src="thumbnailMap[item.key]" class="filter-thumb">
              <div v-else class="thumb-placeholder loading"></div>
            </div>
            <span class="filter-label">{{ item.label }}</span>
          </div>
        </div>
      </div>

      <div class="intensity-box" v-if="currentFilter !== 'original'">
        <div class="label-row">
          <span>强度：{{ intensity }}</span>
        </div>
        <input type="range" v-model.number="intensity" min="0" max="100" class="ie-slider" @input="updateIntensity">
      </div>

      <div class="action-buttons">
        <button class="ie-btn ie-primary full" @click="handleConfirm">确定</button>
        <button class="ie-btn full" @click="handleCancel">取消</button>
      </div>
    </div>
  </div>
</template>

<script setup>
import { ref, reactive, inject, onMounted, watch } from 'vue';
import { 
    registerFilterModule, applyFilterPreset, loadThumbnailsTask, 
    backupCurrentFilters, commitFilterChange, cancelFilterChange 
} from './useCanvasFilters';

const props = defineProps({ isExpanded: Boolean });
const emit = defineEmits(['toggle']);
const canvasAPI = inject('canvasAPI');

const currentFilter = ref('original');
const intensity = ref(100);
const thumbnailMap = reactive({});

const categories = [
  { name: '基础', list: [{key:'original', label:'原图'}, {key:'natural', label:'自然'}, {key:'bright', label:'鲜亮'}, {key:'whitening', label:'净白'}] },
  { name: '复古', list: [{key:'v8090', label:'8090'}, {key:'modern', label:'摩登'}, {key:'cool_space', label:'烈空'}] },
  { name: '风景', list: [{key:'snow', label:'初雪'}, {key:'sunset', label:'垦丁'}, {key:'hot_sun', label:'烈日'}] },
  { name: '电影', list: [{key:'smoke', label:'尘烟'}, {key:'spring', label:'春风'}, {key:'lalaland', label:'爱乐之城'}] },
];

const selectFilter = (key) => {
  currentFilter.value = key;
  applyFilterPreset(key, intensity.value);
};

const updateIntensity = () => applyFilterPreset(currentFilter.value, intensity.value);

const handleConfirm = () => {
    commitFilterChange();
    emit('toggle');
};

const handleCancel = () => {
    cancelFilterChange();
    emit('toggle');
};

const refreshThumbnails = () => {
    loadThumbnailsTask((map) => Object.assign(thumbnailMap, map));
};

// 核心优化：仅在面板展开时监听，并执行备份
watch(() => props.isExpanded, (expanded) => {
    const canvas = canvasAPI?.canvas?.value;
    const bgImage = canvas?.getObjects().find(o => o.type === 'image');
    
    if (expanded && bgImage) {
        // ✅ 1. 展开瞬间，根据图片上存储的元数据同步 UI 高亮和强度
        currentFilter.value = bgImage._lastFilterKey || 'original';
        intensity.value = bgImage._lastFilterIntensity ?? 100;

        // 2. 执行备份逻辑 (用于取消回滚)
        backupCurrentFilters(); 
        
        // 3. 加载缩略图及注册监听
        refreshThumbnails();
        canvas.on('image:updated', refreshThumbnails);
    } else if (!expanded && canvas) {
        canvas.off('image:updated', refreshThumbnails);
    }
});

onMounted(() => {
    if (canvasAPI?.canvas) registerFilterModule(canvasAPI.canvas, canvasAPI.saveHistory);
});
</script>

<style scoped>
/* 样式保留原有的网格布局和主题色定义 */
.filter-panel { padding: 12px; max-height: 520px; overflow-y: auto; }
.cat-title { font-size: 13px; font-weight: bold; margin: 12px 0 8px; color: #333; }
.filter-grid { display: grid; grid-template-columns: repeat(3, 1fr); gap: 12px; }
.filter-item { display: flex; flex-direction: column; align-items: center; cursor: pointer; }
.thumb-container { width: 70px; height: 70px; border-radius: 4px; overflow: hidden; border: 2px solid transparent; transition: 0.2s; background: #eee; }
.filter-thumb { width: 100%; height: 100%; object-fit: cover; }
.thumb-placeholder.loading { width: 100%; height: 100%; background: linear-gradient(90deg, #f0f0f0 25%, #e0e0e0 50%, #f0f0f0 75%); background-size: 200% 100%; animation: loading-skeleton 1.5s infinite; }
@keyframes loading-skeleton { 0% { background-position: 200% 0; } 100% { background-position: -200% 0; } }
.filter-item.active .thumb-container { border-color: var(--ie-primary-color); }
.filter-label { font-size: 11px; margin-top: 6px; color: #666; }
.intensity-box { margin-top: 20px; padding: 12px 0; border-top: 1px solid #f0f0f0; }
.label-row { display: flex; justify-content: space-between; font-size: 12px; color: #606266; margin-bottom: 8px; }
.action-buttons { display: flex; gap: 10px; margin-top: 16px; }
.full { flex: 1; }
</style>
</file>

<file path="src/components/modules/adjust/AdjustRuler.vue">
<template>
  <div class="tool-group">
    <div class="tool-item" :class="{ 'is-expanded': isExpanded }" @click="$emit('toggle')">
      <div class="left">
        <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
          <path d="M21.3 15.3a2.4 2.4 0 0 1 0 3.4l-2.6 2.6a2.4 2.4 0 0 1-3.4 0L2.7 8.7a2.4 2.4 0 0 1 0-3.4l2.6-2.6a2.4 2.4 0 0 1 3.4 0l12.6 12.6z"></path>
          <path d="m5 6 1.7 1.7"></path>
          <path d="m17 18 1.7 1.7"></path>
          <path d="m11 12 1.7 1.7"></path>
        </svg>
        <span>测量标尺</span>
      </div>
      <div class="right-icon">
        <svg class="arrow" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
          <path d="m9 18 6-6-6-6" />
        </svg>
      </div>
    </div>

    <div v-if="isExpanded" class="tool-content">
      
      <div class="action-row">
        <button 
          class="ie-btn ie-primary" 
          :class="{ 'active': isDrawing }"
          @click="toggleDrawMode"
        >
          <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" style="margin-right:4px">
            <line x1="5" y1="12" x2="19" y2="12"></line>
            <polyline points="12 5 19 12 12 19"></polyline>
          </svg>
          {{ isDrawing ? '绘制中 (Esc退出)' : '新建标尺' }}
        </button>
      </div>

      <div class="divider"></div>

      <div class="control-group">
        <div class="label-row">
          <span>标注数值</span>
        </div>
        <div class="input-group">
          <input 
            type="number" 
            v-model.number="rulerConfig.value" 
            class="ie-input-number" 
            style="flex:1; width:auto;"
            @input="updateActiveRuler"
          >
          <select v-model="rulerConfig.unit" class="ie-select" @change="updateActiveRuler">
            <option value="px">px</option>
            <option value="cm">cm</option>
            <option value="mm">mm</option>
            <option value="m">m</option>
            <option value="in">inch</option>
            <option value="ft">foot</option>
          </select>
        </div>
      </div>

      <div class="control-group">
        <div class="label-row">
          <span>线条颜色</span>
          <input type="color" v-model="rulerConfig.color" @input="updateActiveRuler">
        </div>
        
        <div class="label-row">
          <span>透明度</span>
          <span class="val">{{ rulerConfig.opacity }}%</span>
        </div>
        <input 
          type="range" 
          v-model.number="rulerConfig.opacity" 
          min="10" max="100" 
          class="ie-slider" 
          @input="updateActiveRuler"
        >
      </div>

      <div class="control-group">
        <div class="label-row">
          <span>线条粗细</span>
          <span class="val">{{ rulerConfig.strokeWidth }}px</span>
        </div>
        <input 
          type="range" 
          v-model.number="rulerConfig.strokeWidth" 
          min="1" max="10" 
          class="ie-slider" 
          @input="updateActiveRuler"
        >
      </div>

      <div class="control-group">
        <div class="label-row">
          <span>字体大小</span>
          <input 
            type="number" 
            v-model.number="rulerConfig.fontSize" 
            class="ie-input-number"
            @input="updateActiveRuler"
          >
        </div>
        <div class="label-row" style="margin-top:8px">
          <span>文字背景</span>
          <input type="checkbox" v-model="rulerConfig.showBg" @change="updateActiveRuler">
        </div>
      </div>

    </div>
  </div>
</template>

<script setup>
import { defineProps, defineEmits, inject, onMounted } from 'vue';
import { 
  registerRulerModule, 
  rulerConfig, 
  isDrawing, 
  startDrawMode, 
  stopDrawMode,
  updateActiveRuler 
} from './useCanvasRuler';

const props = defineProps({
  isExpanded: Boolean
});

const emit = defineEmits(['toggle']);
const canvasAPI = inject('canvasAPI'); // 依赖注入获取 Canvas

const toggleDrawMode = () => {
  if (isDrawing.value) {
    stopDrawMode();
  } else {
    startDrawMode();
  }
};

onMounted(() => {
  if (canvasAPI && canvasAPI.canvas) {
    registerRulerModule(canvasAPI.canvas, canvasAPI.saveHistory);
  } else {
    console.warn('CanvasAPI not found in AdjustRuler');
  }
});
</script>

<style scoped>
.tool-content { padding: 16px; }

.action-row {
  display: flex;
  justify-content: center;
  margin-bottom: 16px;
}

.divider {
  height: 1px;
  background: #ebeef5;
  margin: 16px 0;
}

.control-group {
  margin-bottom: 16px;
}

.label-row {
  display: flex;
  justify-content: space-between;
  align-items: center;
  font-size: 12px;
  color: #606266;
  margin-bottom: 8px;
}

.input-group {
  display: flex;
  gap: 8px;
}

.ie-select {
  height: 28px;
  border: 1px solid #dcdfe6;
  border-radius: 4px;
  font-size: 12px;
  color: #606266;
  padding: 0 4px;
  outline: none;
  background: white;
}

.ie-btn.active {
  background-color: #ecf5ff;
  color: var(--ie-primary-color);
  border-color: var(--ie-primary-color);
}

.val { font-family: monospace; }
</style>
</file>

<file path="src/components/modules/adjust/useCanvasFilters.js">
// src/components/modules/adjust/useCanvasFilters.js
import { unref } from "vue";
import { fabric } from "fabric";

let canvasRef = null;
let saveHistoryFn = null;
let thumbnailTimer = null;
let backupFilters = [];
let backupKey = 'original'; // 用于备份滤镜 Key
let backupIntensity = 100;   // 用于备份强度


export const registerFilterModule = (canvas, saveHistory) => {
    canvasRef = canvas;
    saveHistoryFn = saveHistory;
};

// 滤镜矩阵配置（模拟店小秘的四大分类）
export const filterDefinitions = {
    // 基础类
    natural: [1, 0, 0, 0, 0,  0, 1.05, 0, 0, 0,  0, 0, 1.02, 0, 0,  0, 0, 0, 1, 0], // 自然
    bright: [1.1, 0, 0, 0, 0,  0, 1.1, 0, 0, 0,  0, 0, 1.1, 0, 0,  0, 0, 0, 1, 0],   // 鲜亮
    whitening: [1.05, 0, 0, 0, 0.05,  0, 1.05, 0, 0, 0.05,  0, 0, 1.05, 0, 0.05,  0, 0, 0, 1, 0], // 净白

    // 复古类
    v8090: [0.35, 0.25, 0.25, 0, 0,  0.25, 0.35, 0.25, 0, 0,  0.25, 0.25, 0.35, 0, 0,  0, 0, 0, 1, 0], // 8090
    modern: [0.393, 0.769, 0.189, 0, 0,  0.349, 0.686, 0.168, 0, 0,  0.272, 0.534, 0.131, 0, 0,  0, 0, 0, 1, 0], // 摩登
    cool_space: [1, 0, 0, 0.1, -0.1,  0, 1, 0, 0.1, -0.1,  0, 0, 1.2, 0.2, -0.1,  0, 0, 0, 1, 0], // 烈空

    // 风景类
    snow: [1, 0, 0, 0, 0.1,  0, 1, 0, 0, 0.1,  0, 0, 1.1, 0, 0.15,  0, 0, 0, 1, 0], // 初雪
    sunset: [1.2, 0, 0, 0, 0,  0, 1, 0, 0, 0,  0, 0, 0.8, 0, 0,  0, 0, 0, 1, 0],     // 垦丁
    hot_sun: [1.1, 0, 0, 0.1, 0,  0, 1, 0, 0.1, 0,  0, 0, 0.9, 0, 0,  0, 0, 0, 1, 0], // 烈日

    // 电影类
    smoke: [0.8, 0.1, 0.1, 0, 0,  0.1, 0.8, 0.1, 0, 0,  0.1, 0.1, 0.8, 0, 0,  0, 0, 0, 1, 0], // 尘烟
    spring: [0.9, 0, 0, 0, 0,  0, 1.1, 0, 0, 0,  0, 0, 0.9, 0, 0,  0, 0, 0, 1, 0], // 春风
    lalaland: [1, 0, 0, 0, 0,  0, 0.9, 0, 0, 0,  0, 0, 1.2, 0, 0,  0, 0, 0, 1, 0], // 爱乐之城
};

// 备份当前滤镜状态
export const backupCurrentFilters = () => {
    const canvas = unref(canvasRef);
    const bgImage = canvas?.getObjects().find(o => o.type === 'image');
    if (bgImage) {
        // 深拷贝滤镜数组
        backupFilters = [...bgImage.filters];
        backupKey = bgImage._lastFilterKey || 'original';
        backupIntensity = bgImage._lastFilterIntensity ?? 100;
    }
};

/**
 * 应用滤镜预设
 * @param {string} filterKey 滤镜配置键名
 * @param {number} intensity 强度 (0-100)
 */
export const applyFilterPreset = (filterKey, intensity = 100) => {
    const canvas = unref(canvasRef);
    const bgImage = canvas?.getObjects().find(o => o.type === 'image');
    if (!bgImage) return;

    // 记录当前选中的滤镜信息到对象上，以便重新打开面板时同步 UI
    bgImage._lastFilterKey = filterKey;
    bgImage._lastFilterIntensity = intensity;

    bgImage.filters = bgImage.filters.filter(f => !f._isArtFilter);

    if (filterKey !== 'original') {
        const matrix = filterDefinitions[filterKey];
        if (matrix) {
            const filter = new fabric.Image.filters.ColorMatrix({
                matrix: matrix,
                alpha: intensity / 100
            });
            filter._isArtFilter = true;
            bgImage.filters.push(filter);
        }
    }

    bgImage.applyFilters();
    canvas.requestRenderAll();
};

// 确定：保存历史记录并清理备份
export const commitFilterChange = () => {
    if (saveHistoryFn) saveHistoryFn();
    backupFilters = [];
};

/**
 * 取消修改：核心逻辑回归 —— 恢复到备份状态
 */
export const cancelFilterChange = () => {
    const canvas = unref(canvasRef);
    const bgImage = canvas?.getObjects().find(o => o.type === 'image');
    if (bgImage) {
        bgImage.filters = [...backupFilters];
        // ✅ 还原元数据
        bgImage._lastFilterKey = backupKey;
        bgImage._lastFilterIntensity = backupIntensity;
        
        bgImage.applyFilters();
        canvas.requestRenderAll();
    }
    backupFilters = [];
};

/**
 * 生成所有滤镜的预览缩略图
 * @returns {Promise<Object>} 返回一个对象，键是滤镜key，值是Base64图片数据
 */
export const generateFilterThumbnails = () => {
  return new Promise((resolve, reject) => {
    const canvas = unref(canvasRef);
    if (!canvas) {
      reject("Canvas not initialized");
      return;
    }

    const bgImage = canvas.getObjects().find(o => o.type === 'image');
    if (!bgImage) {
      resolve({}); // 没有图片时返回空
      return;
    }

    const originalSrc = bgImage.getSrc();
    const thumbSize = 80; // 缩略图大小，越小生成越快

    // 1. 创建一个后台小型离屏画布
    const tempCanvas = new fabric.StaticCanvas(null, {
      width: thumbSize,
      height: thumbSize,
      backgroundColor: 'transparent'
    });

    // 2. 加载原图
    fabric.Image.fromURL(originalSrc, (thumbImg) => {
        // 3. 将图片缩放并居中填满小画布
        const scale = Math.max(thumbSize / thumbImg.width, thumbSize / thumbImg.height);
        thumbImg.set({
            originX: 'center',
            originY: 'center',
            left: thumbSize / 2,
            top: thumbSize / 2,
            scaleX: scale,
            scaleY: scale
        });
        tempCanvas.add(thumbImg);

        const resultMap = {};

        // 4. 定义一个辅助函数来生成单个滤镜图
        const renderOne = (matrix) => {
            thumbImg.filters = []; // 清空旧滤镜
            if (matrix) {
                const filter = new fabric.Image.filters.ColorMatrix({ matrix: matrix });
                thumbImg.filters.push(filter);
            }
            thumbImg.applyFilters();
            tempCanvas.renderAll();
            // 使用较低质量导出，提高速度
            return tempCanvas.toDataURL({ format: 'jpeg', quality: 0.7 });
        };

        // 5. 生成【原图】缩略图
        resultMap['original'] = renderOne(null);

        // 6. 循环生成所有【滤镜】缩略图
        for (const key in filterDefinitions) {
            resultMap[key] = renderOne(filterDefinitions[key]);
        }
        
        // 清理内存
        tempCanvas.dispose();
        resolve(resultMap);
    }, { crossOrigin: 'anonymous' }); // 确保跨域加载
  });
};

/**
 * 优化的缩略图加载逻辑（带内部防抖）
 * @param {Function} callback - 成功生成后的回调
 */
export const loadThumbnailsTask = (callback) => {
    if (thumbnailTimer) clearTimeout(thumbnailTimer);

    // 设置 200ms 防抖，防止面板快速切换或图片连续变换时的计算浪费
    thumbnailTimer = setTimeout(async () => {
        try {
            const map = await generateFilterThumbnails(); // 调用之前定义的生成函数
            if (callback) callback(map);
        } catch (e) {
            console.error("生成缩略图失败:", e);
        }
    }, 200);
};
</file>

<file path="src/components/modules/adjust/useCanvasMosaic.js">
// [文件: src/components/modules/adjust/useCanvasMosaic.js]
import { unref } from "vue";
import { fabric } from "fabric";

let canvasRef = null;
let saveHistoryFn = null;

// 内部状态：保持持久化，直到点击应用或取消
let mosaicPreviewLayer = null;
let maskGroup = null;

export const registerMosaicModule = (canvas, saveHistory) => {
  canvasRef = canvas;
  saveHistoryFn = saveHistory;
};

/**
 * 核心：开启或更新马赛克交互 [遵循全景报告：状态保护]
 */
export const startMosaicInteraction = (mode, intensity = 15) => {
  const canvas = unref(canvasRef);
  if (!canvas) return;

  const bgImage = canvas.getObjects().find(o => o.type === 'image');
  if (!bgImage) return;

  // 1. 如果预览层已存在，仅更新滤镜强度，不重置状态
  if (mosaicPreviewLayer) {
    const filter = new fabric.Image.filters.Pixelate({ blocksize: intensity });
    mosaicPreviewLayer.filters = [filter];
    mosaicPreviewLayer.applyFilters();
    
    // 切换模式逻辑
    canvas.isDrawingMode = (mode === 'path');
    if (!canvas.isDrawingMode) addMosaicShape(mode);
    
    canvas.requestRenderAll();
    return;
  }

  // 2. 首次初始化：创建预览层
  bgImage.clone((cloned) => {
    mosaicPreviewLayer = cloned;
    
    const pixelateFilter = new fabric.Image.filters.Pixelate({ blocksize: intensity });
    mosaicPreviewLayer.filters = [pixelateFilter];
    mosaicPreviewLayer.applyFilters();

    // 初始化路径遮罩组
    maskGroup = new fabric.Group([], { absolutePositioned: true });

    mosaicPreviewLayer.set({
      selectable: false,
      evented: false,
      clipPath: maskGroup, // 初始关联
      name: 'mosaic-preview-layer'
    });

    canvas.add(mosaicPreviewLayer);
    canvas.bringToFront(mosaicPreviewLayer);

    // 设置交互
    canvas.isDrawingMode = (mode === 'path');
    if (mode === 'path') {
      const brush = new fabric.PencilBrush(canvas);
      brush.width = 30;
      brush.color = 'rgba(0,0,0,1)'; // 遮罩色
      canvas.freeDrawingBrush = brush;
      canvas.on('path:created', onPathCreated);
    } else {
      addMosaicShape(mode);
    }
    
    canvas.requestRenderAll();
  });
};

const onPathCreated = (opt) => {
  const canvas = unref(canvasRef);
  if (maskGroup && mosaicPreviewLayer) {
    canvas.remove(opt.path);
    maskGroup.addWithUpdate(opt.path);
    canvas.requestRenderAll();
  }
};

/**
 * 添加可交互的形状框 [修复交互失效的关键]
 */
const addMosaicShape = (type) => {
  const canvas = unref(canvasRef);
  const center = canvas.getCenter();
  
  // 检查是否已有形状，避免重复生成
  const existing = canvas.getObjects().find(o => o.name === 'mosaic-shape');
  if (existing) {
    canvas.setActiveObject(existing);
    return;
  }

  const commonTpl = {
    left: center.left, top: center.top,
    fill: 'rgba(64, 158, 255, 0.2)', // 半透明蓝色，表示选区
    stroke: '#409eff', strokeWidth: 2,
    originX: 'center', originY: 'center',
    cornerColor: '#fff', cornerStrokeColor: '#409eff',
    transparentCorners: false,
    name: 'mosaic-shape',
    absolutePositioned: true
  };

  const shape = type === 'rect' 
    ? new fabric.Rect({ ...commonTpl, width: 150, height: 150 })
    : new fabric.Circle({ ...commonTpl, radius: 75 });

  canvas.add(shape);
  canvas.setActiveObject(shape);

  // ✅ 关键：形状变动时，强制马赛克预览层刷新渲染
  const updateClip = () => canvas.requestRenderAll();
  shape.on('moving', updateClip);
  shape.on('scaling', updateClip);

  // 修改预览层的 clipPath，使其包含路径组和当前交互形状
  mosaicPreviewLayer.clipPath = new fabric.Group([maskGroup, shape], { 
    absolutePositioned: true 
  });
  
  canvas.requestRenderAll();
};

/**
 * 应用马赛克：离屏高清重制 [遵循全景报告：高清准则]
 */
export const applyMosaic = (intensity) => {
  return new Promise((resolve) => {
    const canvas = unref(canvasRef);
    const bgImage = canvas?.getObjects().find(o => o.type === 'image');
    if (!bgImage) return resolve();

    // 1. 捕获视觉快照 (Viewport Compensation)
    const prevVpt = [...canvas.viewportTransform];
    const prevZoom = canvas.getZoom();
    const imgCenter = bgImage.getCenterPoint();
    const rectCenterScreen = {
      x: imgCenter.x * prevVpt[0] + prevVpt[4],
      y: imgCenter.y * prevVpt[3] + prevVpt[5]
    };

    // 2. 收集所有作为遮罩的对象
    const shapes = canvas.getObjects().filter(o => o.name === 'mosaic-shape');
    const allMaskObjects = [...maskGroup.getObjects(), ...shapes];
    if (allMaskObjects.length === 0) return resolve();

    const originalSrc = bgImage.getSrc();
    fabric.Image.fromURL(originalSrc, (highResImg) => {
      const { width, height } = highResImg;
      const tempCanvas = new fabric.StaticCanvas(null, { width, height });
      const scale = width / bgImage.getScaledWidth();

      const mosaicLayer = fabric.util.object.clone(highResImg);
      mosaicLayer.filters = [new fabric.Image.filters.Pixelate({ blocksize: intensity })];
      mosaicLayer.applyFilters();

      // 坐标换算
      const finalMaskObjects = allMaskObjects.map(obj => {
        const cloned = fabric.util.object.clone(obj);
        const localLeft = (obj.left - (bgImage.left - bgImage.getScaledWidth() / 2)) * scale;
        const localTop = (obj.top - (bgImage.top - bgImage.getScaledHeight() / 2)) * scale;
        cloned.set({
          left: localLeft, top: localTop,
          scaleX: obj.scaleX * scale, scaleY: obj.scaleY * scale,
          absolutePositioned: true
        });
        return cloned;
      });

      mosaicLayer.clipPath = new fabric.Group(finalMaskObjects, { absolutePositioned: true });

      tempCanvas.add(highResImg); 
      tempCanvas.add(mosaicLayer);
      tempCanvas.renderAll();

      const dataURL = tempCanvas.toDataURL({ format: 'png', quality: 1 });
      tempCanvas.dispose();

      // 3. 应用并补偿视口
      bgImage.setSrc(dataURL, () => {
        const newZoom = prevZoom / scale;
        bgImage.set({
          scaleX: 1, scaleY: 1, angle: 0,
          originX: 'center', originY: 'center',
          left: canvas.width / 2, top: canvas.height / 2
        });
        bgImage.setCoords();
        canvas.centerObject(bgImage);

        stopMosaicInteraction();

        const newCenterLogic = { x: canvas.width / 2, y: canvas.height / 2 };
        const newPanX = rectCenterScreen.x - newCenterLogic.x * newZoom;
        const newPanY = rectCenterScreen.y - newCenterLogic.y * newZoom;
        canvas.setViewportTransform([newZoom, 0, 0, newZoom, newPanX, newPanY]);

        if (saveHistoryFn) saveHistoryFn();
        canvas.requestRenderAll();
        canvas.fire('zoom:change');
        resolve();
      });
    }, { crossOrigin: 'anonymous' });
  });
};

export const stopMosaicInteraction = () => {
  const canvas = unref(canvasRef);
  if (!canvas) return;
  canvas.off('path:created', onPathCreated);
  canvas.isDrawingMode = false;
  
  if (mosaicPreviewLayer) canvas.remove(mosaicPreviewLayer);
  const shapes = canvas.getObjects().filter(o => o.name === 'mosaic-shape');
  if (shapes.length > 0) canvas.remove(...shapes);

  mosaicPreviewLayer = null;
  maskGroup = null;
  canvas.requestRenderAll();
};

export const cancelMosaic = () => {
  stopMosaicInteraction();
};
</file>

<file path="src/components/modules/ai/AiExpand.vue">

</file>

<file path="src/components/modules/ai/AiGenerate.vue">

</file>

<file path="src/components/modules/ai/index.vue">
<!-- ai工具 -->
  <template>
    ai工具
  </template>
</file>

<file path="src/components/modules/border/index.vue">
<!-- 边框 -->
  <template>
    边框
  </template>
</file>

<file path="src/components/modules/draw/DrawBrush.vue">
<!-- 画笔设置 -->
 <template>
    画笔设置
 </template>
</file>

<file path="src/components/modules/draw/DrawShape.vue">
<!-- 几何形状 -->
  <template>
    几何形状
  </template>
</file>

<file path="src/components/modules/draw/index.vue">
<!-- 绘制 -->
 <template>
    绘制
 </template>
</file>

<file path="src/components/modules/material/index.vue">
<!-- 素材 -->
  <template>
    素材
  </template>
</file>

<file path="src/components/modules/text/index.vue">
<!-- 文本 -->
  <template>
    文本
  </template>
</file>

<file path="src/components/modules/text/TextAdd.vue">

</file>

<file path="src/components/modules/text/TextStyle.vue">
<!-- 文本样式 -->
  <template>
    文本样式
  </template>
</file>

<file path="src/components/modules/watermark/index.vue">
<!-- 水印 -->
  <template>
    水印
  </template>
</file>

<file path="src/composables/useConstraint.js">
import { fabric } from 'fabric';

/**
 * 获取对象在画布上的逻辑矩形（消除缩放和视口偏移的影响）
 * @param {fabric.Object} obj 
 * @param {fabric.Canvas} canvas 
 */
export const getLogicRect = (obj, canvas) => {
    if (!obj || !canvas) return { left: 0, top: 0, width: 0, height: 0 };

    const zoom = canvas.getZoom();
    const vpt = canvas.viewportTransform;

    // getBoundingRect 返回的是屏幕坐标（受 zoom 和 viewport 影响）
    const rawRect = obj.getBoundingRect();

    return {
        left: (rawRect.left - vpt[4]) / zoom,
        top: (rawRect.top - vpt[5]) / zoom,
        width: rawRect.width / zoom,
        height: rawRect.height / zoom
    };
};

/**
 * 核心算法：计算“对象”相对于“容器”的越界修正值
 * 返回具体的 deltaX 和 deltaY，不直接修改对象
 */
export const calculateConstraintOffset = (targetRect, containerRect) => {
    let deltaX = 0;
    let deltaY = 0;

    // 1. 左边界检测
    if (targetRect.left > containerRect.left) {
        deltaX = containerRect.left - targetRect.left;
    }

    // 2. 上边界检测
    if (targetRect.top > containerRect.top) {
        deltaY = containerRect.top - targetRect.top;
    }

    // 3. 右边界检测
    const targetRight = targetRect.left + targetRect.width;
    const containerRight = containerRect.left + containerRect.width;

    // 如果当前已经在右边界内，就不需要修正（除非左边修正导致的连锁反应，但这里简化处理）
    // 逻辑：只有当右边“出界”了（targetRight < containerRight 是指图片没填满右边）
    // 注意：这里的语义是“图片必须覆盖容器”，所以图片右边必须 >= 容器右边
    if (targetRight < containerRight) {
        // 优先保证左对齐，如果左边没问题，才修正右边
        if (deltaX === 0) {
            deltaX = containerRight - targetRight;
        }
    }

    // 4. 下边界检测
    const targetBottom = targetRect.top + targetRect.height;
    const containerBottom = containerRect.top + containerRect.height;

    if (targetBottom < containerBottom) {
        if (deltaY === 0) {
            deltaY = containerBottom - targetBottom;
        }
    }

    return { deltaX, deltaY };
};

/**
 * 动作：瞬间修正对象位置（通常用于 Resize 过程中，或者 mouse:up 不需要动画时）
 */
export const constrainObjectToRect = (obj, containerRect, canvas) => {
    if (!obj || !containerRect || !canvas) return false;

    const objRect = getLogicRect(obj, canvas);
    const boxRect = containerRect.type ? getLogicRect(containerRect, canvas) : containerRect;

    const { deltaX, deltaY } = calculateConstraintOffset(objRect, boxRect);

    if (Math.abs(deltaX) > 0.1 || Math.abs(deltaY) > 0.1) {
        obj.left += deltaX;
        obj.top += deltaY;
        obj.setCoords(); // 重要：更新点击区域
        return true; // 发生了修正
    }
    return false; // 无需修正
};

/**
 * 动作：带动画的平滑回弹（完善版）
 * 适用场景：拼图拖拽松手、图片移动松手
 */
export const animateRebound = (obj, containerRect, canvas) => {
    if (!obj || !containerRect || !canvas) return;

    // 1. 计算需要的修正值
    const objRect = getLogicRect(obj, canvas);
    const boxRect = containerRect.type ? getLogicRect(containerRect, canvas) : containerRect;

    const { deltaX, deltaY } = calculateConstraintOffset(objRect, boxRect);

    // 2. 如果偏移量很小，忽略
    if (Math.abs(deltaX) < 0.5 && Math.abs(deltaY) < 0.5) return;

    // 3. 计算目标坐标
    const targetLeft = obj.left + deltaX;
    const targetTop = obj.top + deltaY;

    // 4. 执行 Fabric 动画
    obj.animate({
        left: targetLeft,
        top: targetTop
    }, {
        duration: 300, // 动画时长 300ms
        onChange: canvas.requestRenderAll.bind(canvas), // 每一帧都重绘
        onComplete: () => {
            obj.setCoords(); // 动画结束必须更新坐标，否则点击区域会错位
            canvas.requestRenderAll();
        },
        // 使用指数缓动，物理感更强 (easeOutExpo)
        easing: fabric.util.ease.easeOutExpo
    });
};
</file>

<file path="src/composables/useKeyboardShortcuts.js">
import { onMounted, onUnmounted } from 'vue';

export function useKeyboardShortcuts(actions) {
  
  const handleKeydown = (e) => {
    // 1. 🛡️ 避开输入框：如果用户正在打字，不触发快捷键
    const activeTag = document.activeElement.tagName.toUpperCase();
    if (activeTag === 'INPUT' || activeTag === 'TEXTAREA') {
      return;
    }

    const isCmd = e.ctrlKey || e.metaKey; // Windows用Ctrl, Mac用Command
    const isShift = e.shiftKey;
    const key = e.key.toLowerCase(); // 统一转小写判断

    // === 组合键 (Cmd/Ctrl + ...) ===
    if (isCmd) {
      switch (key) {
        // --- 基础编辑 ---
        case 'c': 
          e.preventDefault(); 
          actions.copyActive();
          break;
          
        case 'v': 
          e.preventDefault();
          actions.pasteActive(); // 自动触发"键盘偏移粘贴"
          break;
        
        case 'x': // 剪切
          e.preventDefault();
          actions.cutActive();
          break;

        case 'z': // 撤销 & 重做
          e.preventDefault();
          if (isShift) {
            actions.redo && actions.redo(); // 支持 Ctrl+Shift+Z 重做
          } else {
            actions.undo && actions.undo();
          }
          break;
          
        case 'y': // 重做 (Windows 习惯)
          e.preventDefault();
          actions.redo && actions.redo();
          break;

        case 'a': // 全选 (预留)
          e.preventDefault();
          // actions.selectAll();
          break;

        case 's': // 保存 (拦截浏览器保存)
          e.preventDefault();
          // actions.saveCanvas(); 
          break;
          
        // --- 锁定 (Ctrl + Shift + L) ---
        case 'l': 
          if (isShift) {
            e.preventDefault(); // 防止浏览器跳到地址栏
            actions.toggleLock();
          }
          break;
      }
    } 
    
    // === 单键或 Shift 组合键 (不按 Ctrl) ===
    else {
      switch (e.key) { // 这里区分大小写或者用 key code 更准确，这里直接用字符
        // --- 删除 ---
        case 'Delete':
        case 'Backspace':
          actions.deleteActive();
          break;

        // --- 图层层级 (关键) ---
        case '[': // 左中括号
          if (isShift) {
             actions.moveLayer('back'); // Shift + [ = 置底
          } else {
             actions.moveLayer('backward'); // [ = 下移一层
          }
          break;

        case ']': // 右中括号
          if (isShift) {
             actions.moveLayer('front'); // Shift + ] = 置顶
          } else {
             actions.moveLayer('forward'); // ] = 上移一层
          }
          break;
      }
    }
  };

  onMounted(() => {
    window.addEventListener('keydown', handleKeydown);
  });

  onUnmounted(() => {
    window.removeEventListener('keydown', handleKeydown);
  });
}
</file>

<file path="src/composables/useObjectActions.js">
import { inject, unref, reactive, readonly } from 'vue';
import { toast } from '@/utils/toast'; 

// 1. 定义全局剪贴板状态 (放在函数外，保证跨组件共享)
const clipboardState = reactive({
    hasContent: false, 
    data: null         
});

export function useObjectActions() {
    const canvasAPI = inject('canvasAPI');
    
    const getContext = () => {
        const canvas = unref(canvasAPI?.canvas);
        const activeObj = canvas?.getActiveObject();
        return { canvas, activeObj };
    };

    // === 1. 删除 ===
    const deleteActive = () => {
        const { canvas, activeObj } = getContext();
        if (!canvas || !activeObj) return;
        
        if (activeObj.type === 'activeSelection') {
            activeObj.forEachObject(obj => canvas.remove(obj));
            canvas.discardActiveObject();
        } else {
            canvas.remove(activeObj);
        }
        canvas.requestRenderAll();
        canvasAPI.saveHistory && canvasAPI.saveHistory();
    };

    // === 2. 复制 ===
    const copyActive = () => {
        const { activeObj } = getContext();
        if (!activeObj) return;
        
        activeObj.clone((cloned) => {
            // 存入全局状态
            clipboardState.data = cloned;
            clipboardState.hasContent = true; 
            toast.success('已复制');
        });
    };

    // === 3. 剪切 ===
    const cutActive = () => {
        const { canvas, activeObj } = getContext();
        if (!activeObj) return;
        
        activeObj.clone((cloned) => {
            clipboardState.data = cloned;
            clipboardState.hasContent = true;
            
            // 复制后删除原对象
            if (activeObj.type === 'activeSelection') {
                activeObj.forEachObject(obj => canvas.remove(obj));
                canvas.discardActiveObject();
            } else {
                canvas.remove(activeObj);
            }
            canvas.requestRenderAll();
            canvasAPI.saveHistory && canvasAPI.saveHistory();
            toast.success('已剪切');
        });
    };

    // === 4. 粘贴 (核心修改逻辑) ===
    const pasteActive = (point = null) => {
        // 从全局状态读取
        if (!clipboardState.data) {
            return;
        }

        const { canvas } = getContext();
        if (!canvas) return;

        clipboardState.data.clone((clonedObj) => {
            canvas.discardActiveObject();

            clonedObj.set({
                evented: true,
            });

            if (point) {
                // 情况 A: 右键定点粘贴
                clonedObj.set({
                    left: point.x,
                    top: point.y,
                    originX: 'left',
                    originY: 'top',
                });
            } else {
                // 情况 B: 键盘快捷键粘贴 (自动偏移)
                clonedObj.set({
                    left: clonedObj.left + 20,
                    top: clonedObj.top + 20,
                    originX: 'left',
                    originY: 'top',
                });
            }

            if (clonedObj.type === 'activeSelection') {
                clonedObj.canvas = canvas;
                clonedObj.forEachObject((obj) => {
                    canvas.add(obj);
                });
                clonedObj.setCoords();
            } else {
                canvas.add(clonedObj);
            }
            
            canvas.setActiveObject(clonedObj);
            canvas.requestRenderAll();
            canvasAPI.saveHistory && canvasAPI.saveHistory();
            
            // 更新剪贴板引用，支持连续粘贴
            clipboardState.data = clonedObj; 
        });
    };

    // === 5. 锁定/解锁 ===
    const toggleLock = () => {
        const { canvas, activeObj } = getContext();
        if (!activeObj) return;

        const isLocked = !activeObj.lockMovementX;
        
        activeObj.set({
            lockMovementX: isLocked,
            lockMovementY: isLocked,
            lockRotation: isLocked,
            lockScalingX: isLocked,
            lockScalingY: isLocked
        });

        if (isLocked) {
             activeObj.selectable = true; 
             toast.success('对象已锁定');
        } else {
             toast.success('对象已解锁');
        }
        
        canvas.requestRenderAll();
        canvasAPI.saveHistory && canvasAPI.saveHistory();
        return isLocked;
    };

    // === 6. 图层调整 (保留所有逻辑) ===
    const moveLayer = (direction) => {
        const { canvas, activeObj } = getContext();
        if (!activeObj) return;

        const objects = canvas.getObjects();
        // 查找主图位置，确保不覆盖主图
        const mainImgIndex = objects.findIndex(o => o.isMainImage);
        const floorIndex = mainImgIndex >= 0 ? mainImgIndex + 1 : 0;
        const currentIndex = objects.indexOf(activeObj);

        switch (direction) {
            case 'front': 
                activeObj.bringToFront(); 
                break;
            case 'back': 
                if (currentIndex > floorIndex) activeObj.moveTo(floorIndex);
                break;
            case 'forward': 
                activeObj.bringForward(); 
                break;
            case 'backward': 
                if (currentIndex > floorIndex) {
                    activeObj.sendBackwards();
                    // 防止被送到底图下面
                    const newIndex = canvas.getObjects().indexOf(activeObj);
                    if (newIndex <= mainImgIndex && mainImgIndex !== -1) {
                         activeObj.moveTo(floorIndex);
                    }
                }
                break;
        }
        canvas.requestRenderAll();
        canvasAPI.saveHistory && canvasAPI.saveHistory();
    };

    return {
        clipboardState: readonly(clipboardState),
        deleteActive,
        copyActive,
        cutActive,
        pasteActive,
        toggleLock,
        moveLayer
    };
}
</file>

<file path="src/composables/useOffscreenHelper.js">
import { fabric } from 'fabric';

/**
 * 通用：高保真离屏渲染器
 * @param {fabric.Image} originalImageObj 画布上的源图片对象（用于获取原图 URL 和当前状态）
 * @param {Number} targetWidth 目标导出宽度
 * @param {Number} targetHeight 目标导出高度
 * @param {Function} transformCallback 回调函数，让你在离屏 canvas 上调整图片参数
 * @returns {Promise<string>} 返回生成的 Base64
 */
export const renderHighResSnapshot = (originalImageObj, targetWidth, targetHeight, transformCallback) => {
    return new Promise((resolve) => {
        const originalSrc = originalImageObj.getSrc();

        // 1. 创建离屏画布
        const tempCanvas = new fabric.StaticCanvas(null, {
            width: targetWidth,
            height: targetHeight,
            backgroundColor: 'transparent'
        });

        // 2. 加载原图（避免使用缓存的缩略图）
        fabric.Image.fromURL(originalSrc, (highResImg) => {

            // 3. 执行调用者的自定义变换逻辑
            if (transformCallback) {
                transformCallback(highResImg, tempCanvas);
            } else {
                // 默认行为：居中填满
                highResImg.set({
                    originX: 'center', originY: 'center',
                    left: targetWidth / 2, top: targetHeight / 2
                });
                // 简单的 Cover 逻辑...
            }

            tempCanvas.add(highResImg);
            tempCanvas.renderAll();

            // 4. 导出
            const dataURL = tempCanvas.toDataURL({ format: 'png', quality: 1 });

            // 5. 清理内存
            tempCanvas.dispose();

            resolve(dataURL);
        }, { crossOrigin: 'anonymous' });
    });
};
</file>

<file path="src/config/shortcuts.js">
// src/config/shortcuts.js

export const SHORTCUT_GROUPS = [
  {
    title: '基础编辑 (Editing)',
    items: [
      { label: '复制', keys: ['Ctrl', 'C'] },
      { label: '粘贴', keys: ['Ctrl', 'V'] },
      { label: '剪切', keys: ['Ctrl', 'X'] },
      { label: '撤销', keys: ['Ctrl', 'Z'] },
      { label: '重做', keys: ['Ctrl', 'Y'] },
      { label: '删除', keys: ['Delete'] },
    ]
  },
  {
    title: '图层管理 (Layers)',
    items: [
      { label: '上移一层', keys: [']'] },
      { label: '下移一层', keys: ['['] },
      { label: '置顶', keys: ['Shift', ']'] },
      { label: '置底', keys: ['Shift', '['] },
      { label: '锁定/解锁', keys: ['Ctrl', 'Shift', 'L'] },
    ]
  },
  {
    title: '画布视图 (View)',
    items: [
      { label: '放大', keys: ['Ctrl', '+'] }, // 假设你未来会加这个
      { label: '缩小', keys: ['Ctrl', '-'] },
      { label: '重置缩放', keys: ['Ctrl', '0'] },
      { label: '平移画布', keys: ['Space', 'Drag'] },
    ]
  }
];
</file>

<file path="src/index.js">
import EditorLayout from './components/layout/EditorLayout.vue';
import './style.css'; // 确保样式被引入

// 导出主组件
export { EditorLayout };
// 默认导出
export default EditorLayout;
</file>

<file path=".spec/feature-ruler-interaction.md">

</file>

<file path="index.html">
<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <link rel="icon" type="image/svg+xml" href="/vite.svg" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>image-editor</title>
  </head>
  <body>
    <div id="app"></div>
    <script type="module" src="/src/main.js"></script>
  </body>
</html>
</file>

<file path="src/App.vue">
<template>
  <EditorLayout />
</template>

<script setup>
import EditorLayout from './components/layout/EditorLayout.vue';
</script>

<style>
html,
body {
  margin: 0;
  padding: 0;
  width: 100%;
  height: 100%;
  overflow: hidden;
  /* 防止出现滚动条 */
}

#app {
  width: 100%;
  height: 100%;
}

.app-wrapper {
  width: 100vw;
  /* 强制视口宽度 */
  height: 100vh;
  /* 强制视口高度 */
  display: flex;
  flex-direction: column;
}
</style>
</file>

<file path="src/components/modules/adjust/AdjustMosaic.vue">
<template>
  <div class="tool-group">
    <div class="tool-item" :class="{ 'is-expanded': isExpanded }" @click="$emit('toggle')">
      <div class="left">
        <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
          <rect x="3" y="3" width="7" height="7" /><rect x="14" y="3" width="7" height="7" />
          <rect x="14" y="14" width="7" height="7" /><rect x="3" y="14" width="7" height="7" />
        </svg>
        <span>马赛克</span>
      </div>
      <div class="right-icon">
        <svg class="arrow" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
          <path d="m9 18 6-6-6-6" />
        </svg>
      </div>
    </div>

    <div v-if="isExpanded" class="tool-content filter-panel">
      <div class="mode-row">
        <div class="mode-btn" :class="{ active: activeMode === 'path' }" @click="setMode('path')" title="涂抹">
          <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M12 3c-1.1 0-2 .9-2 2s.9 2 2 2 2-.9 2-2-.9-2-2-2zm0 14c-1.1 0-2 .9-2 2s.9 2 2 2 2-.9 2-2-.9-2-2-2zM4 11c-1.1 0-2 .9-2 2s.9 2 2 2 2-.9 2-2-.9-2-2-2zm16 0c-1.1 0-2 .9-2 2s.9 2 2 2 2-.9 2-2-.9-2-2-2z"/></svg>
        </div>
        <div class="mode-btn" :class="{ active: activeMode === 'rect' }" @click="setMode('rect')" title="矩形">
          <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><rect x="3" y="3" width="18" height="18" rx="2" /></svg>
        </div>
        <div class="mode-btn" :class="{ active: activeMode === 'circle' }" @click="setMode('circle')" title="圆形">
          <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><circle cx="12" cy="12" r="9" /></svg>
        </div>
      </div>

      <div class="intensity-section">
        <div class="label-row">
          <span>强度</span>
          <input type="number" v-model.number="intensity" class="ie-input-number" @change="updateConfig">
        </div>
        <input type="range" v-model.number="intensity" min="4" max="100" class="ie-slider" @input="updateConfig">
      </div>

      <div class="action-buttons">
        <button class="ie-btn ie-primary full" @click="handleApply" :disabled="loading">
          {{ loading ? '处理中...' : '确定应用' }}
        </button>
        <button class="ie-btn full" @click="handleCancel">取消</button>
      </div>
    </div>
  </div>
</template>

<script setup>
import { ref, inject, watch, onMounted, onUnmounted } from 'vue';
import { registerMosaicModule, startMosaicInteraction, applyMosaic, cancelMosaic } from './useCanvasMosaic';

const props = defineProps({ isExpanded: Boolean });
const emit = defineEmits(['toggle']);
const canvasAPI = inject('canvasAPI');

const activeMode = ref('path');
const intensity = ref(15);
const loading = ref(false);

const setMode = (mode) => {
  activeMode.value = mode;
  startMosaicInteraction(mode, intensity.value);
};

const updateConfig = () => {
  startMosaicInteraction(activeMode.value, intensity.value);
};

const handleApply = async () => {
  loading.value = true;
  await applyMosaic(intensity.value);
  loading.value = false;
  emit('toggle');
};

const handleCancel = () => {
  cancelMosaic();
  emit('toggle');
};

watch(() => props.isExpanded, (val) => {
  if (val) setMode('path');
  else cancelMosaic();
});

onMounted(() => {
  if (canvasAPI?.canvas) registerMosaicModule(canvasAPI.canvas, canvasAPI.saveHistory);
});

// 组件销毁时确保清理交互状态
onUnmounted(() => {
  cancelMosaic();
});
</script>

<style scoped>
.filter-panel { padding: 16px; }
.mode-row { display: flex; justify-content: space-between; margin-bottom: 24px; gap: 12px; }
.mode-btn { 
  flex: 1; height: 44px; display: flex; align-items: center; justify-content: center; 
  border-radius: 8px; background: #f5f7fa; cursor: pointer; border: 1px solid transparent; transition: 0.2s; 
}
.mode-btn:hover { background: #eef1f6; color: #333; }
.mode-btn.active { background: #ecf5ff; border-color: var(--ie-primary-color); color: var(--ie-primary-color); }

.intensity-section { margin-bottom: 24px; }
/* label-row 继承宪法规范，这里微调间距 */
.label-row { display: flex; justify-content: space-between; align-items: center; margin-bottom: 12px; font-size: 13px; color: #606266; }

.action-buttons { display: flex; gap: 10px; }
.full { flex: 1; }
</style>
</file>

<file path="src/components/modules/adjust/useCanvasColor.js">
// src/components/modules/adjust/useCanvasColor.js
import { unref } from "vue";
import { fabric } from "fabric";

let canvasRef = null;
let saveHistoryFn = null;
let originalFilters = []; // 用于取消时恢复

export const registerColorModule = (canvas, saveHistory) => {
    canvasRef = canvas;
    saveHistoryFn = saveHistory;
};

/**
 * 核心：应用组合滤镜
 * @param {Object} params - 包含亮度、对比度等数值的对象
 */
export const applyColorAdjust = (params) => {
    const canvas = unref(canvasRef);
    if (!canvas) return;

    const bgImage = canvas.getObjects().find(o => o.type === 'image');
    if (!bgImage) return;

    // 记录初始状态用于恢复
    if (originalFilters.length === 0 && bgImage.filters.length > 0) {
        originalFilters = [...bgImage.filters];
    }

    const filters = [];

    // 1. 模糊 (-100 ~ 0) / 锐化 (0 ~ 100)
    if (params.blurSharpen < 0) {
        filters.push(new fabric.Image.filters.Blur({ blur: Math.abs(params.blurSharpen) / 100 }));
    } else if (params.blurSharpen > 0) {
        filters.push(new fabric.Image.filters.Convolute({
            matrix: [0, -1, 0, -1, 5, -1, 0, -1, 0] // 锐化矩阵
        }));
    }

    // 2. 饱和度 (-100 ~ 100 -> -1 ~ 1)
    if (params.saturation !== 0) {
        filters.push(new fabric.Image.filters.Saturation({ saturation: params.saturation / 100 }));
    }

    // 3. 亮度 (-100 ~ 100 -> -1 ~ 1)
    if (params.brightness !== 0) {
        filters.push(new fabric.Image.filters.Brightness({ brightness: params.brightness / 100 }));
    }

    // 4. 对比度 (-100 ~ 100 -> -1 ~ 1)
    if (params.contrast !== 0) {
        filters.push(new fabric.Image.filters.Contrast({ contrast: params.contrast / 100 }));
    }

    // 5. 色温 (通过 ColorMatrix 模拟)
    if (params.temperature !== 0) {
        const temp = params.temperature / 100;
        filters.push(new fabric.Image.filters.ColorMatrix({
            matrix: [
                1 + temp, 0, 0, 0, 0, // R
                0, 1, 0, 0, 0,        // G
                0, 0, 1 - temp, 0, 0, // B
                0, 0, 0, 1, 0         // A
            ]
        }));
    }

    // 6. 色调 (-100 ~ 100 -> -1 ~ 1)
    if (params.hue !== 0) {
        filters.push(new fabric.Image.filters.HueRotation({ rotation: params.hue / 100 }));
    }

    bgImage.filters = filters;
    bgImage.applyFilters();
    canvas.requestRenderAll();
};

export const cancelColorAdjust = () => {
    const canvas = unref(canvasRef);
    const bgImage = canvas?.getObjects().find(o => o.type === 'image');
    if (bgImage) {
        bgImage.filters = [...originalFilters];
        bgImage.applyFilters();
        canvas.requestRenderAll();
    }
    originalFilters = [];
};

export const commitColorAdjust = () => {
    if (saveHistoryFn) saveHistoryFn();
    originalFilters = [];
};
</file>

<file path="src/components/modules/adjust/useCanvasColorOverlay.js">
// src/components/modules/adjust/useCanvasColorOverlay.js
import { unref } from "vue";
import { fabric } from "fabric";

let canvasRef = null;
let saveHistoryFn = null;
let backupFilters = [];
let backupColor = null;    // ✅ 新增：备份颜色
let backupOpacity = 30;


export const registerColorOverlayModule = (canvas, saveHistory) => {
    canvasRef = canvas;
    saveHistoryFn = saveHistory;
};


/**
 * 备份当前状态（包含滤镜数组和元数据）
 */
export const backupCurrentColorOverlay = () => {
    const canvas = unref(canvasRef);
    const bgImage = canvas?.getObjects().find(o => o.type === 'image');
    if (bgImage) {
        // 深拷贝滤镜数组
        backupFilters = [...bgImage.filters];
        // 备份元数据
        backupColor = bgImage._lastOverlayColor || null;
        backupOpacity = bgImage._lastOverlayOpacity ?? 30;
    }
};

/**
 * 应用颜色叠加：记录元数据到图片对象
 */
export const applyColorOverlay = (color, opacity = 30) => {
    const canvas = unref(canvasRef);
    if (!canvas) return;

    const bgImage = canvas.getObjects().find(o => o.type === 'image');
    if (!bgImage) return;

    // 记录元数据，用于 UI 状态同步
    bgImage._lastOverlayColor = color;
    bgImage._lastOverlayOpacity = opacity;

    const existingIndex = bgImage.filters.findIndex(f => f instanceof fabric.Image.filters.BlendColor);

    if (!color) {
        if (existingIndex > -1) {
            bgImage.filters.splice(existingIndex, 1);
        }
    } else {
        const filter = new fabric.Image.filters.BlendColor({
            color: color,
            mode: 'tint',
            alpha: opacity / 100
        });

        if (existingIndex > -1) {
            bgImage.filters[existingIndex] = filter;
        } else {
            bgImage.filters.push(filter);
        }
    }

    bgImage.applyFilters();
    canvas.requestRenderAll();
};

/**
 * 取消修改：还原滤镜数组和元数据
 */
export const cancelColorOverlayChange = () => {
    const canvas = unref(canvasRef);
    const bgImage = canvas?.getObjects().find(o => o.type === 'image');
    if (bgImage) {
        bgImage.filters = [...backupFilters];
        // 还原元数据
        bgImage._lastOverlayColor = backupColor;
        bgImage._lastOverlayOpacity = backupOpacity;
        
        bgImage.applyFilters();
        canvas.requestRenderAll();
    }
    backupFilters = [];
};

export const commitColorOverlay = () => {
    if (saveHistoryFn) saveHistoryFn(); // 保存历史记录
    backupFilters = [];
};
</file>

<file path="src/components/modules/adjust/useCanvasRuler.js">
import { ref, unref, watch, nextTick } from 'vue';
import { fabric } from 'fabric';

// === 模块级单例状态 ===
let canvasRef = null;
let saveHistoryFn = null;

// 响应式状态 (供 UI 双向绑定)
const isDrawing = ref(false);
const rulerConfig = ref({
    value: 20,
    unit: 'cm',
    color: '#ff0000',
    opacity: 100,
    fontSize: 24,
    fontFamily: 'Arial',
    strokeWidth: 4,
    showBg: true,
    capStyle: 'line'
});

// === 1. 注册与初始化 ===
export const registerRulerModule = (canvas, saveHistory) => {
    canvasRef = canvas;
    saveHistoryFn = saveHistory;

    const c = unref(canvas);
    if (c) {
        // 绑定选择事件，实现“点击标尺回显属性”
        c.on('selection:created', onSelectionChanged);
        c.on('selection:updated', onSelectionChanged);
        c.on('selection:cleared', onSelectionCleared);
    }
};

// === 2. 事件监听逻辑 ===
const onSelectionChanged = (e) => {
    const activeObj = e.selected?.[0];
    if (activeObj && activeObj.isRuler) {
        // 回显属性到面板
        const items = activeObj.getObjects();
        rulerConfig.value.value = activeObj._rulerValue ?? 20;
        rulerConfig.value.unit = activeObj._rulerUnit ?? 'cm';
        rulerConfig.value.opacity = (activeObj.opacity || 1) * 100;
        
        // 线条样式回显 (取 Line 对象)
        if (items[0]) {
            rulerConfig.value.color = items[0].stroke;
            rulerConfig.value.strokeWidth = items[0].strokeWidth;
        }
        // 文字样式回显 (取 Text 对象)
        if (items[3]) {
            rulerConfig.value.fontSize = items[3].fontSize;
            rulerConfig.value.fontFamily = items[3].fontFamily;
            rulerConfig.value.showBg = !!items[3].backgroundColor;
        }
    }
};

const onSelectionCleared = () => {
    // 可选：清空或保持最后一次配置
    // rulerConfig.value.value = 20; 
};

// === 3. 绘制交互流程 ===
let startPoint = null;
let activeLine = null;

export const startDrawMode = () => {
    const canvas = unref(canvasRef);
    if (!canvas) return;
    
    isDrawing.value = true;
    
    // 锁定所有对象，防止误触
    canvas.discardActiveObject();
    canvas.selection = false;
    canvas.defaultCursor = 'crosshair';
    canvas.hoverCursor = 'crosshair';
    
    // 临时锁定其他对象
    canvas.getObjects().forEach(obj => {
        obj._prevSelectable = obj.selectable;
        obj.selectable = false;
    });

    canvas.on('mouse:down', onMouseDown);
};

export const stopDrawMode = () => {
    const canvas = unref(canvasRef);
    if (!canvas) return;

    isDrawing.value = false;
    
    canvas.selection = true;
    canvas.defaultCursor = 'default';
    canvas.hoverCursor = 'move';
    
    // 恢复对象可选中
    canvas.getObjects().forEach(obj => {
        if (obj._prevSelectable !== undefined) {
            obj.selectable = obj._prevSelectable;
            delete obj._prevSelectable;
        }
    });

    canvas.off('mouse:down', onMouseDown);
    canvas.off('mouse:move', onMouseMove);
    canvas.off('mouse:up', onMouseUp);
};

const onMouseDown = (opt) => {
    const canvas = unref(canvasRef);
    const pointer = canvas.getPointer(opt.e);
    startPoint = { x: pointer.x, y: pointer.y };
    
    activeLine = new fabric.Line([startPoint.x, startPoint.y, startPoint.x, startPoint.y], {
        stroke: rulerConfig.value.color,
        strokeWidth: rulerConfig.value.strokeWidth,
        strokeDashArray: [5, 5],
        selectable: false,
        evented: false
    });
    
    canvas.add(activeLine);
    canvas.on('mouse:move', onMouseMove);
    canvas.on('mouse:up', onMouseUp);
};

const onMouseMove = (opt) => {
    if (!activeLine) return;
    const canvas = unref(canvasRef);
    const pointer = canvas.getPointer(opt.e);
    activeLine.set({ x2: pointer.x, y2: pointer.y });
    canvas.requestRenderAll();
};

const onMouseUp = () => {
    const canvas = unref(canvasRef);
    canvas.off('mouse:move', onMouseMove);
    canvas.off('mouse:up', onMouseUp);

    if (!activeLine) return;

    const endPoint = { x: activeLine.x2, y: activeLine.y2 };
    canvas.remove(activeLine);
    activeLine = null;

    // 防止误触点击
    const dist = Math.sqrt(Math.pow(endPoint.x - startPoint.x, 2) + Math.pow(endPoint.y - startPoint.y, 2));
    if (dist > 10) {
        createRulerObject(startPoint, endPoint);
    }
    
    // 绘制一次后自动退出
    stopDrawMode();
};

// === 4. 创建标尺对象 (Group) ===
const createRulerObject = (start, end) => {
    const canvas = unref(canvasRef);
    const cfg = rulerConfig.value;
    const color = cfg.color;
    
    // 1. 主线条
    const line = new fabric.Line([start.x, start.y, end.x, end.y], {
        stroke: color,
        strokeWidth: cfg.strokeWidth,
        originX: 'center', originY: 'center'
    });

    // 2. 计算几何
    const dx = end.x - start.x;
    const dy = end.y - start.y;
    const angle = Math.atan2(dy, dx) * (180 / Math.PI);
    const midX = (start.x + end.x) / 2;
    const midY = (start.y + end.y) / 2;

    // 3. 端点 (Cap)
    const capSize = 10 + cfg.strokeWidth;
    const startCap = new fabric.Line([0, -capSize, 0, capSize], {
        stroke: color, strokeWidth: cfg.strokeWidth,
        left: start.x, top: start.y,
        angle: angle,
        originX: 'center', originY: 'center'
    });
    const endCap = new fabric.Line([0, -capSize, 0, capSize], {
        stroke: color, strokeWidth: cfg.strokeWidth,
        left: end.x, top: end.y,
        angle: angle,
        originX: 'center', originY: 'center'
    });

    // 4. 文字
    const textStr = `${cfg.value} ${cfg.unit}`;
    const textObj = new fabric.Text(textStr, {
        fontSize: cfg.fontSize,
        fontFamily: cfg.fontFamily,
        fill: color,
        backgroundColor: cfg.showBg ? 'rgba(255,255,255,0.8)' : '',
        originX: 'center', originY: 'bottom',
        left: midX,
        top: midY - 10,
        angle: angle > 90 || angle < -90 ? angle + 180 : angle
    });

    // 5. 组合 Group
    const group = new fabric.Group([line, startCap, endCap, textObj], {
        left: midX, top: midY,
        originX: 'center', originY: 'center',
        opacity: cfg.opacity / 100,
        id: 'ruler-group',
        
        // ✨✨✨ 这里是关键修改 ✨✨✨
        // 1. 告诉路由系统：选中我时，请自动打开 'ruler' 这个二级折叠面板
        customTab: 'ruler', 
        // 2. (可选) 强制指定一级面板为 'adjust' (防止被误判为 border)
        customTool: 'adjust', 

        isRuler: true, // 关键标识
        _rulerValue: cfg.value, // 持久化数据
        _rulerUnit: cfg.unit,
        lockScalingY: true, 
        lockUniScaling: true 
    });

    group.setControlsVisibility({
        mt: false, mb: false, ml: true, mr: true, 
        bl: false, br: false, tl: false, tr: false,
        mtr: true 
    });

    canvas.add(group);
    canvas.setActiveObject(group);
    if (saveHistoryFn) saveHistoryFn();
};

// === 5. 更新选中标尺 ===
export const updateActiveRuler = () => {
    const canvas = unref(canvasRef);
    if (!canvas) return;

    const obj = canvas.getActiveObject();
    if (!obj || !obj.isRuler) return;

    const cfg = rulerConfig.value;
    const items = obj.getObjects();
    
    // 更新内部子对象
    [0, 1, 2].forEach(i => {
        if (items[i]) items[i].set({ stroke: cfg.color, strokeWidth: cfg.strokeWidth });
    });
    
    if (items[3]) { // Text
        items[3].set({ 
            text: `${cfg.value} ${cfg.unit}`,
            fill: cfg.color,
            fontSize: cfg.fontSize,
            fontFamily: cfg.fontFamily,
            backgroundColor: cfg.showBg ? 'rgba(255,255,255,0.8)' : ''
        });
    }

    obj.set({ opacity: cfg.opacity / 100 });
    obj._rulerValue = cfg.value;
    obj._rulerUnit = cfg.unit;

    canvas.requestRenderAll();
    if (saveHistoryFn) saveHistoryFn();
};

// 导出 Vue 响应式数据
export { rulerConfig, isDrawing };
</file>

<file path="src/config/theme.js">
// src/config/theme.js

/**
 * 🎨 Design Token Source (Single Source of Truth)
 * 供 Canvas (JS) 和 UI (CSS) 共同使用
 */
export const THEME = {
    colors: {
        // 品牌色 (对应 style.css 中的 --ie-primary-color)
        primary: '#409eff',
        primaryHover: '#66b1ff',

        // 基础色
        bg: '#242424',            // 画布背景
        panel: '#1e1e1e',         // 工具栏背景 (如果你需要区分的话)
        text: 'rgba(255, 255, 255, 0.87)',
        border: '#dcdfe6',

        // Canvas 交互专用 (JS 读取)
        selectionBorder: '#409eff',
        selectionFill: 'rgba(64, 158, 255, 0.1)',
    },

    // 字体栈
    fontFamily: 'system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif',
};

/**
 * 注入主题变量到 CSS
 * @param {HTMLElement} [targetElement] - 如果传入，只注入该元素的 style；否则注入到 document.documentElement
 */
export const applyTheme = (targetElement) => {
    const root = targetElement || document.documentElement;
    const { colors, fontFamily } = THEME;

    // 注入核心变量
    root.style.setProperty('--ie-primary-color', colors.primary);
    root.style.setProperty('--ie-bg-color', colors.bg);
    root.style.setProperty('--ie-text-color', colors.text);
    root.style.setProperty('--ie-border-color', colors.border);
    root.style.setProperty('--ie-font-family', fontFamily);
    console.log(targetElement);
    console.log(`🎨 Theme applied to ${targetElement ? 'SDK Container' : 'Global Root'}`);
};
</file>

<file path="src/utils/toast.js">
export const toast = {
    show(text, type = 'info') {
        const div = document.createElement('div');
        div.className = 'ie-toast';
        div.innerText = text;
        // 简单区分颜色
        if (type === 'error') div.style.background = 'rgba(255, 77, 79, 0.9)';
        if (type === 'success') div.style.background = 'rgba(82, 196, 26, 0.9)';

        document.body.appendChild(div);
        setTimeout(() => {
            div.style.transition = 'opacity 0.3s';
            div.style.opacity = '0';
            setTimeout(() => div.remove(), 300);
        }, 2000);
    },
    success(text) { this.show(text, 'success'); },
    warning(text) { this.show(text, 'warning'); },
    error(text) { this.show(text, 'error'); },
    info(text) { this.show(text, 'info'); }
};
</file>

<file path=".spec/project-charter.md">
# Project Charter: Image Editor SDK (大秘美图)

> **Version**: 3.8.0 (Integrated Edition)
> **Last Updated**: 2025-12-22
> **Context**: High-performance Web Image Processing SDK
> **Enforcement**: 此文档为最高准则，AI 生成代码必须严格查阅并遵循。

## 1. 项目愿景 (Vision)

构建一个**模块化、高性能**的 Web 端图像处理 SDK。核心架构采用“轻量级核心 (Core) + 功能插件化 (Modules)”的设计模式，支持从基础的裁剪旋转到复杂的 AI 消除、拼图和滤镜处理。

---

## 2. 技术栈与版本约束 (Tech Stack)

> ⚠️ **关键约束**：所有自动生成的代码必须严格遵守以下版本特性。

- **Core Framework**: Vue 3.3+ (Composition API, `<script setup>`)
- **Graphics Engine**: **Fabric.js v5.3.0** (Locked)
  - ❌ **严禁**: 使用 Fabric v6 的 `Canvas` 类名或 Promise-based 渲染。
  - ✅ **必须**: 使用 `new fabric.Canvas()` 等 v5 风格 API。
- **Build Tool**: Vite 7.x
- **Style System**: **Native CSS (Scoped) + CSS Variables**
  - **Color Source**: 遵循 SSOT 原则，颜色必须定义在 `src/config/theme.js`。
  - **Isolation**: 所有样式必须包裹在 `.image-editor-sdk-container` 作用域内。
- **State Management**: **Custom Reactive Singleton**
  - 必须保持响应性，严禁直接解构 State 对象。

---

## 3. 核心架构模式 (Core Architecture Patterns) `Critical`

### 3.1 颜色管理策略 (Color Strategy)

> **原则**: 解决 Canvas (JS) 与 UI (CSS) 颜色不同步问题。

1.  **真理源**: 所有颜色值定义在 `src/config/theme.js` 的 `THEME` 对象中。
2.  **注入机制**: App 挂载时 (`onMounted`)，必须调用 `applyTheme(containerRef)` 将 JS 变量注入为 CSS 变量。
3.  **使用规范**:
    - **UI (Vue/CSS)**: 使用 `var(--ie-primary-color)`。
    - **Canvas (JS)**: 引入 `THEME` 对象，使用 `THEME.colors.primary`。
    - **禁止**: 代码中出现 `#409eff` 等硬编码颜色。

### 3.2 高清离屏渲染 (Offscreen Rendering)

- 所有涉及**导出图片**或**生成 AI 遮罩**的操作，必须使用 `src/composables/useOffscreenHelper.js`，严禁直接对主 Canvas 进行 `toDataURL`。

### 3.3 模块通信 (Event Bus)

- 使用 Fabric Canvas 实例 (`canvas.fire`) 作为唯一事件总线。

---

## 4. 目录结构规范 (Directory Structure)

| 路径                      | 说明                 | 规则                                                                    |
| :------------------------ | :------------------- | :---------------------------------------------------------------------- |
| `src/components/modules/` | **独立功能模块**     | 包含完整业务逻辑 (UI + Canvas 交互)，如 `Crop/`, `Puzzle/`, `Filter/`。 |
| `src/components/tools/`   | **纯 Canvas 工具**   | 仅包含 Fabric.js 的自定义类或交互逻辑，如 `RulerTool.js`。              |
| `src/components/common/`  | **通用 UI 组件**     | 无业务逻辑的纯 UI，如 Slider, Button, Modal。                           |
| `src/composables/`        | **逻辑复用 (Hooks)** | 必须以 `use` 开头，如 `useKeyboardShortcuts.js`。                       |
| `src/config/`             | **静态配置**         | 快捷键定义、拼图模板数据、滤镜参数矩阵、`theme.js`。                    |

---

## 5. UI 开发规范 (UI Design System)

> **原则**: 使用 Scoped CSS 和 CSS 变量，统一视觉风格。

### 5.1 通用类名表 (Common Classes)

| 组件类型       | 类名 (Class Name)  | 样式特征 (Style Specs)                                               |
| :------------- | :----------------- | :------------------------------------------------------------------- |
| **面板容器**   | `.tool-panel`      | `bg: var(--panel-bg)`, 固定宽 280px，白底/深色模式适配，绝对定位右侧 |
| **面板标题**   | `.panel-title`     | 14px, 600 weight, 底部 Margin                                        |
| **控制组**     | `.control-group`   | 包含标签和控件的容器，底部 Margin (24px)                             |
| **属性行**     | `.label-row`       | Flex 布局 (两端对齐)，用于显示 "属性名 - 数值"                       |
| **主要按钮**   | `.btn-primary`     | 100% 宽度，`bg: var(--primary)`，圆角 (4px)                          |
| **次要按钮**   | `.btn-secondary`   | `border: var(--border)`，用于取消或次要操作                          |
| **滑动条**     | `.slider-input`    | 统一宽度的 range input                                               |
| **数值输入框** | `.ie-input-number` | 固定宽 50px，高 28px，居中对齐，无原生箭头，常配合 Slider 使用       |

---

## 6. 开发工作流 (OpenSpec Workflow)

### 6.1 提议 (Proposal)

在开发新功能前，必须在 `.spec/proposals/` 下创建文档，并回答以下“灵魂三问”：

1.  **复用检查**: “我要写的这个辅助函数，`src/utils` 里有没有？UI 组件在 `common` 里有没有？架构模式在 `Section 3` 里有没有？”
2.  **UI 位置**: 在 `ToolPanel` 的哪个位置增加入口？
3.  **交互逻辑**: 拖入画布后的默认行为（居中？自动缩放？）。

### 6.2 实施检查清单 (The "Golden Checklist") [CRITICAL]

- [ ] **Canvas 销毁**: 组件 `onUnmounted` 时是否注销了 fabric 事件监听？
- [ ] **状态清理**: 退出模块时，是否重置了 `activeTool` 和临时图层？
- [ ] **键盘安全**: 新增快捷键是否判断了 `document.activeElement` 以防止输入框冲突？
- [ ] **响应式检查**: 是否错误地使用了 `const { state } = useStore()` 导致响应性丢失？
- [ ] **颜色合规**: 检查代码中是否还残留 `#hex` 硬编码颜色？

---

## 7. 禁区 (Forbidden Zones)

1.  **DOM 操作**: 严禁使用 jQuery 操作 Canvas 内部。
2.  **重型计算**: 严禁在 `mousemove` 中直接运行高开销算法。
3.  **硬编码颜色**: 严禁写死颜色值，必须引用 `THEME` 或 CSS 变量。
</file>

<file path="src/api/ai.js">
// src/api/ai.js

// 默认地址 (作为兜底，防止调用时传空)
const DEFAULT_BASE_URL = 'http://localhost:3000/ai';

export const aiApi = {
  /**
   * 移除背景
   * @param {File} file - 图片文件
   * @param {string} [baseUrl] - 后端 API 基础地址
   * @returns {Promise<string>} - Blob URL
   */
  async removeBackground(file, baseUrl = DEFAULT_BASE_URL) {
    const formData = new FormData();
    formData.append('image', file);

    // 拼接完整的 URL，移除末尾可能多余的斜杠
    const cleanBaseUrl = baseUrl.replace(/\/+$/, '');

    try {
      const response = await fetch(`${cleanBaseUrl}/rembg`, {
        method: 'POST',
        body: formData,
        // fetch 自动处理 multipart/form-data 的 Content-Type，无需手动设置
      });

      if (!response.ok) {
        throw new Error(`请求失败: ${response.status} ${response.statusText}`);
      }

      const blob = await response.blob();
      return URL.createObjectURL(blob);
    } catch (error) {
      console.error('AI API Error:', error);
      throw error;
    }
  },

  /**
   * 图像修复 (Inpaint)
   * @param {Blob} imageBlob 
   * @param {Blob} maskBlob 
   * @param {string} [baseUrl] 
   */
  async inpaint(imageBlob, maskBlob, baseUrl = DEFAULT_BASE_URL) {
    const formData = new FormData();
    formData.append('image', imageBlob);
    formData.append('mask', maskBlob);

    const cleanBaseUrl = baseUrl.replace(/\/+$/, '');

    try {
      const response = await fetch(`${cleanBaseUrl}/inpaint`, {
        method: 'POST',
        body: formData,
      });

      if (!response.ok) {
        throw new Error(`请求失败: ${response.status} ${response.statusText}`);
      }

      const blob = await response.blob();
      return URL.createObjectURL(blob);
    } catch (error) {
      console.error('AI API Error:', error);
      throw error;
    }
  },

  /**
    * AI 智能消除接口
    * @param {string} imageUrl - 原图 URL
    * @param {string} maskBase64 - 遮罩图片 Base64 (黑底白图)
    * @returns {Promise<string>} 处理后的图片 URL
    */
  async inpaint(imageUrl, maskBase64) {
    // 模拟网络延迟
    return new Promise((resolve) => {
      console.log('Calling AI Inpaint API...');
      console.log('Image:', imageUrl.substring(0, 50) + '...');
      console.log('Mask Length:', maskBase64.length);

      setTimeout(() => {
        // ⚠️ 这里目前直接返回原图，仅做流程跑通演示
        // 真实开发请替换为：
        // const formData = new FormData();
        // formData.append('image', ...);
        // formData.append('mask', ...);
        // const res = await fetch('/api/inpaint', { ... });

        resolve(imageUrl);
      }, 2000);
    });
  }
};
</file>

<file path="src/components/common/Modal.vue">
<template>
    <Teleport to="body">
        <Transition name="fade">
            <div v-if="modelValue" class="modal-mask" @click.self="$emit('cancel')">
                <div class="modal-container">
                    <button class="modal-close" title="关闭" @click="$emit('cancel')">×</button>

                    <div class="modal-header">
                        <h3>{{ title }}</h3>
                    </div>
                    <div class="modal-body">
                        <slot>{{ content }}</slot>
                    </div>
                    <div class="modal-footer">
                        <button class="ie-btn btn-secondary" @click="$emit('discard')">不保存</button>
                        <button class="ie-btn btn-primary" @click="$emit('confirm')">保存并退出</button>
                    </div>
                </div>
            </div>
        </Transition>
    </Teleport>
</template>

<script setup>
defineProps({
    modelValue: Boolean,
    title: { type: String, default: '提示' },
    content: String
});
defineEmits(['update:modelValue', 'confirm', 'discard', 'cancel']);
</script>

<style scoped>
.modal-mask {
    position: fixed;
    inset: 0;
    background: rgba(0, 0, 0, 0.5);
    display: flex;
    justify-content: center;
    align-items: center;
    z-index: 9999;
}

.modal-container {
    position: relative;
    background: white;
    border-radius: 12px;
    width: 320px;
    padding: 24px;
    box-shadow: 0 10px 25px rgba(0, 0, 0, 0.2);
}

.modal-header h3 {
    margin: 0 0 16px;
    font-size: 18px;
    color: #333;
}

.modal-close {
    position: absolute;
    top: 4px;
    right: 4px;
    background: none;
    border: none;
    font-size: 32px;
    color: #909399;
    cursor: pointer;
    padding: 0;
    width: 32px;
    height: 32px;
    line-height: 1;
}

.modal-close:hover {
    color: #606266;
}

.modal-body {
    font-size: 14px;
    color: #666;
    margin-bottom: 24px;
    line-height: 1.5;
}

.modal-footer {
    display: flex;
    gap: 12px;
    justify-content: flex-end;
}

.ie-btn {
    padding: 8px 16px;
    border-radius: 6px;
    cursor: pointer;
    border: none;
    font-size: 14px;
}

.btn-primary {
    background: var(--ie-primary-color);
    color: white;
}

.btn-secondary {
    background: #f4f4f5;
    color: #606266;
}

.fade-enter-active,
.fade-leave-active {
    transition: opacity 0.3s ease;
}

.fade-enter-from,
.fade-leave-to {
    opacity: 0;
}
</style>
</file>

<file path="src/components/modules/adjust/AdjustColor.vue">
<template>
    <div class="tool-group">
        <div class="tool-item" :class="{ 'is-expanded': isExpanded }" @click="handleToggle">
            <div class="left">
                <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                    <circle cx="12" cy="12" r="10" />
                    <path d="M12 2a10 10 0 0 0 0 20Z" />
                </svg>
                <span>色彩调节</span>
            </div>
            <div class="right-icon">
                <svg class="arrow" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor"
                    stroke-width="2">
                    <path d="m9 18 6-6-6-6" />
                </svg>
            </div>
        </div>

        <div v-if="isExpanded" class="tool-content">
            <div class="color-controls">
                <div v-for="item in config" :key="item.key" class="control-row">
                    <div class="label-box">
                        <span>{{ item.label }}</span>
                        <input type="number" v-model.number="values[item.key]" class="ie-input-number"
                            @input="updateFilters">
                    </div>
                    <input type="range" v-model.number="values[item.key]" :min="item.min" :max="item.max" step="1"
                        class="ie-slider" @input="updateFilters">
                </div>
            </div>

            <div class="action-buttons">
                <button class="ie-btn ie-primary full" @click="handleApply">确定</button>
                <button class="ie-btn full" @click="handleCancel">取消</button>
            </div>
        </div>
    </div>
</template>

<script setup>
import { reactive, inject, onMounted } from 'vue';
import { registerColorModule, applyColorAdjust, commitColorAdjust, cancelColorAdjust } from './useCanvasColor';

const props = defineProps({ isExpanded: Boolean });
const emit = defineEmits(['toggle']);
const canvasAPI = inject('canvasAPI');

const values = reactive({
    blurSharpen: 0,
    saturation: 0,
    brightness: 0,
    contrast: 0,
    temperature: 0,
    hue: 0
});

const config = [
    { label: '模糊 / 锐化', key: 'blurSharpen', min: -10, max: 10 },
    { label: '饱和度', key: 'saturation', min: -100, max: 100 },
    { label: '亮度', key: 'brightness', min: -10, max: 10 },
    { label: '对比度', key: 'contrast', min: -10, max: 10 },
    { label: '色温', key: 'temperature', min: -20, max: 20 },
    { label: '色调', key: 'hue', min: -20, max: 20 },
];

const updateFilters = () => applyColorAdjust(values);
const handleToggle = () => emit('toggle');

const handleApply = () => {
    commitColorAdjust();
    emit('toggle');
};

const handleCancel = () => {
    cancelColorAdjust();
    emit('toggle');
};

onMounted(() => {
    if (canvasAPI?.canvas) {
        registerColorModule(canvasAPI.canvas, canvasAPI.saveHistory);
    }
});
</script>

<style scoped>
.color-controls {
    padding: 8px 0;
}

.control-row {
    margin-bottom: 16px;
}

.label-box {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 6px;
    font-size: 13px;
    color: #606266;
}

/* 已移除局部的 ie-small-input 样式 */

.ie-slider {
    width: 100%;
    height: 4px;
    background: #e4e7ed;
    border-radius: 2px;
    appearance: none;
    outline: none;
}

.ie-slider::-webkit-slider-thumb {
    appearance: none;
    width: 12px;
    height: 12px;
    background: #fff;
    border: 2px solid var(--ie-primary-color); /* 修正为主题色 */
    border-radius: 50%;
    cursor: pointer;
    transition: transform 0.2s;
}

.ie-slider::-webkit-slider-thumb:hover {
    transform: scale(1.2);
}

.action-buttons {
    display: flex;
    gap: 10px;
    margin-top: 10px;
}

.full {
    flex: 1;
}
</style>
</file>

<file path="src/components/modules/adjust/AdjustColorOverlay.vue">
<template>
    <div class="tool-group">
        <div class="tool-item" :class="{ 'is-expanded': isExpanded }" @click="$emit('toggle')">
            <div class="left">
                <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                    <path d="M12 22a7 7 0 0 0 7-7c0-2-1-3.9-3-5.5s-3-4-3-4-1 2.4-3 4-3 3.5-3 5.5a7 7 0 0 0 7 7Z"/>
                </svg>
                <span>颜色叠加</span>
            </div>
            <div class="right-icon">
                <svg class="arrow" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                    <path d="m9 18 6-6-6-6" />
                </svg>
            </div>
        </div>

        <div v-if="isExpanded" class="tool-content">
            <div class="section-label">选择颜色</div>
            <div class="color-presets">
                <div class="preset-item color-picker-wrapper" :class="{ active: isCustomActive }">
                    <input type="color" v-model="customColor" @input="handleCustomColorInput" class="native-color-picker">
                    <div class="rainbow-gradient"></div>
                </div>
                <div v-for="color in presets" :key="color" class="preset-item" :style="{ background: color }"
                    :class="{ active: selectedColor === color }" @click="selectColor(color)"></div>
                <div class="preset-item clear-item" :class="{ active: selectedColor === null }" @click="selectColor(null)">
                    <div class="slash-line"></div>
                </div>
            </div>

            <div class="intensity-section">
                <div class="label-row">
                    <span>叠加强度</span>
                    <input type="number" v-model.number="intensity" class="ie-input-number" @input="updateOverlay">
                </div>
                <input type="range" v-model.number="intensity" min="0" max="100" class="ie-slider" @input="updateOverlay">
            </div>

            <div class="action-buttons">
                <button class="ie-btn ie-primary full" @click="handleConfirm">确定</button>
                <button class="ie-btn full" @click="handleCancel">取消</button>
            </div>
        </div>
    </div>
</template>

<script setup>
import { ref, inject, onMounted, computed, watch } from 'vue';
import { 
    registerColorOverlayModule, applyColorOverlay, commitColorOverlay, 
    backupCurrentColorOverlay, cancelColorOverlayChange 
} from './useCanvasColorOverlay';

const props = defineProps({ isExpanded: Boolean });
const emit = defineEmits(['toggle']);
const canvasAPI = inject('canvasAPI');

const selectedColor = ref(null);
const customColor = ref('#ff0000');
const intensity = ref(30);
const presets = ['#000000', '#808080', '#ffffff'];

const isCustomActive = computed(() => selectedColor.value !== null && !presets.includes(selectedColor.value));

const selectColor = (color) => {
    selectedColor.value = color;
    updateOverlay();
};

const handleCustomColorInput = (e) => {
    selectedColor.value = e.target.value;
    updateOverlay();
};

const updateOverlay = () => {
    applyColorOverlay(selectedColor.value, intensity.value);
};

const handleConfirm = () => {
    commitColorOverlay();
    emit('toggle');
};

const handleCancel = () => {
    cancelColorOverlayChange();
    emit('toggle');
};

watch(() => props.isExpanded, (expanded) => {
    const canvas = canvasAPI?.canvas?.value;
    const bgImage = canvas?.getObjects().find(o => o.type === 'image');
    
    if (expanded && bgImage) {
        selectedColor.value = bgImage._lastOverlayColor || null;
        intensity.value = bgImage._lastOverlayOpacity ?? 30;
        if (selectedColor.value && !presets.includes(selectedColor.value)) {
            customColor.value = selectedColor.value;
        }
        backupCurrentColorOverlay();
    }
});

onMounted(() => {
    if (canvasAPI?.canvas) {
        registerColorOverlayModule(canvasAPI.canvas, canvasAPI.saveHistory);
    }
});
</script>

<style scoped>
.section-label { font-size: 12px; color: #666; margin-bottom: 8px; }
.color-presets { display: flex; gap: 8px; margin-bottom: 20px; }
.preset-item { width: 36px; height: 20px; border-radius: 4px; border: 1px solid #ddd; cursor: pointer; position: relative; overflow: hidden; }
.preset-item.active { border-color: var(--ie-primary-color); border-width: 2px; }
.rainbow-gradient { width: 100%; height: 100%; background: linear-gradient(to right, red, yellow, lime, cyan, blue, magenta, red); }
.color-picker-wrapper { position: relative; }
.native-color-picker { position: absolute; top: 0; left: 0; width: 100%; height: 100%; opacity: 0; cursor: pointer; }
.clear-item { background: #fff; }
.slash-line { position: absolute; top: 50%; left: 0; width: 100%; height: 1px; background: red; transform: rotate(-45deg); }
.intensity-section { margin-bottom: 16px; }
.label-row { display: flex; justify-content: space-between; align-items: center; margin-bottom: 8px; font-size: 13px; color: #606266; }
/* 已移除局部的 input 样式 */
.action-buttons { display: flex; gap: 10px; margin-top: 16px; }
.full { flex: 1; }
</style>
</file>

<file path="src/components/modules/adjust/useCanvasInpaint.js">
import { ref, unref, watch } from 'vue';
import { fabric } from 'fabric';
import { aiApi } from '@/api/ai';
import { toast } from '@/utils/toast';
import { useEditorState } from '@/composables/useEditorState';

// === 模块级单例状态 ===
let canvasRef = null;
let saveHistoryFn = null;
let initialSnapshot = null; 
let autoInpaintTimer = null;
let isDragging = false;
let startPoint = null;
let activeRect = null;

// 响应式状态
export const brushSize = ref(30);
export const drawMode = ref('brush'); 

// 注册模块
export const registerInpaintModule = (canvas, saveHistory) => {
    canvasRef = canvas;
    saveHistoryFn = saveHistory;
};

// === 🔒 画布锁定系统 ===
const setObjectsLocked = (locked) => {
    const canvas = unref(canvasRef);
    if (!canvas) return;

    const objects = canvas.getObjects();
    objects.forEach(obj => {
        if (obj.isMaskObject || obj.type === 'path') return; // 跳过遮罩层

        if (locked) {
            obj._prevSelectable = obj.selectable;
            obj._prevEvented = obj.evented;
            obj.selectable = false;
            obj.evented = false; // 让事件穿透底图
            obj.lockMovementX = true;
            obj.lockMovementY = true;
        } else {
            obj.selectable = obj._prevSelectable ?? true;
            obj.evented = obj._prevEvented ?? true;
            obj.lockMovementX = false;
            obj.lockMovementY = false;
        }
    });

    if (locked) {
        canvas.discardActiveObject();
        canvas.selection = false;
    } else {
        canvas.selection = true;
    }
    canvas.requestRenderAll();
};

// === 🛠 核心修复：离屏生成遮罩 (解决闪屏问题) ===
const getInpaintMaskOffscreen = async () => {
    const canvas = unref(canvasRef);
    if (!canvas) return null;

    // 1. 筛选出屏幕上的红线或红框
    const maskObjects = canvas.getObjects().filter(o => o.isMaskObject || o.type === 'path');
    if (maskObjects.length === 0) return null;

    // 2. 创建一个临时的、不可见的画布 (StaticCanvas)
    // 大小与主画布一致，背景设为黑色
    const tempCanvas = new fabric.StaticCanvas(null, {
        width: canvas.width,
        height: canvas.height,
        backgroundColor: 'black' 
    });

    // 3. 克隆遮罩对象并“洗白”
    const clonePromises = maskObjects.map(obj => {
        return new Promise(resolve => {
            obj.clone((cloned) => {
                // 强制设为纯白，不透明
                cloned.set({
                    left: obj.left,
                    top: obj.top,
                    fill: 'white', 
                    stroke: 'white',
                    opacity: 1,
                    visible: true,
                    evented: false
                });

                // 针对画笔(Path)和框选(Rect)做微调，确保是实心白
                if (cloned.type === 'path') {
                    cloned.set({ fill: null, stroke: 'white' });
                } else if (cloned.type === 'rect') {
                    cloned.set({ fill: 'white', stroke: 'transparent' });
                }

                resolve(cloned);
            });
        });
    });

    // 4. 将克隆体添加到临时画布
    const clones = await Promise.all(clonePromises);
    clones.forEach(c => tempCanvas.add(c));
    
    // 5. 渲染并导出 (这一步发生在内存中，用户看不见)
    tempCanvas.renderAll();
    const dataUrl = tempCanvas.toDataURL({ 
        format: 'png',
        multiplier: 1 
    });
    
    // 6. 销毁临时画布释放内存
    tempCanvas.dispose();
    
    return dataUrl;
};

// === 进入/退出模块 ===
export const enterInpaintMode = () => {
    const canvas = unref(canvasRef);
    if (!canvas) return;

    initialSnapshot = JSON.stringify(canvas.toJSON(['id', 'selectable', 'name']));
    setObjectsLocked(true); // 锁定底图
    drawMode.value = 'brush';
    enableBrush();
};

export const exitInpaintMode = () => {
    const canvas = unref(canvasRef);
    if (!canvas) return;

    if (autoInpaintTimer) clearTimeout(autoInpaintTimer);
    unbindEvents();
    
    canvas.isDrawingMode = false;
    setObjectsLocked(false); // 解锁底图
    clearMaskObjects();
    canvas.defaultCursor = 'default';
};

// === 模式切换 ===
const enableBrush = () => {
    const canvas = unref(canvasRef);
    if (!canvas) return;

    unbindEvents();
    canvas.isDrawingMode = true;
    
    const brush = new fabric.PencilBrush(canvas);
    brush.color = 'rgba(255, 0, 0, 0.5)';
    brush.width = brushSize.value;
    canvas.freeDrawingBrush = brush;
    
    canvas.on('path:created', onPathCreated);
};

const enableRect = () => {
    const canvas = unref(canvasRef);
    if (!canvas) return;

    canvas.isDrawingMode = false;
    unbindEvents();
    setObjectsLocked(true); 
    canvas.defaultCursor = 'crosshair';

    canvas.on('mouse:down', onRectDown);
    canvas.on('mouse:move', onRectMove);
    canvas.on('mouse:up', onRectUp);
};

// === 事件处理 ===
const onPathCreated = (opt) => {
    const path = opt.path;
    if (path) {
        path.excludeFromHistory = true; 
        path.isMaskObject = true;
    }
    // 1秒防抖
    if (autoInpaintTimer) clearTimeout(autoInpaintTimer);
    autoInpaintTimer = setTimeout(() => executeInpaint(), 1000);
};

const onRectDown = (opt) => {
    const canvas = unref(canvasRef);
    if (opt.target && !opt.target.isMaskObject) return;

    const pointer = canvas.getPointer(opt.e);
    isDragging = true;
    startPoint = { x: pointer.x, y: pointer.y };

    activeRect = new fabric.Rect({
        left: startPoint.x, top: startPoint.y,
        width: 0, height: 0,
        fill: 'rgba(255, 0, 0, 0.5)',
        stroke: 'transparent',
        selectable: false, evented: false,
        isMaskObject: true,
        excludeFromHistory: true
    });
    canvas.add(activeRect);
};

const onRectMove = (opt) => {
    if (!isDragging || !activeRect) return;
    const canvas = unref(canvasRef);
    const pointer = canvas.getPointer(opt.e);
    
    let w = Math.abs(pointer.x - startPoint.x);
    let h = Math.abs(pointer.y - startPoint.y);
    
    if (pointer.x < startPoint.x) activeRect.set({ left: pointer.x });
    if (pointer.y < startPoint.y) activeRect.set({ top: pointer.y });

    activeRect.set({ width: w, height: h });
    canvas.requestRenderAll();
};

const onRectUp = () => {
    isDragging = false;
    if (activeRect && (activeRect.width < 5 || activeRect.height < 5)) {
        unref(canvasRef).remove(activeRect);
    } else {
        executeInpaint(); // 松手即触发
    }
    activeRect = null;
};

const unbindEvents = () => {
    const canvas = unref(canvasRef);
    if (!canvas) return;
    canvas.off('path:created', onPathCreated);
    canvas.off('mouse:down', onRectDown);
    canvas.off('mouse:move', onRectMove);
    canvas.off('mouse:up', onRectUp);
};

// === 🚀 核心执行逻辑 ===
const executeInpaint = async () => {
    const canvas = unref(canvasRef);
    if (!canvas) return;

    // 1. 检查是否有遮罩内容
    const hasContent = canvas.getObjects().some(o => o.isMaskObject || o.type === 'path');
    if (!hasContent) return;

    const { setLoading } = useEditorState(); // 获取全局 Loading 控制

    try {
        setLoading(true, 'AI 正在消除...'); // 开启 Loading，遮住画布
        
        // 2. 寻找底图
        const activeObj = canvas.getObjects().find(o => o.type === 'image' && !o.isMaskObject);
        if (!activeObj) throw new Error('未找到底图');

        // 3. 【新逻辑】使用离屏渲染获取 Mask，不再导致主画布闪黑
        const maskBase64 = await getInpaintMaskOffscreen();
        if (!maskBase64) return;

        // 4. 调用 AI 接口
        const resultUrl = await aiApi.inpaint(activeObj.getSrc(), maskBase64);
        
        if (resultUrl) {
            // 5. 成功后替换图片
            activeObj.setSrc(resultUrl, () => {
                clearMaskObjects(); // 清除红线
                setObjectsLocked(true); // 重新锁定新图片
                
                if (saveHistoryFn) saveHistoryFn();
                toast.success('消除完成');
                canvas.requestRenderAll();
                
                // 图片加载完再关闭 Loading，体验更平滑
                setLoading(false);
            }, { crossOrigin: 'anonymous' });
        } else {
            setLoading(false);
        }
    } catch (error) {
        console.error('Inpaint error:', error);
        toast.error('消除失败，请重试');
        clearMaskObjects();
        setLoading(false);
    }
};

const clearMaskObjects = () => {
    const canvas = unref(canvasRef);
    if (!canvas) return;
    const masks = canvas.getObjects().filter(o => o.isMaskObject || o.type === 'path');
    canvas.remove(...masks);
    canvas.requestRenderAll();
};

// === 恢复原图 ===
export const handleRestoreOriginal = () => {
    const canvas = unref(canvasRef);
    if (!canvas || !initialSnapshot) return;

    canvas.loadFromJSON(initialSnapshot, () => {
        setObjectsLocked(true);
        if (drawMode.value === 'brush') enableBrush();
        else enableRect();
        
        if (saveHistoryFn) saveHistoryFn();
        toast.success('已恢复至初始状态');
    });
};

watch(drawMode, (newMode) => {
    if (newMode === 'brush') enableBrush();
    else enableRect();
});

watch(brushSize, (val) => {
    const canvas = unref(canvasRef);
    if (canvas && canvas.freeDrawingBrush) {
        canvas.freeDrawingBrush.width = val;
    }
});
</file>

<file path="src/components/layout/LeftSidebar.vue">
<template>
  <div class="left-sidebar">
    <div 
      v-for="item in menuItems" 
      :key="item.id" 
      class="menu-item" 
      :class="{ 
        active: state.activeTool === item.id,
        'auto-activated': state.activeTool === item.id && state.navigationSource === 'canvas'
      }"
      @click="handleToolClick(item.id)"
    >
      <svg class="menu-icon" viewBox="0 0 1024 1024" width="20" height="20">
        <path :d="item.iconPath" fill="currentColor" />
      </svg>
      <span class="label">{{ item.label }}</span>
    </div>
  </div>
</template>

<script setup>
import { useEditorState } from '../../composables/useEditorState';

// 1. 替代 Pinia
const { state, setActiveTool } = useEditorState();

// 2. 点击处理：手动点击时，强制解除 Disabled 状态
// 点击处理：标记来源为 'manual'
const handleToolClick = (id) => {
  setActiveTool(id, 'manual');
};

// 3. 定义菜单配置 (保持原样)
const menuItems = [
  {
    id: 'adjust',
    label: '调整',
    iconPath: 'M192 128v768h128V672h192v224h128V672h192V544H512V128H192zm128 128h192v160H320V256z'
  },
  {
    id: 'draw',
    label: '绘制',
    iconPath: 'M853.504 192.064l-235.008 235.008-60.352-60.352 235.008-235.008a64 64 0 0 1 90.496 0l-30.144 30.144 30.144 30.208z m-467.2 491.52l60.352-60.352L249.408 425.984l-60.352 60.352 197.248 197.248zM189.056 365.632l60.352-60.352 384.896 384.896-60.352 60.352L189.056 365.632zM128 896a64 64 0 0 1-64-64c0-68.992 48.128-196.608 107.52-256l192 192C304.128 827.392 192 896 128 896z'
  },
  {
    id: 'text',
    label: '文本',
    iconPath: 'M832 64H192a64 64 0 0 0-64 64v768a64 64 0 0 0 64 64h640a64 64 0 0 0 64-64V128a64 64 0 0 0-64-64zM256 256h512v64H256v-64zm512 448H256v-64h512v64zm0-192H256v-64h512v64z'
  },
  {
    id: 'border',
    label: '边框',
    iconPath: 'M160 160v192h-64V96h256v64H160z m0 704h192v64H96V672h64v192z m704-192v192H672v64h256V672h-64z m0-288V160H672V96h256v288h-64z'
  },
  {
    id: 'material',
    label: '素材',
    iconPath: 'M448 128H128v320h320V128zm-64 256H192V192h192v192z m448-256H576v320h256V128zm-64 256H640V192h192v192z M448 576H128v320h320V576zm-64 256H192V640h192v192z m448-256H576v320h256V576zm-64 256H640V640h192v192z'
  },
  {
    id: 'watermark',
    label: '水印',
    iconPath: 'M832 320H608V128h-64a96 96 0 0 0-96-96h-64a96 96 0 0 0-96 96h-64v192H192a64 64 0 0 0-64 64v512h768V384a64 64 0 0 0-64-64z m-320-96h64v96h-64v-96z m0-128h64a32 32 0 0 1 32 32v32h-128V128a32 32 0 0 1 32-32zM256 704a64 64 0 1 1 0-128 64 64 0 0 1 0 128zm256 128a64 64 0 1 1 0-128 64 64 0 0 1 0 128zm256-128a64 64 0 1 1 0-128 64 64 0 0 1 0 128z'
  },
  {
    id: 'puzzle',
    label: '拼图',
    iconPath: 'M704 576a128 128 0 0 1-128 128h-64v256h-64V704h-64a128 128 0 1 1 0-256h64V192h64v256h64a128 128 0 0 1 128 128z m-256-64h64V256h-64v256zM320 576a64 64 0 1 0 64-64h-64v64zm384 0a64 64 0 1 0-64-64h64v64z'
  },
  {
    id: 'ai',
    label: 'AI',
    iconPath: 'M832 192H192v640h640V192z m64-64v768H128V128h768z M320 320h128v128H320V320z m0 256h128v128H320V576z m256-256h128v128H576V320z m0 256h128v128H576V576z'
  },
];
</script>

<style scoped>
.left-sidebar {
  width: 72px;
  background-color: #fff;
  border-right: 1px solid #e4e7ed;
  display: flex;
  flex-direction: column;
  padding-top: 12px;
  overflow-y: auto;
  transition: opacity 0.3s ease;
}


.left-sidebar::-webkit-scrollbar {
  display: none;
}

.menu-item {
  height: 68px;
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  cursor: pointer;
  color: #606266;
  gap: 6px;
  transition: all 0.2s;
  flex-shrink: 0;
}

.menu-item:hover {
  color: var(--ie-primary-color);
  background-color: #f5f7fa;
}

.menu-item.active {
  color: var(--ie-primary-color);
  font-weight: 500;
  background-color: #ecf5ff;
  position: relative;
}

.menu-item.active::before {
  content: '';
  position: absolute;
  left: 0;
  top: 50%;
  transform: translateY(-50%);
  width: 3px;
  height: 24px;
  background-color: var(--ie-primary-color);
  border-radius: 0 2px 2px 0;
}

.label {
  font-size: 12px;
  line-height: 1;
}

.menu-icon {
  fill: currentColor;
  display: block;
}

/* 这是一个可选的增强： */
/* 如果是自动跳转的，我们可以让高亮条有个淡入效果，而不是瞬间切换 */
.menu-item.active.auto-activated::before {
  transition: all 0.3s ease;
}

.left-sidebar.is-disabled {
    /* 你的残影样式 */
    opacity: 0.5;
    filter: grayscale(0.8);
    pointer-events: auto; /* 关键：允许点击以重新激活 */
}
</style>
</file>

<file path="src/components/modules/adjust/useCanvasWhite.js">
// [File: src/components/modules/adjust/useCanvasWhite.js]

import { ref, unref, shallowRef, toRaw } from "vue";
import { fabric } from "fabric";

let canvasRef = null;
let saveHistoryFn = null;
let zoomToRectFn = null;
// === 预览相关状态 ===
const previewBgRect = shallowRef(null);
let originalSelectable = true;
let originalEvented = true;
let originalTransform = null;


export const registerWhiteModule = (canvas, saveHistory, zoomToRect) => {
  canvasRef = canvas;
  saveHistoryFn = saveHistory;
  zoomToRectFn = zoomToRect;
};


// 新增：手动触发视角对齐的方法
export const zoomToPreview = () => {
  const canvas = unref(canvasRef);
  // 如果 zoomToRectFn 为 null，这里就会直接 return，导致没反应
  if (!canvas || !previewBgRect.value || !zoomToRectFn || !originalTransform) return;

  const rect = previewBgRect.value;

  // 计算补白框在画布上的逻辑矩形范围
  const logicRect = {
    left: rect.left - (rect.width * rect.scaleX) / 2,
    top: rect.top - (rect.height * rect.scaleY) / 2,
    width: rect.width * rect.scaleX,
    height: rect.height * rect.scaleY
  };

  // 调用相机缩放方法
  zoomToRectFn(logicRect);
};





export const getCurrentSize = () => {
  const canvas = unref(canvasRef);
  if (!canvas) return { width: 0, height: 0 };
  const bgImage = canvas.getObjects().find(o => o.type === 'image');
  if (bgImage) {
    return {
      width: Math.round(bgImage.getScaledWidth()),
      height: Math.round(bgImage.getScaledHeight())
    };
  }
  return { width: canvas.width, height: canvas.height };
};

const restoreImageState = (bgImage) => {
  if (originalTransform && bgImage) {
    bgImage.set({
      scaleX: originalTransform.scaleX,
      scaleY: originalTransform.scaleY,
      left: originalTransform.left,
      top: originalTransform.top,
      width: originalTransform.width,
      height: originalTransform.height,
      angle: originalTransform.angle,
      originX: originalTransform.originX,
      originY: originalTransform.originY
    });
    bgImage.setCoords();
  }
};

export const startPreview = (targetW, targetH, bgColor = '#ffffff') => {
  const canvas = unref(canvasRef);
  if (!canvas || !targetW || !targetH) return;

  const bgImage = canvas.getObjects().find(o => o.type === 'image');
  if (!bgImage) return;

  if (!originalTransform) {
    originalSelectable = bgImage.selectable;
    originalEvented = bgImage.evented;
    originalTransform = {
      scaleX: bgImage.scaleX,
      scaleY: bgImage.scaleY,
      left: bgImage.left,
      top: bgImage.top,
      width: bgImage.width,
      height: bgImage.height,
      angle: bgImage.angle,
      originX: bgImage.originX,
      originY: bgImage.originY
    };
  }

  if (previewBgRect.value) {
    canvas.remove(toRaw(previewBgRect.value));
    previewBgRect.value = null;
  }

  const imgW = originalTransform.width * originalTransform.scaleX;
  const imgH = originalTransform.height * originalTransform.scaleY;
  const scaleX = targetW / imgW;
  const scaleY = targetH / imgH;
  const fitScale = Math.min(scaleX, scaleY);

  // const canvasW = canvas.width;
  // const canvasH = canvas.height;
  // const center = canvas.getCenter();
  // const VIEW_FACTOR = 0.85;

  // const viewScale = Math.min(
  //   (canvasW * VIEW_FACTOR) / targetW,
  //   (canvasH * VIEW_FACTOR) / targetH
  // );
  const viewScale = 1;
  const center = canvas.getCenter();
  const rect = new fabric.Rect({
    width: targetW,
    height: targetH,
    left: center.left,
    top: center.top,
    originX: 'center',
    originY: 'center',
    fill: bgColor === 'transparent' ? 'transparent' : bgColor,
    stroke: '#409eff',
    strokeWidth: 2 / viewScale,
    selectable: false,
    evented: false,
    excludeFromExport: true,
    scaleX: viewScale,
    scaleY: viewScale
  });

  previewBgRect.value = rect;
  canvas.add(rect);
  canvas.sendToBack(rect);

  const finalScaleX = originalTransform.scaleX * fitScale * viewScale;
  const finalScaleY = originalTransform.scaleY * fitScale * viewScale;

  bgImage.set({
    scaleX: finalScaleX,
    scaleY: finalScaleY,
    left: center.left,
    top: center.top,
    originX: 'center',
    originY: 'center',
    selectable: false,
    evented: false
  });
  bgImage.setCoords();
  canvas.requestRenderAll();
};

export const updatePreview = (targetW, targetH, bgColor) => {
  startPreview(targetW, targetH, bgColor);
};

export const stopPreview = () => {
  const canvas = unref(canvasRef);
  if (canvas) {
    if (previewBgRect.value) {
      canvas.remove(toRaw(previewBgRect.value));
      previewBgRect.value = null;
    }

    const bgImage = canvas.getObjects().find(o => o.type === 'image');
    if (bgImage) {
      restoreImageState(bgImage);
      bgImage.selectable = originalSelectable;
      bgImage.evented = originalEvented;
    }
    canvas.discardActiveObject();
    originalTransform = null;
    canvas.requestRenderAll();
  }
};


// 母带重制 (Source Remastering) 原清晰度
export const applyWhitePadding = (width, height, bgColor) => {
  return new Promise((resolve, reject) => {
    const canvas = unref(canvasRef);
    if (!canvas || !previewBgRect.value) {
      resolve();
      return;
    }

    const targetW = Math.round(width);
    const targetH = Math.round(height);
    if (targetW <= 0 || targetH <= 0) {
      resolve();
      return;
    }

    const bgImage = canvas.getObjects().find(o => o.type === 'image');
    if (!bgImage) {
      resolve();
      return;
    }

    // 1. 获取原图的原始 Source URL (最清晰的数据源)
    const originalSrc = bgImage.getSrc();

    // 2. 捕获当前画布上的视觉状态 (用于最后恢复视图)
    const rect = previewBgRect.value;
    const targetVisualZoom = rect.scaleX;

    // 3. 在内存中创建一个新的 Fabric Image 对象，加载原始高清图
    fabric.Image.fromURL(originalSrc, (highResImg) => {

      // === 核心差异：基于原始分辨率计算 ===
      // highResImg.width / height 是图片最原始的像素尺寸 (比如 4000x3000)
      const originalW = highResImg.width;
      const originalH = highResImg.height;

      // 计算适应比例：让原图完整塞进目标尺寸 (Fit)
      // 例如：目标 1000x222，原图 4000x3000
      // scale = min(1000/4000, 222/3000)
      const fitScale = Math.min(targetW / originalW, targetH / originalH);

      // 4. 创建高清离屏画布
      // 这里的策略是：如果目标尺寸很小(如1000px)，我们强制放大导出尺寸，保证Retina屏清晰度
      // 至少保证长边有 2500px 以上，或者按目标尺寸的 2-3 倍输出
      const outputMultiplier = Math.max(1, 3000 / Math.max(targetW, targetH)); // 动态计算倍率

      const outputW = Math.round(targetW * outputMultiplier);
      const outputH = Math.round(targetH * outputMultiplier);

      const tempCanvas = new fabric.StaticCanvas(null, {
        width: outputW,
        height: outputH,
        backgroundColor: bgColor,
      });

      // 5. 设置高清图在离屏画布中的位置
      highResImg.set({
        originX: 'center',
        originY: 'center',
        left: outputW / 2,
        top: outputH / 2,
        // 关键：缩放 = 适应比例 * 输出倍率
        scaleX: fitScale * outputMultiplier,
        scaleY: fitScale * outputMultiplier,
        // 继承原图的角度和翻转（如果有）
        angle: bgImage.angle,
        flipX: bgImage.flipX,
        flipY: bgImage.flipY
      });

      tempCanvas.add(highResImg);
      tempCanvas.renderAll();

      // 6. 导出最终图片 (这是真正的高清图)
      const dataURL = tempCanvas.toDataURL({
        format: 'png',
        quality: 1
      });

      tempCanvas.dispose();

      // 7. 应用回主画布
      bgImage.setSrc(dataURL, () => {
        // 1. 清理预览资源
        if (previewBgRect.value) {
          canvas.remove(toRaw(previewBgRect.value));
          previewBgRect.value = null;
        }
        originalTransform = null;

        // 2. 恢复交互状态
        bgImage.selectable = originalSelectable;
        bgImage.evented = originalEvented;

        // === 3. 核心：清晰度调整 (Source Remastering) ===
        // 注意：这段逻辑不能删。高清重制导出了物理像素极高的新图 (outputMultiplier)，
        // 我们需要把它缩放到逻辑尺寸，否则图片会显得异常巨大或模糊。
        const displayScale = 1 / outputMultiplier;

        bgImage.set({
          scaleX: displayScale,
          scaleY: displayScale,
          angle: 0,
          flipX: false,
          flipY: false,
          originX: 'center',
          originY: 'center',
          left: 0,
          top: 0
        });

        // === 4. 视图处理 ===
        // 根据你的要求，这里注释掉了会引起视角跳动的重置代码
        // canvas.setViewportTransform([1, 0, 0, 1, 0, 0]); // ❌ 不进行视角复位

        // 也不使用 zoomToPoint 跳转到预设视距
        // canvas.zoomToPoint(new fabric.Point(canvas.width / 2, canvas.height / 2), targetVisualZoom); // ❌ 不改变当前缩放比例

        // 5. 仅在当前视角下将图片居中
        canvas.centerObject(bgImage);
        bgImage.setCoords();

        // 6. 刷新画布并保存历史
        canvas.requestRenderAll();
        if (saveHistoryFn) saveHistoryFn();

        resolve();
      });
    }, { crossOrigin: 'anonymous' }); // 确保跨域图片能加载
  });
};
</file>

<file path="src/components/modules/puzzle/config.js">
// src/components/modules/puzzle/config.js

// =========================================================================
// 1. 网格模板数据 - 按图片数量分组
// =========================================================================
// 网格模板数据 - 按图片数量分组
export const gridTemplates = {
  1: [
    {
      id: '1-1',
      wrapStyle: {
        'grid-template-columns': 'repeat(1, 1fr)',
        'grid-template-rows': 'repeat(1, 1fr)',
      },
      gridAreas: ['1 / 1 / 2 / 2'],
    }
  ],
  2: [
    {
      id: '2-1',
      wrapStyle: {
        'grid-template-columns': 'repeat(2, 1fr)',
        'grid-template-rows': 'repeat(2, 1fr)',
      },
      gridAreas: ['1 / 1 / 3 / 2', '1 / 2 / 3 / 3'],
    },
    {
      id: '2-2',
      wrapStyle: {
        'grid-template-columns': 'repeat(2, 1fr)',
        'grid-template-rows': 'repeat(2, 1fr)',
      },
      gridAreas: ['1 / 1 / 2 / 3', '2 / 1 / 3 / 3'],
    }
  ],
  3: [
    {
      id: '3-1',
      wrapStyle: {
        'grid-template-columns': 'repeat(3, 1fr)',
        'grid-template-rows': 'repeat(3, 1fr)',
      },
      gridAreas: ['1 / 1 / 3 / 3', '1 / 3 / 3 / 4', '3 / 1 / 4 / 4'],
    },
    {
      id: '3-2',
      wrapStyle: {
        'grid-template-columns': 'repeat(3, 1fr)',
        'grid-template-rows': 'repeat(3, 1fr)',
      },
      gridAreas: ['1 / 1 / 2 / 4', '2 / 1 / 4 / 3', '2 / 3 / 4 / 4'],
    },
    {
      id: '3-3',
      wrapStyle: {
        'grid-template-columns': 'repeat(2, 1fr)',
        'grid-template-rows': 'repeat(2, 1fr)',
      },
      gridAreas: [
        '1 / 1 / 3 / 2',
        '1 / 2 / 2 / 3',
        '2 / 2 / 3 / 3'
      ],
    },
    {
      id: '3-4',
      wrapStyle: {
        'grid-template-columns': 'repeat(2, 1fr)',
        'grid-template-rows': 'repeat(2, 1fr)',
      },
      gridAreas: [
        '1 / 1 / 2 / 2',
        '1 / 2 / 3 / 3',
        '2 / 1 / 3 / 2'
      ],
    },
    {
      id: '3-5',
      wrapStyle: {
        'grid-template-columns': 'repeat(2, 1fr)',
        'grid-template-rows': 'repeat(2, 1fr)',
      },
      gridAreas: [
        '1 / 1 / 2 / 3',
        '2 / 1 / 3 / 2',
        '2 / 2 / 3 / 3'
      ],
    },
    {
      id: '3-6',
      wrapStyle: {
        'grid-template-columns': 'repeat(2, 1fr)',
        'grid-template-rows': 'repeat(2, 1fr)',
      },
      gridAreas: [
        '1 / 1 / 2 / 2',
        '1 / 2 / 2 / 3',
        '2 / 1 / 3 / 3'
      ],
    },
    {
      id: '3-7',
      wrapStyle: {
        'grid-template-columns': 'repeat(3, 1fr)',
        'grid-template-rows': 'repeat(3, 1fr)',
      },
      gridAreas: [
        '1 / 1 / 4 / 2',
        '1 / 2 / 4 / 3',
        '1 / 3 / 4 / 4'
      ],
    },
    {
      id: '3-8',
      wrapStyle: {
        'grid-template-columns': 'repeat(3, 1fr)',
        'grid-template-rows': 'repeat(3, 1fr)',
      },
      gridAreas: [
        '1 / 1 / 2 / 4',
        '2 / 1 / 3 / 4',
        '3 / 1 / 4 / 4'
      ],
    }
  ],
  4: [
    {
      id: '4-1',
      wrapStyle: {
        'grid-template-columns': 'repeat(2, 1fr)',
        'grid-template-rows': 'repeat(2, 1fr)',
      },
      gridAreas: [
        '1 / 1 / 2 / 2',
        '1 / 2 / 2 / 3',
        '2 / 1 / 3 / 2',
        '2 / 2 / 3 / 3'
      ],
    },
    {
      id: '4-2',
      wrapStyle: {
        'grid-template-columns': 'repeat(6, 1fr)',
        'grid-template-rows': 'repeat(6, 1fr)',
      },
      gridAreas: [
        '1 / 1 / 4 / 3',
        '1 / 3 / 4 / 7',
        '4 / 1 / 7 / 5',
        '4 / 5 / 7 / 7'
      ],
    },
    {
      id: '4-3',
      wrapStyle: {
        'grid-template-columns': 'repeat(6, 1fr)',
        'grid-template-rows': 'repeat(6, 1fr)',
      },
      gridAreas: [
        '1 / 1 / 7 / 3',
        '1 / 3 / 4 / 5',
        '4 / 3 / 7 / 5',
        '1 / 5 / 7 / 7'
      ],
    },
    {
      id: '4-4',
      wrapStyle: {
        'grid-template-columns': 'repeat(6, 1fr)',
        'grid-template-rows': 'repeat(6, 1fr)',
      },
      gridAreas: [
        '1 / 1 / 3 / 7',
        '3 / 1 / 5 / 4',
        '3 / 4 / 5 / 7',
        '5 / 1 / 7 / 7'
      ],
    },
    {
      id: '4-5',
      wrapStyle: {
        'grid-template-columns': 'repeat(4, 1fr)',
        'grid-template-rows': 'repeat(4, 1fr)',
      },
      gridAreas: [
        '1 / 1 / 5 / 2',
        '1 / 2 / 5 / 3',
        '1 / 3 / 5 / 4',
        '1 / 4 / 5 / 5'
      ],
    },
    {
      id: '4-6',
      wrapStyle: {
        'grid-template-columns': 'repeat(4, 1fr)',
        'grid-template-rows': 'repeat(4, 1fr)',
      },
      gridAreas: [
        '1 / 1 / 2 / 5',
        '2 / 1 / 3 / 5',
        '3 / 1 / 4 / 5',
        '4 / 1 / 5 / 5'
      ],
    },
    {
      id: '4-7',
      wrapStyle: {
        'grid-template-columns': 'repeat(6, 1fr)',
        'grid-template-rows': 'repeat(6, 1fr)',
      },
      gridAreas: [
        '1 / 1 / 3 / 4',
        '3 / 1 / 5 / 4',
        '5 / 1 / 7 / 4',
        '1 / 4 / 7 / 7'
      ],
    },
    {
      id: '4-8',
      wrapStyle: {
        'grid-template-columns': 'repeat(6, 1fr)',
        'grid-template-rows': 'repeat(6, 1fr)',
      },
      gridAreas: [
        '1 / 1 / 7 / 4',
        '1 / 4 / 3 / 7',
        '3 / 4 / 5 / 7',
        '5 / 4 / 7 / 7'
      ],
    },
    {
      id: '4-9',
      wrapStyle: {
        'grid-template-columns': 'repeat(6, 1fr)',
        'grid-template-rows': 'repeat(6, 1fr)',
      },
      gridAreas: [
        '1 / 1 / 4 / 3',
        '1 / 3 / 4 / 5',
        '1 / 5 / 4 / 7',
        '4 / 1 / 7 / 7'
      ],
    },
    {
      id: '4-10',
      wrapStyle: {
        'grid-template-columns': 'repeat(6, 1fr)',
        'grid-template-rows': 'repeat(6, 1fr)',
      },
      gridAreas: [
        '1 / 1 / 4 / 7',
        '4 / 1 / 7 / 3',
        '4 / 3 / 7 / 5',
        '4 / 5 / 7 / 7'
      ],
    },
    {
      id: '4-11',
      wrapStyle: {
        'grid-template-columns': 'repeat(4, 1fr)',
        'grid-template-rows': 'repeat(4, 1fr)',
      },
      gridAreas: [
        '1 / 1 / 3 / 5',
        '3 / 1 / 5 / 3',
        '3 / 3 / 4 / 5',
        '4 / 3 / 5 / 5'
      ],
    },
    {
      id: '4-12',
      wrapStyle: {
        'grid-template-columns': 'repeat(4, 1fr)',
        'grid-template-rows': 'repeat(4, 1fr)',
      },
      gridAreas: [
        '1 / 1 / 5 / 3',
        '1 / 3 / 3 / 4',
        '1 / 4 / 3 / 5',
        '3 / 3 / 5 / 5'
      ],
    },
    {
      id: '4-13',
      wrapStyle: {
        'grid-template-columns': 'repeat(4, 1fr)',
        'grid-template-rows': 'repeat(4, 1fr)',
      },
      gridAreas: [
        '1 / 1 / 2 / 3',
        '2 / 1 / 3 / 3',
        '1 / 3 / 3 / 5',
        '3 / 1 / 5 / 5'
      ],
    },
    {
      id: '4-14',
      wrapStyle: {
        'grid-template-columns': 'repeat(4, 1fr)',
        'grid-template-rows': 'repeat(4, 1fr)',
      },
      gridAreas: [
        '1 / 1 / 3 / 3',
        '3 / 1 / 5 / 2',
        '3 / 2 / 5 / 3',
        '1 / 3 / 5 / 5'
      ],
    },
  ]
};

// 图片数量下拉
export const countOptions = [
  { value: 'all', label: '全部' },
  ...Array.from({ length: 4 }, (_, i) => ({ value: `${i + 1}`, label: `${i + 1}` })),
];

// =========================================================================
// 3. 核心工具函数：生成和解析网格
// =========================================================================

/**
 * 动态生成 NxM 网格的单元格数据
 * @param {Number} rows 行数
 * @param {Number} cols 列数
 * @returns {Array} 单元格数组
 */
export const generateGridCells = (rows, cols) => {
  const cells = [];
  const w = 1 / cols;
  const h = 1 / rows;

  for (let r = 0; r < rows; r++) {
    for (let c = 0; c < cols; c++) {
      cells.push({
        index: r * cols + c,
        x: c * w,
        y: r * h,
        w,
        h
      });
    }
  }
  return cells;
};

/**
 * 解析 CSS Grid Area 模板为百分比坐标
 * 兼容格式如: "1 / 1 / 2 / 2" (rowStart / colStart / rowEnd / colEnd)
 * @param {Object} tpl 模板对象
 */
export const parseTemplateToCells = (tpl) => {
  if (!tpl || !tpl.gridAreas) return [];

  let maxR = 1, maxC = 1;

  const getCountFromStyle = (styleStr) => {
    if (!styleStr) return 1;
    const repeatMatch = styleStr.match(/repeat\((\d+)/);
    if (repeatMatch) return parseInt(repeatMatch[1]);
    const spaceMatch = styleStr.trim().split(/\s+/);
    return spaceMatch.length;
  };

  if (tpl.wrapStyle) {
    maxC = Math.max(maxC, getCountFromStyle(tpl.wrapStyle['grid-template-columns']));
    maxR = Math.max(maxR, getCountFromStyle(tpl.wrapStyle['grid-template-rows']));
  }

  tpl.gridAreas.forEach(area => {
    const parts = area.split('/').map(s => parseInt(s.trim()));
    if (parts.length >= 4) {
      if (parts[2] - 1 > maxR) maxR = parts[2] - 1;
      if (parts[3] - 1 > maxC) maxC = parts[3] - 1;
    }
  });

  return tpl.gridAreas.map((area, index) => {
    const [r1, c1, r2, c2] = area.split('/').map(s => parseInt(s.trim()));
    const x = (c1 - 1) / maxC;
    const y = (r1 - 1) / maxR;
    const w = (c2 - c1) / maxC;
    const h = (r2 - r1) / maxR;

    return { index, x, y, w, h };
  });
};
</file>

<file path="src/components/panels/ToolPanel.vue">
<template>
  <div class="tool-panel">
    <component :is="currentModule" />

    <Modal v-model="showPuzzleConfirm" title="保存拼图修改？" @confirm="handleConfirmExit(true)"
      @discard="handleConfirmExit(false)" @cancel="handleCancelExit">
      检测到您正在拼图模块，离开将无法再次调整当前的格子布局。是否将当前拼图结果保存为一张新图片？
    </Modal>
  </div>
</template>

<script setup>
import { computed, defineAsyncComponent, ref, watch, inject } from 'vue';
import { useEditorState } from '../../composables/useEditorState';
import Modal from '../common/Modal.vue';
import { completeExitPuzzle } from '../modules/puzzle/useCanvasPuzzle';

const { state, setActiveTool } = useEditorState();

// 内部驱动 UI 的工具状态
const localActiveTool = ref(state.activeTool);
const showPuzzleConfirm = ref(false);
let pendingTool = null; // 记录用户点击的目标工具
let isInternalSwitch = false; // 防止 watch 循环触发

// 动态映射表保持不变
const modules = {
  adjust: defineAsyncComponent(() => import('../modules/adjust/index.vue')),
  draw: defineAsyncComponent(() => import('../modules/draw/index.vue')),
  text: defineAsyncComponent(() => import('../modules/text/index.vue')),
  border: defineAsyncComponent(() => import('../modules/border/index.vue')),
  material: defineAsyncComponent(() => import('../modules/material/index.vue')),
  watermark: defineAsyncComponent(() => import('../modules/watermark/index.vue')),
  puzzle: defineAsyncComponent(() => import('../modules/puzzle/index.vue')),
  ai: defineAsyncComponent(() => import('../modules/ai/index.vue')),
};

const currentModule = computed(() => {
  return modules[localActiveTool.value] || modules['adjust'];
});

// === 核心逻辑：拦截切换 ===
watch(() => state.activeTool, (newTool, oldTool) => {
  if (isInternalSwitch) {
    isInternalSwitch = false;
    return;
  }

  // 如果从拼图模块切往别的模块
  if (oldTool === 'puzzle' && newTool !== 'puzzle') {
    pendingTool = newTool; // 记住想去的地方
    showPuzzleConfirm.value = true; // 弹出提示

    // 强制将全局状态重置回 puzzle，让侧边栏高亮保持在拼图上
    isInternalSwitch = true;
    setActiveTool('puzzle');
  } else {
    // 普通切换直接同步
    localActiveTool.value = newTool;
  }
});

// 处理弹窗点击
const handleConfirmExit = (isSave) => {
  // 调用 useCanvasPuzzle 提供的最终退出函数
  completeExitPuzzle(isSave ? 'save' : 'discard');

  showPuzzleConfirm.value = false;

  if (pendingTool) {
    // 确认后，执行真正的全局跳转
    isInternalSwitch = true;
    setActiveTool(pendingTool);
    localActiveTool.value = pendingTool;
    pendingTool = null;
  }
};

const handleCancelExit = () => {
  showPuzzleConfirm.value = false;
  pendingTool = null;
};
</script>

<style scoped>
.tool-panel {
  background: #fff;
  border-right: 1px solid #e4e7ed;
  height: 100%;
  overflow-y: auto;
}
</style>
</file>

<file path=".spec/active-context.md">
# Active Context & Development State

> **Version**: 2.3 (Object-Driven Navigation & Routing)
> **Last Updated**: 2025-12-23
> **Current Focus**: Global Navigation Architecture & Event-Driven UI

## 1. 当前开发状态 (Current Status)

### ✅ 已完成模块 (Completed Modules)

#### 1.1 核心编辑 (Core Editing)
- **剪裁 (Crop)**:
  - [x] **手动选区**: 实现了 `startManualSelection`，支持自定义框选区域。
  - [x] **比例锁定**: 支持原图比例、自由比例及常用预设 (1:1, 16:9 等)。
  - [x] **旋转翻转**: 90° 步进旋转与 XY 轴翻转。
- **尺寸调整 (Resize)**:
  - [x] **高清重制**: 引入 `useOffscreenHelper`，实现了基于原图分辨率的高清缩放。
  - [x] **保真模式**: 支持锁定长宽比计算。
- **补白 (White/Padding)**:
  - [x] **社媒预设**: 集成 Instagram/Youtube 等常用尺寸模板。
  - [x] **智能吸色**: 支持背景色吸取及透明背景设置。

#### 1.2 拼图系统 (Puzzle System)
- **网格布局**:
  - [x] **动态模板**: 基于 `config.js` 实现了 1-16 张图片的网格布局解析。
  - [x] **自动布局**: 图片拖入自动计算 Cover 裁剪，保证填满格子不留白。
- **交互逻辑**:
  - [x] **拖拽交换**: 实现了平滑的交换动画 (`animateSwap`) 和失败回弹。
  - [x] **物理约束**: 应用 `useConstraint` 防止图片脱离格子可视区。
- **样式调整**:
  - [x] **全局参数**: 支持动态调整间距、边距和圆角。

#### 1.3 智能与特效 (AI & Effects)
- **智能消除 (Inpaint)**:
  - [x] **离屏遮罩**: 解决闪烁问题，通过离屏 Canvas 生成 Mask。
  - [x] **双模交互**: 支持画笔 (Brush) 和 矩形框选 (Rect)。
- **一键抠图 (Rembg)**:
  - [x] **API 集成**: 封装 `src/api/ai.js` 支持一键移除背景。
- **马赛克 (Mosaic)**:
  - [x] **无损处理**: 采用“预览层 + 离屏应用”策略。
- **滤镜与调色**:
  - [x] **ColorMatrix**: 实现亮度、对比度等 6 维调节。
  - [x] **LUT 模拟**: 内置“复古”、“电影”等滤镜预设。

#### 1.4 辅助工具与交互 (Tools & Interaction)
- **快捷键系统 (Shortcuts)**:
  - [x] **可视化面板**: 实现 Keycap 风格的侧边抽屉速查表 (`ShortcutsPanel`)。
  - [x] **通用操作**: 覆盖复制粘贴、图层移动、锁定等。
- **测量工具 (Measure)**:
  - [x] **精准路由**: 点击标尺组件自动跳转至 `Adjust -> Ruler` 面板。
  - [x] **交互绘制**: 支持拖拽创建测量线，自动计算长度。
- **交互优化 (Interaction Polish)**:
  - [x] **右键菜单**: 修复粘贴坐标偏移，实现基于鼠标位置的左上角对齐。
  - [x] **悬浮菜单**: 实现事件隔离，防止在悬浮条上操作时误触底层 Canvas。
  - [x] **剪贴板**: 重构为单例模式 (`clipboardState`)。

#### 1.5 全局导航系统 (Global Navigation System) `Major Upgrade`
- **对象驱动路由 (Object-Driven Routing)**:
  - [x] **智能分发**: 实现了 `useEditorState` 中的 `routeToObject`，根据 Canvas 选中对象自动切换 UI。
  - [x] **二级导航 (Level 2 Support)**: 支持精确跳转至特定折叠面板 (如 `Tool: Adjust` + `Tab: Ruler`)。
  - [x] **元数据注入 (Metadata Injection)**: 支持通过 `customTab` / `customTool` 属性覆盖默认路由行为。
- **视图解耦**:
  - [x] **状态监听**: 侧边栏组件 (`index.vue`) 通过 `watch` 监听全局路由状态自动展开对应模块。
  - [x] **去除残影**: 移除了未选中时的 Sidebar Disabled 状态，保持界面始终可用。

---

## 2. 系统架构备忘 (Architecture Memo)

### 2.1 高清离屏渲染管线 (High-Res Offscreen Pipeline)
> **Pattern**: `src/composables/useOffscreenHelper.js`
- **逻辑**: 获取原图原始分辨率 -> 创建临时 StaticCanvas -> 映射效果 -> 导出高清图。

### 2.2 物理约束系统 (Constraint System)
> **Pattern**: `src/composables/useConstraint.js`
- **逻辑**: 计算对象相对于容器的溢出值，Resizing 时实时修正，Puzzle 拖拽时触发回弹。

### 2.3 状态与快捷键 (State & Shortcuts)
- **State**: 使用 `useEditorState.js` (Reactive 单例) 管理全局状态。
- **Shortcuts**: 采用配置化策略，`ShortcutsPanel` UI 与 `useKeyboardShortcuts` 逻辑共用同一份配置源。

### 2.4 对象驱动路由架构 (Object-Driven Routing Architecture) `NEW`
> **Core Philosophy**: Canvas 是路由触发器，State 是控制器，Sidebar 是视图。
- **配置层 (Configuration)**:
  - `OBJECT_TO_TOOL_MAP` (in `useEditorState.js`): 定义类型到面板的映射 (e.g., `'i-text' -> { tool: 'text', tab: 'style' }`)。
- **感知层 (Sensor)**:
  - `useCanvas.js`: 监听 `mouse:up`, `selection:created`, `selection:updated`。
  - 过滤多选 (`activeSelection`) 和特殊对象，提取 `customTab` 信标。
- **注入层 (Injection)**:
  - 在创建特殊对象 (如标尺、素材) 时，注入 `{ customTab: 'ruler' }` 属性实现精确跳转。
- **视图层 (View)**:
  - 左侧菜单高亮 `state.activeTool`。
  - 二级面板 (如 AdjustPanel) 监听 `state.activeTab` 并自动展开对应模块。

---

## 3. 待办事项 (Backlog & Roadmap)

### 📅 近期计划 (Next Sprint)


### 🐛 已知优化点 (Refactoring)
</file>

<file path="src/components/modules/adjust/AdjustWhite.vue">
<template>
    <div class="tool-group">
        <div class="tool-item" :class="{ 'is-expanded': isExpanded }" @click="handleToggle">
            <div class="left">
                <svg width="18" height="18" viewBox="0 0 1024 1024" style="margin-right: 8px; fill: currentColor">
                    <path
                        d="M96 896a32 32 0 0 1-32-32V160a32 32 0 0 1 32-32h832a32 32 0 0 1 32 32v704a32 32 0 0 1-32 32H96z m315.52-228.48l-68.928-114.88a32 32 0 0 0-54.784 0l-68.928 114.88L158.72 768h316.16l-60.16-100.48zM288 384a64 64 0 1 0 0-128 64 64 0 0 0 0 128z m261.12 216.96l-78.72-118.08a32 32 0 0 0-53.12 0l-78.72 118.08L483.2 697.6h126.72l-54.4-96.64z m208.64-106.88l-98.56-147.84a32 32 0 0 0-53.12 0l-98.56 147.84L652.8 697.6h209.92l-104.96-157.44z" />
                </svg>
                <span>图片补白</span>
            </div>
            <div class="right-icon">
                <svg class="arrow" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor"
                    stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                    <path d="m9 18 6-6-6-6" />
                </svg>
            </div>
        </div>

        <div v-if="isExpanded" class="tool-content">

            <div class="preset-grid">
                <div class="preset-item custom-item" :class="{ active: isCustomMode }" @click="selectCustomMode">
                    <span>自定义</span>
                    <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"
                        stroke-linecap="round" stroke-linejoin="round">
                        <rect x="3" y="3" width="18" height="18" rx="2" ry="2"></rect>
                        <line x1="12" y1="8" x2="12" y2="16"></line>
                        <line x1="8" y1="12" x2="16" y2="12"></line>
                    </svg>
                </div>

                <div v-for="(preset, index) in presets" :key="index" class="preset-item"
                    :class="{ active: activePresetIndex === index }" @click="selectPreset(preset, index)">
                    <span class="preset-name">{{ preset.label }}</span>
                    <span class="preset-dim">{{ preset.w }}×{{ preset.h }}</span>
                </div>
            </div>

            <div class="resize-input-box">
                <div class="input-controls">
                    <div class="input-wrapper">
                        <input type="number" v-model.number="width" class="ie-input" @change="onInputChanged('w')">
                        <span class="suffix">W</span>
                    </div>

                    <div class="link-icon-btn" @click="toggleAdaptive" :title="isAdaptive ? '锁定比例' : '自由比例'">
                        <svg v-if="isAdaptive" width="16" height="16" viewBox="0 0 24 24" fill="none"
                            stroke="var(--ie-primary-color)" stroke-width="2" stroke-linecap="round"
                            stroke-linejoin="round">
                            <path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path>
                            <path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path>
                        </svg>
                        <svg v-else width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="#999"
                            stroke-width="2" stroke-linecap="round" stroke-linejoin="round" style="opacity: 0.6">
                            <path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path>
                            <path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path>
                            <line x1="4" y1="4" x2="20" y2="20" stroke="#999"></line>
                        </svg>
                    </div>

                    <div class="input-wrapper">
                        <input type="number" v-model.number="height" class="ie-input" @change="onInputChanged('h')">
                        <span class="suffix">H</span>
                    </div>
                </div>

                <div class="bg-color-section">
                    <div class="section-label">背景颜色</div>
                    <div class="color-row">
                        <div class="color-item checkerboard" :class="{ active: currentBgColor === 'transparent' }"
                            @click="setBgColor('transparent')" title="透明"></div>
                        <div class="color-item" style="background: #ffffff; border: 1px solid #ddd;"
                            :class="{ active: currentBgColor === '#ffffff' }" @click="setBgColor('#ffffff')"></div>
                        <div class="color-item" style="background: #808080;"
                            :class="{ active: currentBgColor === '#808080' }" @click="setBgColor('#808080')"></div>
                        <div class="color-item" style="background: #000000;"
                            :class="{ active: currentBgColor === '#000000' }" @click="setBgColor('#000000')"></div>
                        <div class="color-item color-picker-wrap" :class="{ active: isCustomColor }">
                            <input type="color" v-model="customColorVal" @input="onCustomColorChange"
                                class="native-color-input" />
                            <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor"
                                stroke-width="2">
                                <path
                                    d="M12 21.35l-1.45-1.32C5.4 15.36 2 12.28 2 8.5 2 5.42 4.42 3 7.5 3c1.74 0 3.41.81 4.5 2.09C13.09 3.81 14.76 3 16.5 3 19.58 3 22 5.42 22 8.5c0 3.78-3.4 6.86-8.55 11.54L12 21.35z" />
                            </svg>
                        </div>
                    </div>
                </div>

            </div>

            <div class="action-buttons">
                <button class="ie-btn ie-primary full" @click="handleApply">应用修改</button>
                <button class="ie-btn full" @click="handleCancel">取消</button>
            </div>

        </div>
    </div>
</template>

<script setup>
import { ref, inject, watch, onMounted, onUnmounted, nextTick, computed } from 'vue';
// 引入修改后的 useCanvasWhite
import { registerWhiteModule, getCurrentSize, applyWhitePadding, startPreview, updatePreview, stopPreview, zoomToPreview } from './useCanvasWhite';

const props = defineProps({
    isExpanded: { type: Boolean, default: false }
});

const emit = defineEmits(['toggle']);
const canvasAPI = inject('canvasAPI');

// === 状态定义 ===
const width = ref(0);
const height = ref(0);
const isAdaptive = ref(false); // 补白模式下，默认自由比例
const originalRatio = ref(1);
const activePresetIndex = ref(-1);
const isInternalUpdate = ref(false);

// 背景颜色状态
const currentBgColor = ref('#ffffff'); // 默认白色
const customColorVal = ref('#ff0000');
const isCustomColor = computed(() => !['transparent', '#ffffff', '#808080', '#000000'].includes(currentBgColor.value));


// 预设数据
const presets = [
    { label: '方形主图', w: 800, h: 800 },
    { label: 'Temu服装图', w: 1340, h: 1785 },
    { label: '方形主图', w: 1000, h: 1000 },
    { label: '竖图主图', w: 750, h: 1000 },
    { label: '方形主图', w: 500, h: 500 },
    { label: '竖图主图', w: 1000, h: 1200 },
    { label: 'Youtube视频封面', w: 1280, h: 720 },
    { label: 'Pinterest帖子', w: 750, h: 1120 },
    { label: 'Facebook封面', w: 851, h: 315 },
];

const isCustomMode = computed(() => activePresetIndex.value === -1);
const currentTargetRatio = computed(() => {
    if (activePresetIndex.value >= 0) {
        const p = presets[activePresetIndex.value];
        return p.h !== 0 ? (p.w / p.h) : 1;
    } else {
        return originalRatio.value;
    }
});

// === 初始化 ===
const initSize = () => {
    if (canvasAPI && canvasAPI.canvas) {
        // 确保传入了 zoomToRect
        registerWhiteModule(canvasAPI.canvas, canvasAPI.saveHistory, canvasAPI.zoomToRect);

        const size = getCurrentSize();
        width.value = size.width;
        height.value = size.height;

        nextTick(() => {
            // 仅开启预览框，不移动相机
            startPreview(width.value, height.value, currentBgColor.value);
        });
    }
};


// === 交互逻辑 ===
const selectCustomMode = () => {
    activePresetIndex.value = -1;
    const size = getCurrentSize();
    width.value = size.width;
    height.value = size.height;
    updatePreviewBox();
};

const selectPreset = (preset, index) => {
    activePresetIndex.value = index;
    isInternalUpdate.value = true;
    width.value = preset.w;
    height.value = preset.h;

    nextTick(() => {
        isInternalUpdate.value = false;
        updatePreviewBox(); // 先更新蓝框尺寸

        // ✅ 触发相机放大：让 500*500 的框占据当初图片占据的屏幕范围
        zoomToPreview();
    });
};

const toggleAdaptive = () => {
    isAdaptive.value = !isAdaptive.value;
    if (isAdaptive.value && width.value > 0) {
        height.value = Math.round(width.value / currentTargetRatio.value);
        updatePreviewBox();
    }
};

// 背景颜色处理
const setBgColor = (color) => {
    currentBgColor.value = color;
    updatePreviewBox();
};

const onCustomColorChange = (e) => {
    currentBgColor.value = e.target.value;
    updatePreviewBox();
};

// 监听输入
watch([width, height], ([newW, newH]) => {
    if (isInternalUpdate.value) return;
    // 如果开启了锁定比例 (输入W自动算H)
    if (isAdaptive.value) {
        // 简单的防止死循环逻辑
        // 实际业务中通常只在一个方向输入时触发另一个，这里简化为change触发updatePreview
    }
    updatePreviewBox();
});

const onInputChanged = (type) => {
    // 1. 如果开启了“锁定比例” (isAdaptive) 且有原始比例数据
    if (isAdaptive.value && originalRatio.value) {

        // 标记为内部更新，防止触发 watch 导致死循环或多余计算
        isInternalUpdate.value = true;

        // 根据输入的类型进行换算
        // originalRatio = 宽 / 高

        if (type === 'w' && width.value > 0) {
            // 用户改了【宽度】 -> 自动算【高度】
            // 公式: Height = Width / Ratio
            height.value = Math.round(width.value / originalRatio.value);

        } else if (type === 'h' && height.value > 0) {
            // 用户改了【高度】 -> 自动算【宽度】
            // 公式: Width = Height * Ratio
            width.value = Math.round(height.value * originalRatio.value);
        }

        // 计算并赋值完成后，在下一个 tick 释放锁
        nextTick(() => {
            isInternalUpdate.value = false;
        });
    }

    // 2. 实时更新画布上的预览框
    updatePreviewBox();
};

const updatePreviewBox = () => {
    if (width.value > 0 && height.value > 0) {
        updatePreview(width.value, height.value, currentBgColor.value);
    } else {
        stopPreview();
    }
};

// 监听面板展开
watch(() => props.isExpanded, (val) => {
    if (val) initSize();
    else stopPreview();
});

const handleApply = async () => {
    // 1. 等待图片处理完全结束 (新图上屏，状态重置完成)
    await applyWhitePadding(width.value, height.value, currentBgColor.value);

    // 2. 只有处理完了，才通知父组件关闭面板
    // 此时 isExpanded 变 false 触发 watcher 里的 stopPreview
    // 但因为 originalTransform 已经被置空，stopPreview 不会产生任何副作用
    emit('toggle');
};

const handleCancel = () => {
    stopPreview();
    emit('toggle');
}

const handleToggle = () => emit('toggle');

onMounted(() => {
    if (props.isExpanded) initSize();
});

onUnmounted(() => stopPreview());
</script>

<style scoped>
/* 继承并复用了大部分 AdjustResize 的样式 */
.preset-grid {
    display: grid;
    grid-template-columns: 1fr 1fr;
    gap: 8px;
    margin-bottom: 16px;
    max-height: 280px;
    overflow-y: auto;
}

.preset-item {
    background-color: #f5f7fa;
    padding: 10px;
    border-radius: 6px;
    font-size: 13px;
    color: #606266;
    cursor: pointer;
    border: 1px solid transparent;
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: space-between;
    text-align: center;
    transition: all 0.2s;
}

.preset-item:hover {
    background-color: #e6f7ff;
    border-color: #c0c4cc;
}

.preset-item.active {
    background-color: #ecf5ff;
    color: var(--ie-primary-color);
    border-color: var(--ie-primary-color);
    font-weight: 500;
}

.custom-item {
    flex-direction: row;
    grid-column: span 2;
    background-color: #fff;
    border: 1px dashed #dcdfe6;
}

.custom-item.active {
    border-style: solid;
}

.preset-name {
    font-weight: 500;
    margin-bottom: 2px;
}

.preset-dim {
    font-size: 11px;
    color: #909399;
}

.resize-input-box {
    background-color: #fff;
    padding: 4px 0;
}

.input-controls {
    display: flex;
    align-items: center;
    justify-content: space-between;
    margin-bottom: 16px;
}

.input-wrapper {
    position: relative;
    width: 40%;
}

.ie-input {
    text-align: center;
    padding-right: 20px;
    font-weight: bold;
    color: #333;
    width: 100%;
    border: 1px solid #dcdfe6;
    border-radius: 4px;
    height: 32px;
    font-size: 13px;
}

.ie-input:focus {
    border-color: var(--ie-primary-color);
    outline: none;
}

.suffix {
    position: absolute;
    right: 6px;
    top: 50%;
    transform: translateY(-50%);
    color: #c0c4cc;
    font-size: 11px;
    pointer-events: none;
}

.link-icon-btn {
    cursor: pointer;
    padding: 4px;
    border-radius: 4px;
}

.link-icon-btn:hover {
    background-color: #f0f0f0;
}

/* 颜色选择器样式 */
.bg-color-section {
    margin-bottom: 16px;
}

.section-label {
    font-size: 12px;
    color: #606266;
    margin-bottom: 8px;
}

.color-row {
    display: flex;
    gap: 12px;
}

.color-item {
    width: 28px;
    height: 28px;
    border-radius: 4px;
    cursor: pointer;
    box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
    border: 2px solid transparent;
    transition: all 0.2s;
}

.color-item.active {
    border-color: var(--ie-primary-color);
    transform: scale(1.1);
}

.checkerboard {
    background-image:
        linear-gradient(45deg, #ccc 25%, transparent 25%),
        linear-gradient(-45deg, #ccc 25%, transparent 25%),
        linear-gradient(45deg, transparent 75%, #ccc 75%),
        linear-gradient(-45deg, transparent 75%, #ccc 75%);
    background-size: 8px 8px;
    background-position: 0 0, 0 4px, 4px -4px, -4px 0px;
    background-color: #fff;
}

.color-picker-wrap {
    background: linear-gradient(to bottom right, #ff0000, #00ff00, #0000ff);
    display: flex;
    align-items: center;
    justify-content: center;
    color: #fff;
    position: relative;
    overflow: hidden;
}

.native-color-input {
    position: absolute;
    left: 0;
    top: 0;
    width: 100%;
    height: 100%;
    opacity: 0;
    cursor: pointer;
}


.action-buttons {
    display: flex;
    gap: 10px;
}

.full {
    flex: 1;
}

.tool-item:hover .arrow {
    transform: translateX(2px);
    transition: transform 0.2s;
}

.tool-content {
    padding: 16px;
    border: 1px solid #eee;
    border-top: none;
}
</style>
</file>

<file path="src/main.js">
import { createApp } from 'vue'
import './style.css' // 确保这里引入了我们新写的通用 CSS (包含 .ie-btn 等样式)
import App from './App.vue'
import { applyTheme } from './config/theme.js';
// 1. 创建 Vue 实例
const app = createApp(App)

// 2. 应用主题
applyTheme();

// 3. 挂载
app.mount('#app')
</file>

<file path="vite.config.js">
// vite.config.js
import { defineConfig } from 'vite'
import vue from '@vitejs/plugin-vue'
import dts from 'vite-plugin-dts'
import { fileURLToPath, URL } from 'node:url'
import { resolve } from 'path'

export default defineConfig({
  plugins: [
    vue(),
    // 2. 配置插件
    dts({
      outDir: 'dist',
      // 确保只为源码生成类型
      include: ['src/**/*.js', 'src/**/*.vue'],
      // 自动尝试生成 vue 文件的类型定义
      // 确保生成的 .d.ts 文件路径清晰
      insertTypesEntry: true,
    })
  ],
  resolve: {
    alias: {
      '@': fileURLToPath(new URL('./src', import.meta.url))
    }
  },
  build: {
    lib: {
      entry: resolve(__dirname, 'src/index.js'),
      name: 'ImageEditor',
      fileName: 'image-editor'
    },
    rollupOptions: {
      external: ['vue'],
      output: {
        globals: {
          vue: 'Vue'
        },
        assetFileNames: (assetInfo) => {
          if (assetInfo.name === 'style.css') return 'index.css';
          return assetInfo.name;
        },
        exports: 'named'
      }
    },
    cssCodeSplit: false
  }
})
</file>

<file path="src/components/modules/adjust/AdjustInpaint.vue">
<template>
  <div class="tool-group">
    <div class="tool-item" :class="{ 'is-expanded': isExpanded }" @click="$emit('toggle')">
      <div class="left">
        <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
          <path d="M20 14.66V20a2 2 0 0 1-2 2H4a2 2 0 0 1-2-2V6a2 2 0 0 1 2-2h5.34"></path>
          <polygon points="18 2 22 6 12 16 8 16 8 12 18 2"></polygon>
        </svg>
        <span>智能消除笔</span>
      </div>
      <div class="right-icon">
        <svg class="arrow" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
          <path d="m9 18 6-6-6-6" />
        </svg>
      </div>
    </div>

    <div v-if="isExpanded" class="tool-content">
      
      <div class="mode-row">
        <div 
          class="mode-btn" 
          :class="{ active: drawMode === 'brush' }" 
          @click="drawMode = 'brush'" 
        >
          <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
            <path d="M18 13.29C18 16.54 15.6 19 12 19s-6-2.46-6-5.71c0-2.83 2-6.29 6-9.29 4 3 6 6.46 6 9.29z"></path>
            <path d="M12 19v2"></path>
          </svg>
          <span class="mode-label">涂抹</span>
        </div>
        
        <div 
          class="mode-btn" 
          :class="{ active: drawMode === 'rect' }" 
          @click="drawMode = 'rect'" 
        >
          <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
            <rect x="3" y="3" width="18" height="18" rx="2" ry="2"></rect>
          </svg>
          <span class="mode-label">框选</span>
        </div>
      </div>

      <div class="control-section">
        <div v-if="drawMode === 'brush'">
          <div class="label-row">
            <span>画笔大小</span>
            <input 
              type="number" 
              v-model.number="brushSize" 
              class="ie-input-number"
              min="5"
              max="100"
            >
          </div>
          <input 
            type="range" 
            v-model.number="brushSize" 
            min="5" 
            max="100" 
            class="ie-slider"
          >
          <div class="auto-tip">
             💡 涂抹结束 1秒后自动消除
          </div>
        </div>

        <div v-else class="tips-box">
          <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" style="margin-right:4px; min-width:14px">
            <rect x="3" y="3" width="18" height="18" rx="2" ry="2"></rect>
          </svg>
          <span>拖拽框选，松手后自动消除区域内容。</span>
        </div>
      </div>

      <div class="action-buttons">
        <button class="ie-btn full" @click="handleRestoreOriginal">
          <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" style="margin-right:6px">
            <path d="M3 12a9 9 0 1 0 9-9 9.75 9.75 0 0 0-6.74 2.74L3 8"></path>
            <path d="M3 3v5h5"></path>
          </svg>
          恢复原图
        </button>
      </div>

    </div>
  </div>
</template>

<script setup>
import { ref, inject, watch, onMounted, onUnmounted } from 'vue';
import { 
  registerInpaintModule, 
  enterInpaintMode, 
  exitInpaintMode, 
  handleRestoreOriginal,
  brushSize, 
  drawMode 
} from './useCanvasInpaint';

const props = defineProps({
  isExpanded: Boolean
});

const emit = defineEmits(['toggle']);
const canvasAPI = inject('canvasAPI');

onMounted(() => {
  if (canvasAPI?.canvas) {
    registerInpaintModule(canvasAPI.canvas, canvasAPI.saveHistory);
  }
});

watch(() => props.isExpanded, (expanded) => {
  if (expanded) {
    enterInpaintMode();
  } else {
    exitInpaintMode();
  }
});

onUnmounted(() => {
  exitInpaintMode();
});
</script>

<style scoped>
.mode-row { 
  display: flex; 
  gap: 12px; 
  margin-bottom: 20px; 
}

.mode-btn { 
  flex: 1; 
  height: 60px;
  display: flex; 
  flex-direction: column;
  align-items: center; 
  justify-content: center; 
  border-radius: 6px; 
  background: #f5f7fa; 
  cursor: pointer; 
  border: 1px solid transparent; 
  transition: all 0.2s; 
  color: #606266;
}

.mode-btn:hover {
  background: #eef1f6;
  color: #333;
}

.mode-btn.active { 
  background: #ecf5ff; 
  border-color: var(--ie-primary-color); 
  color: var(--ie-primary-color); 
  font-weight: 500;
}

.mode-label {
  font-size: 12px;
  margin-top: 4px;
}

.control-section {
  margin-bottom: 24px;
  min-height: 50px; 
}

.label-row { 
  display: flex; 
  justify-content: space-between; 
  align-items: center; /* 确保垂直对齐 */
  font-size: 12px; 
  color: #606266; 
  margin-bottom: 8px; 
}

.tips-box {
  display: flex;
  align-items: flex-start;
  padding: 10px;
  background-color: #f4f4f5;
  border: 1px solid #e9e9eb;
  border-radius: 4px;
  font-size: 12px;
  color: #909399;
  line-height: 1.4;
}

.auto-tip {
  margin-top: 8px;
  font-size: 12px;
  color: var(--ie-primary-color); 
  text-align: center;
  background: #ecf5ff;
  padding: 4px;
  border-radius: 4px;
}

.action-buttons { 
  display: flex; 
  margin-top: auto;
}

.full { 
  flex: 1; 
  height: 36px;
}

.tool-content {
  padding: 16px;
}

/* === 强制修正滑块主题色 === */
.ie-slider::-webkit-slider-thumb {
  -webkit-appearance: none;
  appearance: none;
  width: 16px;
  height: 16px;
  border-radius: 50%;
  background: var(--ie-primary-color);
  cursor: pointer;
  border: 2px solid white;
  box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
  margin-top: -6px;
}

.ie-slider::-moz-range-thumb {
  width: 16px;
  height: 16px;
  border: 2px solid white;
  border-radius: 50%;
  background: var(--ie-primary-color);
  cursor: pointer;
  box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
}

.ie-slider::-webkit-slider-runnable-track {
  height: 4px;
  background: #e4e7ed;
  border-radius: 2px;
}
</style>
</file>

<file path="src/components/modules/adjust/AdjustRembg.vue">
<template>
  <div class="tool-group">
    <div class="tool-item" @click="handleRembg">
      <div class="left">
        <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"
          stroke-linecap="round" stroke-linejoin="round" style="margin-right: 8px;">
          <circle cx="6" cy="6" r="3" />
          <path d="M8.12 8.12 12 12" />
          <path d="M20 4 8.12 15.88" />
          <circle cx="6" cy="18" r="3" />
          <path d="M14.8 14.8 20 20" />
        </svg>
        <span>一键抠图</span>
      </div>

      <div class="right-icon">
        <svg v-if="loading" class="loading-icon" width="16" height="16" viewBox="0 0 24 24" fill="none"
          stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
          <path d="M21 12a9 9 0 1 1-6.219-8.56" />
        </svg>
        <svg v-else class="arrow" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor"
          stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
          <path d="m9 18 6-6-6-6" />
        </svg>
      </div>
    </div>
  </div>
</template>

<script setup>
import { ref, inject } from 'vue'; // 确保引入 inject
import { aiApi } from '@/api/ai';
import { toast } from '@/utils/toast';

const canvasAPI = inject('canvasAPI');
const config = inject('editorConfig'); // 1. 获取全局配置
const loading = ref(false);

const handleRembg = async () => {
  const activeObj = canvasAPI?.canvas.value?.getActiveObject();
  if (!activeObj || activeObj.type !== 'image') return toast.warning('请先选中图片');

  loading.value = true;
  try {
    const src = activeObj.getSrc();
    const blob = await (await fetch(src)).blob();

    // 2. 调用 API 时传入配置中的 baseUrl
    // 如果 config 为空（单独使用组件时），api 内部会使用默认值
    const newUrl = await aiApi.removeBackground(
      new File([blob], "img.png"),
      config?.aiBaseUrl
    );

    canvasAPI.replaceActiveImage(newUrl);
    toast.success('抠图完成');
  } catch (e) {
    console.error(e);
    toast.error('抠图失败');
  } finally {
    loading.value = false;
  }
};
</script>

<style scoped>
/* Loading 旋转动画 */
.loading-icon {
  animation: rotating 1s linear infinite;
  color: var(--ie-primary-color);
}

@keyframes rotating {
  from {
    transform: rotate(0deg);
  }

  to {
    transform: rotate(360deg);
  }
}

/* 简单的 hover 动画 */
.tool-item:hover .arrow {
  transform: translateX(2px);
  transition: transform 0.2s;
}
</style>
</file>

<file path="src/composables/useEditorState.js">
import { reactive, readonly } from 'vue';

/**
 * ✨ 全局路由配置表 (Single Source of Truth)
 * 定义 Fabric 对象类型 -> 工具面板(Tool) + 子选项卡(Tab) 的映射关系
 */
export const OBJECT_TO_TOOL_MAP = {
    // === 基础形状 ===
    'i-text':  { tool: 'text', tab: 'style' },    // 文本 -> 文本面板-样式Tab
    'textbox': { tool: 'text', tab: 'style' },
    'image':   { tool: 'adjust', tab: 'filter' }, // 图片 -> 调整面板-滤镜Tab
    'group':   { tool: 'adjust', tab: '' },       // 组 -> 调整面板 (根据业务需求)
    
    // === 绘制/矢量 ===
    'path':    { tool: 'draw', tab: '' },         // 路径 -> 绘制面板
    
    // === 几何图形 (通常归类为素材或边框，根据你的业务定) ===
    'rect':     { tool: 'border', tab: 'style' },
    'circle':   { tool: 'material', tab: 'basic' },
    'triangle': { tool: 'material', tab: 'basic' },
    
    // === 自定义业务类型 ===
    'puzzle':   { tool: 'puzzle', tab: 'template' }
};

// 单例状态
const state = reactive({
    activeTool: 'adjust', // 一级菜单 ID
    activeTab: '',        // ✨ 新增: 二级菜单 ID (例如 'style', 'color', 'filter')
    
    isDrawing: false,     // 是否处于自由绘制模式
    
    canUndo: false,       // 历史记录状态
    canRedo: false,
    
    isLoading: false,
    loadingText: '处理中...',
    
    isSidebarDisabled: false, // 侧边栏残影模式
    
    /**
     * ✨ 导航来源标记
     * 'system': 初始化或系统重置
     * 'manual': 用户手动点击侧边栏 (优先级最高，应有点击反馈)
     * 'canvas': 画布对象选中触发自动跳转 (应平滑过渡，无干扰)
     */
    navigationSource: 'system' 
});

export function useEditorState() {
    
    /**
     * 切换当前激活的工具和选项卡
     * @param {string} tool - 一级工具 ID
     * @param {string} tab - (可选) 二级选项卡 ID
     * @param {string} source - 触发来源 ('manual' | 'canvas' | 'system')
     */
    const setActiveTool = (tool, tab = '', source = 'manual') => {
        // 状态防抖：如果 Tool 和 Tab 都没变，且侧边栏也是激活状态，则不执行
        if (state.activeTool === tool && state.activeTab === tab && !state.isSidebarDisabled) {
            return;
        }

        state.activeTool = tool;
        state.activeTab = tab; // 更新二级路由
        state.navigationSource = source;
        
        // 副作用处理
        state.isDrawing = false; // 切换工具默认退出绘制模式
        state.isSidebarDisabled = false; // 只要切换工具，必定激活面板
    };

    const toggleDrawing = (status) => {
        state.isDrawing = status;
    };

    const setHistoryState = (canUndo, canRedo) => {
        state.canUndo = canUndo;
        state.canRedo = canRedo;
    };

    const setLoading = (status, text = '处理中...') => {
        state.isLoading = status;
        state.loadingText = text;
    };

    const setSidebarDisabled = (status) => {
        state.isSidebarDisabled = status;
    };

    // === ✨ 核心：智能路由系统 ===

    /**
     * 根据 Canvas 选中的对象，自动路由到对应的工具面板
     * @param {Object} target - Fabric 对象实例
     * @returns {boolean} - 是否成功匹配并跳转
     */
    const routeToObject = (target) => {
        if (!target) return false;

        // 1. 优先检查对象实例级元数据 (Custom Payload)
        // 允许在代码中 addText 时注入 { customTab: 'color' } 来覆盖默认行为
        if (target.customTab) {
            // 获取该类型的基础配置，如果没有则默认为 adjust
            const baseConfig = OBJECT_TO_TOOL_MAP[target.type] || { tool: 'adjust' };
            const targetTool = baseConfig.tool || 'adjust';
            
            console.log(`[Router] Custom routing: Tool[${targetTool}] Tab[${target.customTab}]`);
            setActiveTool(targetTool, target.customTab, 'canvas');
            return true;
        }

        // 2. 提取并标准化对象类型
        let type = target.type;
        
        // 处理自定义标识
        if (target.isPuzzleImage || target.isPuzzleController) {
            type = 'puzzle';
        }
        
        // ⚠️ 已移除 activeSelection (多选) 的判断逻辑
        // 如果你需要多选时保持在当前页面或去特定页面，可在此重新添加

        // 3. 查表
        const config = OBJECT_TO_TOOL_MAP[type];
        
        if (config) {
            // 兼容配置是字符串的情况 (旧逻辑兼容)
            const toolId = typeof config === 'string' ? config : config.tool;
            const tabId = typeof config === 'string' ? '' : config.tab;
            
            // 触发跳转，标记来源为 'canvas'
            setActiveTool(toolId, tabId, 'canvas');
            return true;
        }
        
        // 4. 未匹配到路由 (例如辅助线、背景控制点等)
        return false;
    };

    return {
        state: readonly(state), // 导出只读状态
        setActiveTool,
        toggleDrawing,
        setHistoryState,
        setLoading,
        setSidebarDisabled,
        routeToObject // 导出路由动作供 useCanvas 使用
    };
}

// 全局聚焦系数 (保留)
export const ZOOM_PADDING = 0.921;
</file>

<file path="src/components/modules/puzzle/useCanvasPuzzle.js">
// src/components/modules/puzzle/useCanvasPuzzle.js
import { unref, reactive } from "vue";
import { fabric } from "fabric";
import { parseTemplateToCells, generateGridCells } from "./config";

// 【引入通用规范】
import { constrainObjectToRect, animateRebound } from '@/composables/useConstraint';

// === 内部变量 ===
let canvasRef = null;
let saveHistoryFn = null;
let uiCallbacks = { onCellClick: null };
let prePuzzleSnapshot = null;
// 交互状态
let isDragging = false;
let dragOriginPoint = null;
let dragLastPoint = { x: 0, y: 0 };
let dragProxy = null;
let dragOriginCellIndex = -1;
let dragOffset = { x: 0, y: 0 };
let isCreatingProxy = false;

// 默认配置
const DEFAULTS = {
  padding: 20,
  spacing: 10,
  radius: 0,
  width: 1000,
  height: 1000,
  bgColor: '#ffffff',
  rows: 1,
  cols: 1
};

const puzzleState = reactive({
  isActive: false,
  cells: [],
  padding: DEFAULTS.padding,
  spacing: DEFAULTS.spacing,
  radius: DEFAULTS.radius,
  width: DEFAULTS.width,
  height: DEFAULTS.height,
  bgColor: DEFAULTS.bgColor,
  startX: 0, // 新增：拼图区域的左上角逻辑坐标
  startY: 0  // 新增
});

export const registerPuzzleModule = (canvas, saveHistory, callbacks = {}) => {
  canvasRef = canvas;
  saveHistoryFn = saveHistory;
  uiCallbacks = { ...uiCallbacks, ...callbacks };
};

export const initPuzzleMode = (initialTemplate = null) => {
  const canvas = unref(canvasRef);
  if (!canvas) return;
  prePuzzleSnapshot = JSON.stringify(canvas.toJSON(["id", "selectable", "name"]));
  if (puzzleState.savedHistoryData && puzzleState.savedHistoryData.length > 0) {
    restorePuzzleData();
    bindEvents();
    return;
  }

  puzzleState.isActive = true;

  // 【优化】计算拼图区域的位置：使其与原图位置重合或在画布中心
  const activeImg = canvas.getObjects().find(o => o.type === 'image');
  if (activeImg) {
    const rect = activeImg.getBoundingRect();
    puzzleState.width = rect.width;
    puzzleState.height = rect.height;
    puzzleState.startX = rect.left;
    puzzleState.startY = rect.top;
  } else {
    // 如果没有原图，则在画布中心开启 1000x1000 的区域
    const center = canvas.getCenter();
    puzzleState.width = 1000;
    puzzleState.height = 1000;
    puzzleState.startX = center.left - 500;
    puzzleState.startY = center.top - 500;
  }

  bindEvents();

  const cells = initialTemplate ? parseTemplateToCells(initialTemplate) : generateGridCells(DEFAULTS.rows, DEFAULTS.cols);
  updateLayout(cells);

};

/**
 * 唯一的业务出口函数
 * @param {string} action 'save' | 'discard'
 */
export const completeExitPuzzle = (action = 'save') => {
  const canvas = unref(canvasRef);
  if (!canvas) return;

  // 记录视角，防止切换模块后画面“瞬移”
  const savedVpt = canvas.viewportTransform ? [...canvas.viewportTransform] : [1, 0, 0, 1, 0, 0];

  // 先执行一次通用退出清理
  exitPuzzleMode();

  if (action === 'save') {
    // --- 保存逻辑：生成并固化图片 ---
    const auxObjs = canvas.getObjects().filter(o =>
      o.isPuzzleController || o.isDeleteBtn || o.isPlaceholder || o.isGhost
    );
    auxObjs.forEach(o => o.visible = false);

    canvas.setViewportTransform([1, 0, 0, 1, 0, 0]);
    canvas.renderAll();

    const dataURL = canvas.toDataURL({
      format: 'png', quality: 1, multiplier: 2,
      left: puzzleState.startX, top: puzzleState.startY,
      width: puzzleState.width, height: puzzleState.height
    });

    const allPuzzleObjs = canvas.getObjects().filter(o => o.isPuzzleItem);
    canvas.remove(...allPuzzleObjs);

    fabric.Image.fromURL(dataURL, (img) => {
      img.set({
        left: puzzleState.startX, top: puzzleState.startY,
        originX: 'left', originY: 'top',
        selectable: true
      });
      img.scaleToWidth(puzzleState.width);
      canvas.add(img);
      canvas.setViewportTransform(savedVpt);
      if (saveHistoryFn) saveHistoryFn();
      canvas.requestRenderAll();
    }, { crossOrigin: 'anonymous' });

  } else {
    // --- 【不保存逻辑】直接通过快照还原 ---
    if (prePuzzleSnapshot) {
      // loadFromJSON 会自动调用 clear() 清空当前所有（拼图后的）图片
      canvas.loadFromJSON(prePuzzleSnapshot, () => {
        canvas.setViewportTransform(savedVpt);
        canvas.requestRenderAll();
      });
    }
  }
};

// === 模块级重置 ===
export const resetPuzzle = () => {
  const canvas = unref(canvasRef);
  if (!canvas) return;

  puzzleState.padding = DEFAULTS.padding;
  puzzleState.spacing = DEFAULTS.spacing;
  puzzleState.radius = DEFAULTS.radius;
  puzzleState.bgColor = DEFAULTS.bgColor;

  const defaultCells = generateGridCells(DEFAULTS.rows, DEFAULTS.cols);
  updateLayout(defaultCells);

  if (saveHistoryFn) saveHistoryFn();
};

// === 退出逻辑 (核心修复：只导出有效区域) ===

export const exitPuzzleMode = () => {
  const canvas = unref(canvasRef);
  if (!canvas) return;

  puzzleState.isActive = false;
  unbindEvents(); // 仅执行解绑，不操作画布对象
};

// === 修改后的辅助函数：智能适配屏幕 ===
const fitPuzzleToScreen = () => {
  const canvas = unref(canvasRef);
  if (!canvas) return;

  const { width: puzzleW, height: puzzleH } = puzzleState;
  // 注意：这里用 width / zoom 换算回逻辑像素，确保对比单位一致
  const canvasW = canvas.width / canvas.getRetinaScaling();
  const canvasH = canvas.height / canvas.getRetinaScaling();

  // 1. 计算最佳适配 Zoom (留出 10% 边距)
  const paddingFactor = 0.9;
  const zoomX = (canvasW * paddingFactor) / puzzleW;
  const zoomY = (canvasH * paddingFactor) / puzzleH;

  // 算出“能完全放下拼图”的缩放值
  let targetZoom = Math.min(zoomX, zoomY);

  // 2. 【核心修改】智能阈值处理
  // 如果计算出的缩放比例大于 0.9 (说明图片其实跟屏幕差不多大，或者比屏幕小)
  // 我们就强制设为 1 (100%)，保证画质清晰度，只有图特别大时才缩小
  if (targetZoom > 0.9) {
    targetZoom = 1;
  }

  // 3. 应用缩放
  canvas.setZoom(targetZoom);

  // 4. 计算 Pan (让拼图中心 对齐 视口中心)
  const puzzleCenterX = puzzleW / 2;
  const puzzleCenterY = puzzleH / 2;

  // 视口在当前缩放下的逻辑一半宽高
  const viewportHalfW = canvasW / (2 * targetZoom);
  const viewportHalfH = canvasH / (2 * targetZoom);

  const panX = puzzleCenterX - viewportHalfW;
  const panY = puzzleCenterY - viewportHalfH;

  canvas.absolutePan({ x: panX, y: panY });
  canvas.requestRenderAll();

  // 同步外部 UI 显示
  canvas.fire('zoom:change', { zoom: targetZoom });
};


// 当用户点击“再次编辑”或切换回拼图模块时调用
export const restorePuzzleData = () => {
  const canvas = unref(canvasRef);
  if (!canvas) return;

  // 1. 清理预览图
  const previewImg = canvas.getObjects().find(o => o.isPreviewSnapshot);
  if (previewImg) {
    canvas.remove(previewImg);
  }

  // 2. 获取存档数据
  const historyData = puzzleState.savedHistoryData;
  // 【新增】恢复之前的拼图尺寸设置
  const savedSettings = puzzleState.savedSettings;

  if (!historyData || historyData.length === 0) return;

  // 【新增】恢复尺寸状态
  if (savedSettings) {
    puzzleState.width = savedSettings.width;
    puzzleState.height = savedSettings.height;
    puzzleState.padding = savedSettings.padding;
    puzzleState.spacing = savedSettings.spacing;
    puzzleState.radius = savedSettings.radius;
    if (savedSettings.bgColor) {
      puzzleState.bgColor = savedSettings.bgColor;
      canvas.setBackgroundColor(savedSettings.bgColor, () => { });
    }
  }

  // 3. 异步恢复图片
  let loadedCount = 0;
  // 标记 loading 状态（如果你的 UI 有 loading 遮罩可以在这开启）

  historyData.forEach(item => {
    fabric.Image.fromURL(item.src, (img) => {
      loadedCount++;

      img.set({
        id: item.id,
        left: item.left,
        top: item.top,
        scaleX: item.scaleX,
        scaleY: item.scaleY,
        angle: item.angle,
        flipX: item.flipX,
        flipY: item.flipY,
        cropX: item.cropX,
        cropY: item.cropY,
        originX: item.originX || 'center', // 确保锚点正确
        originY: item.originY || 'center',
        cellIndex: item.cellIndex,
        isPuzzleItem: true,
        isPuzzleImage: true,
        originalSrc: item.src,
        selectable: false,
        evented: false,
        hasControls: false,
        hasBorders: false,
      });

      canvas.add(img);

      // 当所有图片加载完毕时
      if (loadedCount === historyData.length) {
        puzzleState.isActive = true;
        refreshPuzzleObjects(false);

        // 【关键修复】所有元素就位后，执行一次镜头对齐！
        // fitPuzzleToScreen();

        canvas.requestRenderAll();
      }
    }, { crossOrigin: 'anonymous' });
  });
};
// =========================================================================
// 核心逻辑：位置计算 (保留用于初始适配)
// 注意：虽然 animateRebound 能处理回弹，但“初始放入”时的居中逻辑还是需要的
// =========================================================================
const calculateFitPosition = (img, cell) => {
  // 这里的逻辑是“Cover”模式：确保图片填满格子且居中
  const minScaleX = cell.width / img.width;
  const minScaleY = cell.height / img.height;
  const minScale = Math.max(minScaleX, minScaleY) + 0.0001;
  return {
    scaleX: minScale,
    scaleY: minScale,
    left: cell.left + cell.width / 2,
    top: cell.top + cell.height / 2
  };
};

// === 事件绑定 ===
const bindEvents = () => {
  const canvas = unref(canvasRef);
  canvas.on('mouse:down', onMouseDown);
  canvas.on('mouse:move', onMouseMove);
  canvas.on('mouse:up', onMouseUp);
  canvas.on('mouse:wheel', onMouseWheel);
};

const unbindEvents = () => {
  const canvas = unref(canvasRef);
  canvas.off('mouse:down', onMouseDown);
  canvas.off('mouse:move', onMouseMove);
  canvas.off('mouse:up', onMouseUp);
  canvas.off('mouse:wheel', onMouseWheel);
};

const onMouseDown = (opt) => {
  if (!puzzleState.isActive) return;
  const canvas = unref(canvasRef);
  const target = opt.target;

  dragOriginPoint = opt.absolutePointer;
  const pointer = canvas.getPointer(opt.e);
  dragLastPoint = { x: pointer.x, y: pointer.y };

  if (target && target.isDeleteBtn) {
    deleteImageFromCell(target.cellIndex);
    isDragging = false;
    dragOriginCellIndex = -1;
    dragOriginPoint = null;
    return;
  }

  if (target && target.isPuzzleController) {
    isDragging = true;
    dragOriginCellIndex = target.cellIndex;
    canvas.setActiveObject(target);

    const img = canvas.getObjects().find(o => o.isPuzzleImage && o.cellIndex === target.cellIndex);
    if (img) {
      dragOffset = {
        x: img.left - pointer.x,
        y: img.top - pointer.y
      };
    } else {
      dragOffset = { x: 0, y: 0 };
    }

  } else {
    isDragging = false;
    dragOriginCellIndex = -1;
  }
};

const onMouseMove = (opt) => {
  if (!puzzleState.isActive || !isDragging || dragOriginCellIndex === -1) return;
  const canvas = unref(canvasRef);
  const pointer = canvas.getPointer(opt.e);
  const distFromStart = Math.sqrt(
    Math.pow(pointer.x - (dragOriginPoint?.x || 0), 2) +
    Math.pow(pointer.y - (dragOriginPoint?.y || 0), 2)
  );

  if (distFromStart < 5) return;

  const cell = puzzleState.cells.find(c => c.index === dragOriginCellIndex);
  if (!cell) return;

  const isInsideCell =
    pointer.x >= cell.left && pointer.x <= cell.left + cell.width &&
    pointer.y >= cell.top && pointer.y <= cell.top + cell.height;

  if (isInsideCell) {
    // 场景A：在格子内部微调（Pan）
    if (dragProxy) {
      canvas.remove(dragProxy);
      dragProxy = null;
      isCreatingProxy = false;
      const originImg = canvas.getObjects().find(o => o.isPuzzleImage && o.cellIndex === dragOriginCellIndex);
      if (originImg) originImg.set('opacity', 1);
    }
    const deltaX = pointer.x - dragLastPoint.x;
    const deltaY = pointer.y - dragLastPoint.y;
    const img = canvas.getObjects().find(o => o.isPuzzleImage && o.cellIndex === dragOriginCellIndex);
    if (img) {
      // 自由拖动，不做实时约束，松手时再回弹
      img.set({ left: img.left + deltaX, top: img.top + deltaY });
      img.setCoords();
    }
  } else {
    // 场景B：拖出格子（准备交换）
    if (!dragProxy && !isCreatingProxy) {
      isCreatingProxy = true;
      createDragProxy(dragOriginCellIndex, pointer);
    }

    if (dragProxy) {
      dragProxy.set({
        left: pointer.x + dragOffset.x,
        top: pointer.y + dragOffset.y
      });
      dragProxy.setCoords();
    }
  }
  dragLastPoint = { x: pointer.x, y: pointer.y };
  canvas.requestRenderAll();
};

const createDragProxy = (cellIndex, pointer) => {
  const canvas = unref(canvasRef);
  const cell = puzzleState.cells.find(c => c.index === cellIndex);
  const img = canvas.getObjects().find(o => o.isPuzzleImage && o.cellIndex === cellIndex);

  if (!cell || !img) {
    isCreatingProxy = false;
    return;
  }

  img.set('opacity', 0.4);

  img.clone((cloned) => {
    dragProxy = cloned;

    if (pointer) {
      dragOffset = {
        x: img.left - pointer.x,
        y: img.top - pointer.y
      };
    }

    dragProxy.set({
      opacity: 0.8, evented: false, selectable: false,
      originX: 'center', originY: 'center',
      left: pointer ? pointer.x + dragOffset.x : img.left,
      top: pointer ? pointer.y + dragOffset.y : img.top,
      hasControls: false, hasBorders: false,
      stroke: '#409eff', strokeWidth: 2,
      isPuzzleImage: true,
      isGhost: true
    });

    // 保持裁剪样式
    const cellCenterX = cell.left + cell.width / 2;
    const cellCenterY = cell.top + cell.height / 2;
    const offsetX = (cellCenterX - img.left) / img.scaleX;
    const offsetY = (cellCenterY - img.top) / img.scaleY;

    const clipRect = new fabric.Rect({
      left: offsetX, top: offsetY,
      width: cell.width / img.scaleX, height: cell.height / img.scaleY,
      originX: 'center', originY: 'center',
      absolutePositioned: false
    });
    dragProxy.clipPath = clipRect;

    canvas.add(dragProxy);
    canvas.bringToFront(dragProxy);
    isCreatingProxy = false;
  });
};

const onMouseUp = (opt) => {
  if (!puzzleState.isActive) return;
  const canvas = unref(canvasRef);
  const pointer = canvas.getPointer(opt.e);
  isDragging = false;
  isCreatingProxy = false;

  if (dragProxy) {
    // 处理交换逻辑
    const dropCell = getCellFromPoint(pointer.x, pointer.y);
    const originCellIndex = dragOriginCellIndex;
    canvas.remove(dragProxy);
    dragProxy = null;
    const originImg = canvas.getObjects().find(o => o.isPuzzleImage && o.cellIndex === originCellIndex);
    if (originImg) originImg.set('opacity', 1);

    if (dropCell && dropCell.index !== originCellIndex) {
      animateSwap(originCellIndex, dropCell.index);
    } else {
      // 没交换成功，弹回去
      animateSnapBack(originCellIndex);
    }
  } else if (dragOriginPoint) {
    // 处理点击或内部拖拽结束
    const dist = Math.sqrt(
      Math.pow(pointer.x - dragOriginPoint.x, 2) +
      Math.pow(pointer.y - dragOriginPoint.y, 2)
    );

    if (dist < 5) {
      // 点击事件
      const clickedCell = getCellFromPoint(pointer.x, pointer.y);
      if (clickedCell) {
        const target = opt.target;
        if (target && target.isDeleteBtn) return;

        const hasImg = canvas.getObjects().some(o => o.isPuzzleImage && o.cellIndex === clickedCell.index);

        if (!hasImg && uiCallbacks.onCellClick) {
          uiCallbacks.onCellClick(clickedCell.index);
          canvas.discardActiveObject();
        } else if (hasImg) {
          const controller = canvas.getObjects().find(o => o.isPuzzleController && o.cellIndex === clickedCell.index);
          if (controller) canvas.setActiveObject(controller);
        }
      }
    } else {
      // 内部拖拽结束，触发回弹
      if (dragOriginCellIndex !== -1) animateSnapBack(dragOriginCellIndex);
    }
  }
  dragOriginCellIndex = -1;
  dragOriginPoint = null;
  canvas.requestRenderAll();
};

// 【核心修改】替换原有的 animateSnapBack 实现
const animateSnapBack = (cellIndex) => {
  const canvas = unref(canvasRef);
  const cell = puzzleState.cells.find(c => c.index === cellIndex);
  const img = canvas.getObjects().find(o => o.isPuzzleImage && o.cellIndex === cellIndex);

  if (img && cell) {
    // 构造容器矩形 (Cell)
    // 注意：animateRebound 接受的是 {left, top, width, height} 对象
    const containerRect = {
      left: cell.left,
      top: cell.top,
      width: cell.width,
      height: cell.height
    };

    // 直接调用通用物理回弹引擎！
    // 这样拼图的回弹手感就和 Crop/Resize 完全一样了
    animateRebound(img, containerRect, canvas);
  }
};

const animateSwap = (idxA, idxB) => {
  const canvas = unref(canvasRef);
  const imgA = canvas.getObjects().find(o => o.isPuzzleImage && o.cellIndex === idxA);
  const imgB = canvas.getObjects().find(o => o.isPuzzleImage && o.cellIndex === idxB);
  const cellA = puzzleState.cells.find(c => c.index === idxA);
  const cellB = puzzleState.cells.find(c => c.index === idxB);
  const animations = [];
  const duration = 300;
  const easing = fabric.util.ease.easeOutQuart;

  const createSyncAnimation = (img, targetCell) => {
    if (!img || !targetCell) return;

    // 交换时，我们需要重新计算“Cover”状态下的最佳位置
    const targetImgState = calculateFitPosition(img, targetCell);

    animations.push(new Promise(resolve => {
      img.animate({
        left: targetImgState.left,
        top: targetImgState.top,
        scaleX: targetImgState.scaleX,
        scaleY: targetImgState.scaleY
      }, {
        duration, easing,
        onChange: canvas.requestRenderAll.bind(canvas),
        onComplete: resolve
      });
    }));

    if (img.clipPath) {
      animations.push(new Promise(resolve => {
        img.clipPath.animate({
          left: targetCell.left,
          top: targetCell.top,
          width: targetCell.width,
          height: targetCell.height,
          rx: puzzleState.radius,
          ry: puzzleState.radius
        }, {
          duration, easing,
          onComplete: resolve
        });
      }));
    }
  };

  createSyncAnimation(imgA, cellB);
  createSyncAnimation(imgB, cellA);

  Promise.all(animations).then(() => {
    if (imgA) imgA.cellIndex = idxB;
    if (imgB) imgB.cellIndex = idxA;
    const ctrlA = canvas.getObjects().find(o => o.isPuzzleController && o.cellIndex === idxA);
    const ctrlB = canvas.getObjects().find(o => o.isPuzzleController && o.cellIndex === idxB);
    if (ctrlA) ctrlA.cellIndex = idxB;
    if (ctrlB) ctrlB.cellIndex = idxA;
    refreshPuzzleObjects();
    if (saveHistoryFn) saveHistoryFn();
  });
};

const onMouseWheel = (opt) => {
  const canvas = unref(canvasRef);
  const target = canvas.getActiveObject();
  if (!target || !target.isPuzzleController) return;
  opt.e.preventDefault(); opt.e.stopPropagation();
  const cell = puzzleState.cells.find(c => c.index === target.cellIndex);
  const img = canvas.getObjects().find(o => o.isPuzzleImage && o.cellIndex === target.cellIndex);
  if (!cell || !img) return;

  // 缩放逻辑
  let zoom = img.scaleX;
  zoom *= 0.999 ** opt.e.deltaY;

  // 限制缩放范围
  const minScale = Math.max(cell.width / img.width, cell.height / img.height);
  const maxScale = minScale * 5;
  if (zoom < minScale) zoom = minScale;
  if (zoom > maxScale) zoom = maxScale;

  img.set({ scaleX: zoom, scaleY: zoom });

  // 【核心修改】使用通用硬约束，实时修正位置，防止缩放露出黑边
  const containerRect = {
    left: cell.left, top: cell.top, width: cell.width, height: cell.height
  };
  constrainObjectToRect(img, containerRect, canvas);

  canvas.requestRenderAll();
};

export const updateLayout = (cellDefinitions = null, config = {}) => {
  const canvas = unref(canvasRef);
  if (!canvas) return;
  if (config.padding !== undefined) puzzleState.padding = config.padding;
  if (config.spacing !== undefined) puzzleState.spacing = config.spacing;
  if (config.radius !== undefined) puzzleState.radius = config.radius;
  if (config.bgColor) {
    puzzleState.bgColor = config.bgColor;
    canvas.setBackgroundColor(config.bgColor, () => canvas.requestRenderAll());
  }
  const isTemplateChange = !!cellDefinitions;
  if (cellDefinitions) puzzleState.rawCells = cellDefinitions;
  const { width, height, padding, spacing, startX, startY } = puzzleState;
  const availW = width - (padding * 2);
  const availH = height - (padding * 2);

  puzzleState.cells = puzzleState.rawCells.map(cell => ({
    index: cell.index,
    left: startX + padding + cell.x * availW + spacing / 2,
    top: startY + padding + cell.y * availH + spacing / 2,
    width: cell.w * availW - spacing,
    height: cell.h * availH - spacing
  }));
  refreshPuzzleObjects(isTemplateChange);
  if (saveHistoryFn) saveHistoryFn();
};

// === 刷新对象 (防重叠 + 自动吸入) ===
const refreshPuzzleObjects = (shouldResetImages = false) => {
  const canvas = unref(canvasRef);
  const { radius } = puzzleState;

  const toRemove = canvas.getObjects().filter(o => o.isPlaceholder || o.isPuzzleController || o.isDeleteBtn);
  canvas.remove(...toRemove);

  const existingPuzzleImages = canvas.getObjects()
    .filter(o => o.isPuzzleImage && !o.isGhost && o !== dragProxy)
    .sort((a, b) => a.cellIndex - b.cellIndex);

  // 1. 自动吸入普通图片 (修复：不传 scale，强制重新计算 Cover)
  if (shouldResetImages && existingPuzzleImages.length === 0) {
    const rawImages = canvas.getObjects().filter(o => o.type === 'image' && !o.isPuzzleItem);
    if (rawImages.length > 0) {
      const rawImg = rawImages[0];
      const src = rawImg.getSrc();
      // 这里删除了 currentScale 的获取
      canvas.remove(rawImg);

      // 不传 targetScale，强制使用 addImageToCell 内部的自动居中逻辑
      addImageToCell(src, 0);

      puzzleState.cells.forEach(cell => drawPlaceholder(canvas, cell));
      canvas.requestRenderAll();
      return;
    }
  }

  puzzleState.cells.forEach((cell, index) => {
    let img = null;
    if (shouldResetImages) {
      if (index < existingPuzzleImages.length) {
        img = existingPuzzleImages[index];
        img.cellIndex = cell.index;
        img.set({ opacity: 1, visible: true });
        // 模板切换：强制居中
        const fitState = calculateFitPosition(img, cell);
        img.set({ scaleX: fitState.scaleX, scaleY: fitState.scaleY, left: fitState.left, top: fitState.top });
        img.setCoords();
      }
    } else {
      img = existingPuzzleImages.find(o => o.cellIndex === cell.index);
      if (img) {
        // 布局变动（如调整 Padding）：检查是否填满，不够则放大
        const minScale = Math.max(cell.width / img.width, cell.height / img.height);
        if (img.scaleX < minScale - 0.001) {
          img.set({ scaleX: minScale, scaleY: minScale });
        }
        // 硬约束防止跑偏
        const containerRect = { left: cell.left, top: cell.top, width: cell.width, height: cell.height };
        constrainObjectToRect(img, containerRect, canvas);
      }
    }

    if (img) {
      const clipRect = new fabric.Rect({
        left: cell.left, top: cell.top, width: cell.width, height: cell.height,
        rx: radius, ry: radius, absolutePositioned: true
      });
      img.set({ clipPath: clipRect, opacity: 1 });
      img.setCoords();

      const controller = new fabric.Rect({
        left: cell.left, top: cell.top, width: cell.width, height: cell.height,
        fill: 'transparent', noScaleCache: false,
        transparentCorners: false, cornerSize: 8, borderOpacityWhenMoving: 0.5,
        selectable: true, evented: true, hasControls: true, hasBorders: true,
        lockMovementX: true, lockMovementY: true,
        lockRotation: true, lockScalingX: true, lockScalingY: true,
        isPuzzleItem: true, isPuzzleController: true, cellIndex: cell.index
      });
      canvas.add(controller);
      drawDeleteBtn(canvas, cell);
    } else {
      drawPlaceholder(canvas, cell);
    }
  });

  if (shouldResetImages && existingPuzzleImages.length > puzzleState.cells.length) {
    const extras = existingPuzzleImages.slice(puzzleState.cells.length);
    canvas.remove(...extras);
  }
  canvas.requestRenderAll();
};

const deleteImageFromCell = (cellIndex) => {
  const canvas = unref(canvasRef);
  const objs = canvas.getObjects().filter(o =>
    (o.isPuzzleImage || o.isPuzzleController || o.isDeleteBtn) && o.cellIndex === cellIndex
  );
  canvas.remove(...objs);
  refreshPuzzleObjects();
  if (saveHistoryFn) saveHistoryFn();
};

const drawDeleteBtn = (canvas, cell) => {
  const btnRadius = 9;
  const padding = 6;

  const circle = new fabric.Circle({
    radius: btnRadius,
    fill: 'rgba(0, 0, 0, 0.6)',
    originX: 'center', originY: 'center'
  });

  const text = new fabric.Text('×', {
    fill: '#fff',
    fontSize: 18,
    fontFamily: 'Arial',
    originX: 'center', originY: 'center',
    top: -1
  });

  const group = new fabric.Group([circle, text], {
    left: cell.left + cell.width - btnRadius - padding,
    top: cell.top + btnRadius + padding,
    originX: 'center', originY: 'center',
    selectable: false,
    hoverCursor: 'pointer',
    isPuzzleItem: true,
    isDeleteBtn: true,
    cellIndex: cell.index
  });

  canvas.add(group);
  canvas.bringToFront(group);
};

const drawPlaceholder = (canvas, cell) => {
  const rect = new fabric.Rect({
    left: cell.left, top: cell.top, width: cell.width, height: cell.height,
    fill: '#f5f7fa', stroke: '#dcdfe6', strokeWidth: 1, strokeDashArray: [4, 4],
    rx: puzzleState.radius, ry: puzzleState.radius,
    selectable: false, evented: false, isPuzzleItem: true, isPlaceholder: true
  });
  const plus = new fabric.Text('+', {
    left: cell.left + cell.width / 2, top: cell.top + cell.height / 2,
    fontSize: 30, fill: '#909399', originX: 'center', originY: 'center',
    selectable: false, evented: false, isPuzzleItem: true, isPlaceholder: true
  });
  canvas.add(rect, plus);
  canvas.sendToBack(rect);
};

const getCellFromPoint = (x, y) => {
  return puzzleState.cells.find(cell =>
    x >= cell.left && x <= cell.left + cell.width &&
    y >= cell.top && y <= cell.top + cell.height
  );
};

// === 添加图片的终极修复 (强制居中) ===
export const addImageToCell = (url, cellIndex, options = {}) => {
  const canvas = unref(canvasRef);
  const oldObjs = canvas.getObjects().filter(o => (o.isPuzzleImage || o.isPuzzleController || o.isDeleteBtn) && o.cellIndex === cellIndex);
  canvas.remove(...oldObjs);

  fabric.Image.fromURL(url, (img) => {
    const cell = puzzleState.cells.find(c => c.index === cellIndex);
    if (!cell) return;

    let scale;
    // 逻辑：如果有 targetScale 就用，没有就自动 Cover
    if (options.targetScale) {
      scale = options.targetScale;
    } else {
      scale = Math.max(cell.width / img.width, cell.height / img.height) + 0.001;
    }

    // 【关键】设置居中
    img.set({
      // 1. 设置中心点坐标
      left: cell.left + cell.width / 2,
      top: cell.top + cell.height / 2,
      // 2. 设置 origin 为中心
      originX: 'center',
      originY: 'center',
      scaleX: scale,
      scaleY: scale,
      selectable: false, evented: false, hasControls: false, hasBorders: false,
      isPuzzleItem: true, isPuzzleImage: true, cellIndex: cellIndex,
    });

    // 3. 立即更新坐标，防止后续计算出错
    img.setCoords();

    const controller = new fabric.Rect({
      left: cell.left, top: cell.top, width: cell.width, height: cell.height,
      fill: 'transparent', noScaleCache: false,
      transparentCorners: false, cornerSize: 8, borderOpacityWhenMoving: 0.5,
      selectable: true, evented: true, hasControls: true, hasBorders: true,
      lockMovementX: true, lockMovementY: true,
      lockRotation: true, lockScalingX: true, lockScalingY: true,
      isPuzzleItem: true, isPuzzleController: true, cellIndex: cellIndex,
    });

    canvas.add(img);
    canvas.add(controller);
    canvas.setActiveObject(controller);

    refreshPuzzleObjects(); // 这里会再次触发 constrain check，但因为已经居中且足够大，不会有副作用
    if (saveHistoryFn) saveHistoryFn();
  }, { crossOrigin: 'anonymous' });
};
</file>

<file path="package.json">
{
  "name": "image-editor-sdk",
  "version": "1.0.0",
  "type": "module",
  "types": "./dist/index.d.ts",
  "main": "./dist/image-editor.umd.cjs",
  "module": "./dist/image-editor.js",
  "files": ["dist"],
  "exports": {
    ".": {
      "import": "./dist/image-editor.js",
      "require": "./dist/image-editor.umd.cjs"
    },
    "./style.css": "./dist/index.css"
  },
  "scripts": {
    "dev": "vite --host 0.0.0.0",
    "build": "vite build",
    "preview": "vite preview",
    "npx": "npx repomix"
  },
  "dependencies": {
    "fabric": "^5.3.0",
    "file-saver": "^2.0.5"
  },
  "peerDependencies": {
    "vue": "^3.3.0"
  },
  "devDependencies": {
    "@vitejs/plugin-vue": "^6.0.1",
    "vite": "^7.2.4",
    "vite-plugin-dts": "^4.5.4"
  }
}
</file>

<file path="src/components/modules/adjust/index.vue">
<template>
  <div class="panel-adjust">
    <div class="tool-list">

      <AdjustCrop :is-expanded="activeCollapse === 'crop'" @toggle="toggle('crop')" />

      <AdjustResize :is-expanded="activeCollapse === 'resize'" @toggle="toggle('resize')" />

      <AdjustInpaint :is-expanded="activeCollapse === 'inpaint'" @toggle="toggle('inpaint')" />

      <AdjustRembg :is-expanded="activeCollapse === 'rembg'" @toggle="toggle('rembg')" />

      <AdjustRuler :is-expanded="activeCollapse === 'ruler'" @toggle="toggle('ruler')" />

      <AdjustWhite :is-expanded="activeCollapse === 'white'" @toggle="toggle('white')" />

      <AdjustColor :is-expanded="activeCollapse === 'color'" @toggle="toggle('color')" />

      <AdjustColorOverlay :is-expanded="activeCollapse === 'overlay'" @toggle="toggle('overlay')" />

      <AdjustFilters :is-expanded="activeCollapse === 'filters'" @toggle="toggle('filters')" />

      <AdjustMosaic :is-expanded="activeCollapse === 'mosaic'" @toggle="toggle('mosaic')" />

    </div>
  </div>
</template>

<script setup>
import { ref, defineAsyncComponent, watch } from 'vue';
import { toast } from '@/utils/toast';
import { useEditorState } from '@/composables/useEditorState'; // 假设与当前文件同级，如果在 composables 请修改路径

// 异步组件引入
const AdjustCrop = defineAsyncComponent(() => import('./AdjustCrop.vue'));
const AdjustResize = defineAsyncComponent(() => import('./AdjustResize.vue'));
const AdjustInpaint = defineAsyncComponent(() => import('./AdjustInpaint.vue'));
const AdjustRembg = defineAsyncComponent(() => import('./AdjustRembg.vue'));
const AdjustWhite = defineAsyncComponent(() => import('./AdjustWhite.vue'));
const AdjustColor = defineAsyncComponent(() => import('./AdjustColor.vue'));
const AdjustFilters = defineAsyncComponent(() => import('./AdjustFilters.vue'));
const AdjustColorOverlay = defineAsyncComponent(() => import('./AdjustColorOverlay.vue'));
const AdjustMosaic = defineAsyncComponent(() => import('./AdjustMosaic.vue'));
const AdjustRuler = defineAsyncComponent(() => import('./AdjustRuler.vue'));

const activeCollapse = ref('');
// ✨ 获取全局状态
const { state } = useEditorState();

// ✨✨✨ 核心链路修复：监听路由变化 ✨✨✨
// 当 state.activeTab 变为 'ruler' 时，自动展开 'ruler' 面板
watch(
  () => state.activeTab,
  (newTab) => {
    // 这里做一个简单的白名单匹配，防止非 Adjust 面板的 Tab 干扰
    // 这里的 'ruler' 对应 template 中 toggle('ruler') 的 id
    const validTabs = ['crop', 'resize', 'inpaint', 'rembg', 'ruler', 'white', 'color', 'overlay', 'filters', 'mosaic'];
    
    if (newTab && validTabs.includes(newTab)) {
      console.log('[AdjustPanel] Auto expanding:', newTab);
      activeCollapse.value = newTab;
    }
  },
  { immediate: true }
);
const toggle = (id) => {
  activeCollapse.value = activeCollapse.value === id ? '' : id;
};

const notImplemented = () => {
  toast.info('功能开发中');
};
</script>

<style scoped>
.panel-adjust {
  padding: 16px;
  height: 100%;
  overflow-y: auto;
  background-color: #fff;
  box-sizing: border-box;
}
</style>
</file>

<file path="src/components/modules/adjust/useCanvasResize.js">
// src/components/modules/adjust/useCanvasResize.js
import { ref, unref, shallowRef, toRaw } from "vue";
import { fabric } from "fabric";

// 1. 引入通用物理约束与离屏渲染工具
import { constrainObjectToRect, animateRebound } from '@/composables/useConstraint';
import { renderHighResSnapshot } from '@/composables/useOffscreenHelper';

let canvasRef = null;
let saveHistoryFn = null;

const previewRect = shallowRef(null);
let isDraggingImage = false;
let dragLastX = 0;
let dragLastY = 0;

let originalSelectable = true;
let originalEvented = true;
let originalTransform = null;

export const registerResizeModule = (canvas, saveHistory) => {
  canvasRef = canvas;
  saveHistoryFn = saveHistory;
};

export const getCurrentSize = () => {
  const canvas = unref(canvasRef);
  if (!canvas) return { width: 0, height: 0 };
  const bgImage = canvas.getObjects().find(o => o.type === 'image');
  if (bgImage) {
    return {
      width: Math.round(bgImage.getScaledWidth()),
      height: Math.round(bgImage.getScaledHeight())
    };
  }
  return { width: canvas.width, height: canvas.height };
};

// --- 交互事件处理 ---

const onPreviewMouseDown = (opt) => {
  if (!canvasRef?.value || !previewRect.value) return;
  // 拉伸模式下禁止拖拽
  if (previewRect.value.data?.isStretch) return;

  const canvas = canvasRef.value;
  const bgImage = canvas.getObjects().find(o => o.type === 'image');
  if (!bgImage) return;

  isDraggingImage = true;
  const pointer = canvas.getPointer(opt.e);
  dragLastX = pointer.x;
  dragLastY = pointer.y;
  canvas.defaultCursor = 'move';
};

const onPreviewMouseMove = (opt) => {
  if (!isDraggingImage || !canvasRef?.value) return;
  const canvas = canvasRef.value;
  const pointer = canvas.getPointer(opt.e);
  const deltaX = pointer.x - dragLastX;
  const deltaY = pointer.y - dragLastY;

  const bgImage = canvas.getObjects().find(o => o.type === 'image');
  if (bgImage) {
    // 自由拖拽，暂不约束，依靠 mouseUp 时的回弹
    bgImage.left += deltaX;
    bgImage.top += deltaY;
    bgImage.setCoords();
  }
  dragLastX = pointer.x;
  dragLastY = pointer.y;
  canvas.requestRenderAll();
};

const onPreviewMouseUp = () => {
  if (isDraggingImage) {
    if (canvasRef?.value && previewRect.value) {
      const bgImage = canvasRef.value.getObjects().find(o => o.type === 'image');
      if (bgImage) {
        // 【核心升级】使用带动画的弹性回弹
        animateRebound(bgImage, previewRect.value, canvasRef.value);
      }
    }
    isDraggingImage = false;
    if (canvasRef?.value) canvasRef.value.defaultCursor = 'default';
  }
};

// --- 辅助函数 ---

const restoreImageState = (bgImage) => {
  if (originalTransform && bgImage) {
    bgImage.set({
      scaleX: originalTransform.scaleX,
      scaleY: originalTransform.scaleY,
      left: originalTransform.left,
      top: originalTransform.top,
      width: originalTransform.width,
      height: originalTransform.height,
      angle: originalTransform.angle,
      originX: originalTransform.originX,
      originY: originalTransform.originY
    });
    bgImage.setCoords();
  }
};

// --- 预览逻辑 ---

export const startPreview = (targetW, targetH, isStretch = false) => {
  const canvas = unref(canvasRef);
  if (!canvas || !targetW || !targetH) return;

  const bgImage = canvas.getObjects().find(o => o.type === 'image');
  if (!bgImage) return;

  const currentImgCenter = bgImage.getCenterPoint();

  // 第一次进入时备份状态
  if (!originalTransform) {
    originalSelectable = bgImage.selectable;
    originalEvented = bgImage.evented;
    originalTransform = {
      scaleX: bgImage.scaleX,
      scaleY: bgImage.scaleY,
      left: bgImage.left,
      top: bgImage.top,
      width: bgImage.width,
      height: bgImage.height,
      angle: bgImage.angle,
      originX: bgImage.originX,
      originY: bgImage.originY,
      centerX: currentImgCenter.x,
      centerY: currentImgCenter.y
    };
  }

  // 清除旧的预览框
  if (previewRect.value) {
    canvas.remove(toRaw(previewRect.value));
    previewRect.value = null;
  }

  const targetCenter = { x: originalTransform.centerX, y: originalTransform.centerY };

  if (!isStretch) {
    restoreImageState(bgImage);
  } else {
    // 拉伸模式下禁用图片交互
    bgImage.selectable = false;
    bgImage.evented = false;
  }

  // 计算预览框尺寸（保持宽高比）
  const imgW = originalTransform.width * originalTransform.scaleX;
  const imgH = originalTransform.height * originalTransform.scaleY;
  const targetRatio = targetW / targetH;
  const imgRatio = imgW / imgH;

  let previewW, previewH;
  // 逻辑：预览框是“选区”，通常最大不超过图片原尺寸，或者根据比例适配
  if (targetRatio > imgRatio) {
    previewW = imgW;
    previewH = imgW / targetRatio;
  } else {
    previewH = imgH;
    previewW = imgH * targetRatio;
  }

  // 创建预览框
  const rect = new fabric.Rect({
    width: previewW,
    height: previewH,
    left: targetCenter.x,
    top: targetCenter.y,
    originX: 'center',
    originY: 'center',
    fill: 'transparent',
    stroke: '#409eff',
    strokeWidth: 2,
    strokeDashArray: [6, 6],
    selectable: false,
    evented: false,
    excludeFromExport: true,
    data: { isStretch }
  });

  previewRect.value = rect;
  canvas.add(rect);
  canvas.bringToFront(rect);

  if (!isStretch) {
    // 【核心升级】初始约束：确保图片不留白（使用通用硬约束）
    constrainObjectToRect(bgImage, rect, canvas);

    // 绑定拖拽事件
    canvas.on('mouse:down', onPreviewMouseDown);
    canvas.on('mouse:move', onPreviewMouseMove);
    canvas.on('mouse:up', onPreviewMouseUp);
  } else {
    // 拉伸模式：直接让图片填满预览框（视觉预览）
    bgImage.set({
      scaleX: previewW / originalTransform.width,
      scaleY: previewH / originalTransform.height,
      left: targetCenter.x,
      top: targetCenter.y,
      originX: 'center',
      originY: 'center'
    });
    // 解绑事件
    canvas.off('mouse:down', onPreviewMouseDown);
    canvas.off('mouse:move', onPreviewMouseMove);
    canvas.off('mouse:up', onPreviewMouseUp);
  }

  bgImage.setCoords();
  canvas.requestRenderAll();
};

export const updatePreview = (targetW, targetH, isStretch = false) => {
  startPreview(targetW, targetH, isStretch);
};

export const stopPreview = () => {
  const canvas = unref(canvasRef);
  if (canvas) {
    canvas.off('mouse:down', onPreviewMouseDown);
    canvas.off('mouse:move', onPreviewMouseMove);
    canvas.off('mouse:up', onPreviewMouseUp);

    if (previewRect.value) {
      canvas.remove(toRaw(previewRect.value));
      previewRect.value = null;
    }

    const bgImage = canvas.getObjects().find(o => o.type === 'image');
    if (bgImage) {
      restoreImageState(bgImage);
      bgImage.selectable = originalSelectable;
      bgImage.evented = originalEvented;
    }

    canvas.discardActiveObject();
    originalTransform = null;
    canvas.requestRenderAll();
  }
};

// --- 核心应用逻辑 (高清重制) ---

export const applyResize = async (width, height, isStretch = false) => {
  const canvas = unref(canvasRef);
  if (!canvas || !previewRect.value) return;

  const targetW = Math.round(width);
  const targetH = Math.round(height);
  if (targetW <= 0 || targetH <= 0) return;

  const bgImage = canvas.getObjects().find(o => o.type === 'image');
  if (!bgImage) return;

  // 1. 锁定现场
  const rect = previewRect.value;
  const prevVpt = [...canvas.viewportTransform];
  const prevZoom = canvas.getZoom();

  const rectCenterLogic = rect.getCenterPoint();
  // 计算预览框中心在当前屏幕上的绝对位置
  const rectCenterScreen = {
    x: rectCenterLogic.x * prevVpt[0] + prevVpt[4],
    y: rectCenterLogic.y * prevVpt[3] + prevVpt[5]
  };

  const finalPos = {
    logicalW: rect.width * rect.scaleX,
    logicalH: rect.height * rect.scaleY
  };

  originalTransform = null;

  // 2. 【核心升级】使用通用离屏工具生成高清图
  const dataURL = await renderHighResSnapshot(bgImage, targetW, targetH, (highResImg, tempCanvas) => {
    const multiplier = targetW / finalPos.logicalW;

    if (isStretch) {
      // 拉伸模式
      highResImg.set({
        originX: 'center', originY: 'center',
        left: targetW / 2, top: targetH / 2,
        scaleX: targetW / highResImg.width,
        scaleY: targetH / highResImg.height
      });
    } else {
      // 保持相对位置模式
      const imgCenter = bgImage.getCenterPoint();
      const relCenterX = imgCenter.x - rectCenterLogic.x;
      const relCenterY = imgCenter.y - rectCenterLogic.y;

      highResImg.set({
        originX: 'center', originY: 'center',
        left: (targetW / 2) + (relCenterX * multiplier),
        top: (targetH / 2) + (relCenterY * multiplier),
        scaleX: bgImage.scaleX * multiplier,
        scaleY: bgImage.scaleY * multiplier,
        angle: bgImage.angle,
        flipX: bgImage.flipX,
        flipY: bgImage.flipY
      });
    }
  });

  // 3. 应用回主画布并修正视口
  bgImage.setSrc(dataURL, () => {
    // 计算视口缩放补偿
    const multiplier = targetW / finalPos.logicalW;
    const newZoom = prevZoom / multiplier;

    // 物理重置图片到画布中心
    bgImage.set({
      originX: "center", originY: "center",
      angle: 0, flipX: false, flipY: false,
      scaleX: 1, scaleY: 1,
      left: canvas.width / 2,
      top: canvas.height / 2,
    });

    bgImage.setCoords();
    canvas.centerObject(bgImage);

    // 视口补偿：对齐视觉中心
    const newCenterLogic = { x: canvas.width / 2, y: canvas.height / 2 };
    const newPanX = rectCenterScreen.x - newCenterLogic.x * newZoom;
    const newPanY = rectCenterScreen.y - newCenterLogic.y * newZoom;

    canvas.setViewportTransform([newZoom, 0, 0, newZoom, newPanX, newPanY]);

    stopPreview();
    canvas.requestRenderAll();
    canvas.fire('zoom:change', { from: 'resize-apply' });

    if (saveHistoryFn) saveHistoryFn();
  });
};
</file>

<file path="src/components/modules/puzzle/index.vue">
<template>
  <div class="puzzle-module">
    <!-- sub page count: 3 -->
    <!-- 1. 初始, 网格/拼接 选择页 (包含选择模板后的配置面板) -->
    <!-- 2. 模板选择页 -->
    <!-- 3. 点击 Canvas 图片的配置页 (替换/删除 透明度 缩放) 点击空白处 back to sub 1 -->

    <!-- 初始页 -->
    <div
      v-if="sub === 1"
      class="puzzle-main"
    >
      <!-- 选项卡 -->
      <div class="puzzle-tabs">
        <div
          class="tab-item"
          :class="{ active: activeTab === 'grid' }"
          @click="activeTab = 'grid'"
        >
          网格
        </div>
        <div
          class="tab-item"
          :class="{ active: activeTab === 'join' }"
          @click="activeTab = 'join'"
        >
          拼接
        </div>
      </div>

      <!-- 操作内容 -->
      <div>
        <!-- 网格选项卡内容 -->
        <div v-if="activeTab === 'grid'">
          <button
            class="select-btn"
            @click="sub = 2"
          >
            <div class="icon-wrap">
              <div
                v-if="showControlPanel"
                :style="curTemp.wrapStyle"
                class="small-grid-template"
              >
                <div
                  v-for="(gridArea, i) in curTemp.gridAreas"
                  :key="i"
                  class="grid-cell"
                  :style="`grid-area: ${gridArea};`"
                ></div>
              </div>
              <span
                v-else
                class="plus-icon"
              >+</span>
            </div>
            <span>选择网格</span>
            <span
              v-if="showControlPanel"
              class="cancel-btn"
              @click.stop="cancel"
            >取消</span>
          </button>

          <!-- 控制组件 -->
          <div
            v-if="showControlPanel"
            class="control-panel"
          >
            <!-- 拼图尺寸 -->
            <div class="control-group">
              <label>拼图尺寸</label>
              <div class="size-controls">
                <div class="input-wrapper">
                  <input
                    type="number"
                    v-model.number="puzzleSettings.width"
                    :min="min"
                    :max="max"
                    class="ie-input"
                    @change="updateSize('width')"
                  >
                  <span class="suffix">W</span>
                </div>

                <div
                  class="link-icon"
                  title="锁定宽高比"
                  @click="toggleRatioLock"
                >
                  <svg
                    v-if="puzzleSettings.lockRatio"
                    width="16"
                    height="16"
                    viewBox="0 0 24 24"
                    fill="none"
                    stroke="#409eff"
                    stroke-width="2"
                    stroke-linecap="round"
                    stroke-linejoin="round"
                  >
                    <path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71" />
                    <path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71" />
                  </svg>
                  <svg
                    v-else
                    width="16"
                    height="16"
                    viewBox="0 0 24 24"
                    fill="none"
                    stroke="#909399"
                    stroke-width="2"
                    stroke-linecap="round"
                    stroke-linejoin="round"
                    style="opacity: 0.6"
                  >
                    <path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71" />
                    <path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71" />
                    <line
                      x1="4"
                      y1="4"
                      x2="20"
                      y2="20"
                      stroke="#909399"
                    />
                  </svg>
                </div>

                <div class="input-wrapper">
                  <input
                    type="number"
                    v-model.number="puzzleSettings.height"
                    :min="min"
                    :max="max"
                    class="ie-input"
                    @change="updateSize('height')"
                  >
                  <span class="suffix">H</span>
                </div>
              </div>
            </div>

            <!-- 边框 -->
            <div class="control-group">
              <label>边框</label>
              <input
                v-model="puzzleSettings.border"
                type="range"
                min="0"
                max="100"
                step="1"
                @change="updateStyle"
              />
              <span class="value-display">{{ puzzleSettings.border }}px</span>
            </div>

            <!-- 间距 -->
            <div class="control-group">
              <label>间距</label>
              <input
                type="range"
                v-model="puzzleSettings.spacing"
                min="0"
                max="100"
                step="1"
                @change="updateStyle"
              />
              <span class="value-display">{{ puzzleSettings.spacing }}px</span>
            </div>

            <!-- 拼图背景 -->
            <div class="control-group">
              <label>拼图背景颜色</label>
              <input
                type="color"
                class="color"
                v-model="puzzleSettings.bgColor"
                @change="updateStyle"
              />
            </div>

            <!-- 保存按钮 -->
            <button
              class="save-btn"
              @click="save"
            >
              保存
            </button>
          </div>
        </div>

        <!-- 拼接选项卡内容 -->
        <div v-else>
          <button class="select-btn">
            <div class="icon-wrap">
              <div
                v-if="showControlPanel"
                :style="curTemp.wrapStyle"
                class="small-grid-template"
              >
                <div
                  v-for="(gridArea, i) in curTemp.gridAreas"
                  :key="i"
                  class="grid-cell"
                  :style="`grid-area: ${gridArea};`"
                ></div>
              </div>
              <span
                v-else
                class="plus-icon"
              >+</span>
            </div>
            <span>选择拼接</span>
            <span
              v-if="showControlPanel"
              class="cancel-btn"
              @click.stop="cancel"
            >取消</span>
          </button>
        </div>
      </div>
    </div>

    <!-- 模板选择面板 -->
    <div
      v-if="sub === 2"
      class="grid-templates"
    >
      <!-- 返回按钮 -->
      <div
        class="back-header"
        @click="backToMain"
      >
        <span class="back-icon">‹</span> 网格
      </div>

      <!-- 图片数量选择 -->
      <div class="image-count-selector">
        <label>图片数量</label>
        <select v-model="selectedImageCount">
          <option
            v-for="item in countOptions"
            :key="item.value"
            :value="item.value"
          >{{ item.label }}</option>
        </select>
      </div>

      <!-- 网格模板列表 -->
      <div class="grid-list">
        <div
          v-for="(group, count) in filteredTemplates"
          :key="count"
          class="grid-group"
        >
          <!-- 图片数量标题 -->
          <div class="grid-group-title">{{ count }}</div>

          <!-- 该数量下的所有模板 -->
          <div class="grid-templates-row">
            <div
              v-for="template in group"
              :key="template.id"
              :style="template.wrapStyle"
              class="grid-template"
              @click="selectTemplate(template)"
            >
              <div
                v-for="(gridArea, i) in template.gridAreas"
                :key="i"
                class="grid-cell"
                :style="`grid-area: ${gridArea};`"
              ></div>
            </div>
          </div>
        </div>
      </div>
    </div>

    <!-- 图片的配置页 -->
    <div
      v-if="sub === 3"
      class="p-20"
    >
      <div class="operate-tabs">
        <div class="tab-item border">
          替换图片
        </div>
        <div
          v-if="false"
          class="tab-item border"
        >
          删除图片
        </div>
      </div>

      <!-- 透明度 -->
      <div class="control-group">
        <label>透明度</label>
        <input
          v-model="transparent"
          type="range"
          min="0"
          max="100"
          step="1"
        />
        <span class="value-display">{{ transparent }}px</span>
      </div>

      <!-- 放大 -->
      <div class="control-group">
        <label>放大</label>
        <input
          type="range"
          v-model="zoom"
          min="100"
          max="300"
          step="1"
        />
        <span class="value-display">{{ zoom }}px</span>
      </div>
    </div>

    <!-- 隐藏的上传入口 -->
    <input
      type="file"
      ref="fileInput"
      accept="image/png, image/jpeg, image/jpg"
      style="display:none"
      @change="onFileSelected"
    >
  </div>
</template>

<script setup>
  import { ref, reactive, computed, inject, onMounted, onUnmounted } from 'vue';
  import { toast } from '@/utils/toast';
  import { gridTemplates, countOptions, generateGridCells, parseTemplateToCells } from './config.js';
  import {
    registerPuzzleModule,
    initPuzzleMode,
    exitPuzzleMode,
    updateLayout,
    addImageToCell,
  } from './useCanvasPuzzle.js';

  // 获取编辑器状态和Canvas API
  const canvasAPI = inject('canvasAPI');
  const fileInput = ref(null);
  let pendingCellIndex = -1;

  onMounted(() => {
    if (canvasAPI) {
      registerPuzzleModule(canvasAPI.canvas, canvasAPI.saveHistory, {
        onCellClick: (index) => {
          pendingCellIndex = index;
          if (fileInput.value) {
            fileInput.value.value = '';
            fileInput.value.click();
          }
        }
      });
      initPuzzleMode();
    }
  });

  onUnmounted(() => {
    exitPuzzleMode();
  });

  const onFileSelected = (e) => {
    const file = e.target.files?.[0];
    if (!file) return;
    if (file.type !== 'image/jpeg' && file.type !== 'image/png') {
      toast.error('仅支持 JPG/PNG 图片格式');
      return;
    }
    if (pendingCellIndex >= 0) {
      const url = URL.createObjectURL(file);
      addImageToCell(url, pendingCellIndex);
      pendingCellIndex = -1;
    }
  };

  /**
   * sub page count: 3
   * 1. 初始, 网格/拼接 选择页 (包含选择模板后的配置面板)
   * 2. 模板选择页
   * 3. 点击 Canvas 图片的配置页 (替换/删除 透明度 缩放) 点击空白处 back to sub 1
   */
  const sub = ref(1);
  const showControlPanel = ref(false);

  // 状态管理
  const selectedImageCount = ref('all');
  const activeTab = ref('grid');

  // 过滤显示的网格模板
  const filteredTemplates = computed(() => {
    if (selectedImageCount.value === 'all') {
      return gridTemplates;
    } else {
      const curCount = parseInt(selectedImageCount.value);
      const result = {};
      for (const count in gridTemplates) {
        if (parseInt(count) === curCount) {
          result[count] = gridTemplates[count];
        }
      }
      return result;
    }
  });

  // 返回上一级
  const backToMain = () => {
    sub.value = 1;
    selectedImageCount.value = 'all';
  };

  // 选择网格模板
  const curTemp = ref({});
  const selectTemplate = (template) => {
    curTemp.value = template;
    showControlPanel.value = true;
    sub.value = 1;

    // 应用模板到工作区
    applyTemplate(template);
  };

  const applyTemplate = (templ) => {
    const cells = parseTemplateToCells(templ);
    updateLayout(cells);
  };

  const cancel = () => {
    showControlPanel.value = false;
    curTemp.value = {};
    // sub.value = 1; // 本来就在 1
  };

  // 配置面板数据
  const puzzleSettings = reactive({
    width: 1200,
    height: 1200,
    lockRatio: false,
    border: 15,
    spacing: 15,
    bgColor: '#ffffff'
  });
  const min = 400;
  const max = 3840;
  let ratio = 1;

  const toggleRatioLock = () => {
    puzzleSettings.lockRatio = !puzzleSettings.lockRatio;
    if (puzzleSettings.lockRatio) {
      ratio = puzzleSettings.width / puzzleSettings.height;
    }
  };

  // 更新尺寸
  const updateSize = (dimension) => {
    // 确保尺寸在有效范围内
    if (puzzleSettings[dimension] < min) {
      puzzleSettings[dimension] = min;
    } else if (puzzleSettings[dimension] > max) {
      puzzleSettings[dimension] = max;
    }

    // 如果锁定宽高比，同时更新另一个维度
    if (puzzleSettings.lockRatio) {
      if (dimension === 'width') {
        puzzleSettings.height = Math.round(puzzleSettings.width / ratio);
      } else {
        puzzleSettings.width = Math.round(puzzleSettings.height * ratio);
      }
    }

    updateStyle();
  };

  const updateStyle = () => {
    updateLayout(null, puzzleSettings);
  };

  // 保存拼图
  const save = () => { };

  // sub 3
  const transparent = ref(100);
  const zoom = ref(100);
</script>

<style scoped>
  .puzzle-module {
    width: 100%;
    height: 100%;
    background-color: #fff;
  }

  /* 主面板样式 */
  .puzzle-main {
    padding: 20px;
  }

  .puzzle-tabs {
    display: flex;
  }

  .tab-item {
    flex: 1;
    text-align: center;
    padding: 8px 16px;
    border-radius: 4px;
    cursor: pointer;
    font-size: 14px;
    color: #606266;
  }

  .tab-item.active {
    background-color: #409eff;
    color: #fff;
  }

  .select-btn {
    display: inline-flex;
    align-items: center;
    padding: 14px;
    border-radius: 4px;
    width: 100%;
    cursor: pointer;
    font-size: 14px;
    color: #606266;
    transition: all 0.3s;
  }

  .select-btn:hover {
    border-color: #409eff;
    color: #409eff;
  }

  .icon-wrap {
    width: 40px;
    height: 40px;
    border-radius: 4;
    background-color: #fff;
    font-size: 24px;
    line-height: 40px;
    text-align: center;
    margin-right: 16px;
  }

  .small-grid-template {
    height: 100%;
    display: grid;
    /* border-radius: 4px; */
    overflow: hidden;
  }

  .plus-icon {
    font-weight: bold;
  }

  .cancel-btn {
    color: #409eff;
    margin-left: 76px;
    cursor: pointer;
  }

  /* 网格模板选择面板样式 */
  .grid-templates {
    padding: 20px 12px 20px;
  }

  .back-header {
    display: flex;
    align-items: center;
    font-size: 16px;
    font-weight: 500;
    margin-bottom: 20px;
    cursor: pointer;
  }

  .back-icon {
    font-size: 20px;
    margin-right: 8px;
    color: #606266;
  }

  .image-count-selector {
    margin-bottom: 20px;
  }

  .image-count-selector label {
    display: block;
    margin-bottom: 8px;
    font-size: 14px;
    color: #606266;
  }

  .image-count-selector select {
    width: 100%;
    padding: 8px 12px;
    border: 1px solid #dcdfe6;
    border-radius: 4px;
    font-size: 14px;
  }

  .grid-list {
    display: flex;
    flex-direction: column;
    gap: 20px;
  }

  .grid-group {
    border-radius: 4px;
    overflow: hidden;
  }

  .grid-group-title {
    padding: 10px 15px;
    background-color: #f5f7fa;
    font-size: 14px;
    font-weight: 500;
    color: #606266;
  }

  .grid-templates-row {
    display: flex;
    flex-wrap: wrap;
    gap: 10px;
    padding: 12px 4px;
  }

  .grid-template {
    width: 120px;
    height: 120px;
    display: grid;
    border-radius: 4px;
    overflow: hidden;
    cursor: pointer;
    transition: all 0.3s;
  }

  .grid-template:hover {
    border-color: #409eff;
    box-shadow: 0 2px 12px 0 rgba(0, 0, 0, 0.1);
  }

  .grid-cell {
    height: 100%;
    background-color: #f0f0f0;
    border: 1px solid #fff;
  }

  /* 控制面板样式 */
  .control-panel {
    display: flex;
    flex-direction: column;
    gap: 20px;
    padding: 15px 0;
  }

  .control-group {
    display: flex;
    flex-direction: column;
    gap: 8px;
  }

  .control-group label {
    font-size: 14px;
    color: #606266;
    font-weight: 500;
  }

  .color {
    width: 100%;
    cursor: pointer;
    border: none;
  }

  /* 尺寸控制 */
  .size-controls {
    display: flex;
    align-items: center;
    gap: 10px;
  }

  .input-wrapper {
    position: relative;
    width: 38%;
  }

  .ie-input {
    text-align: center;
    padding-right: 20px;
    font-weight: 500;
    color: #333;
  }

  .suffix {
    position: absolute;
    right: 6px;
    top: 50%;
    transform: translateY(-50%);
    color: #c0c4cc;
    font-size: 12px;
    pointer-events: none;
  }

  .link-icon {
    width: 24px;
    display: flex;
    justify-content: center;
    cursor: pointer;
  }

  /* 滑块控制 */
  .control-group input[type="range"] {
    width: 100%;
    height: 4px;
    border-radius: 2px;
    background: #dcdfe6;
    outline: none;
    -webkit-appearance: none;
  }

  .control-group input[type="range"]::-webkit-slider-thumb {
    -webkit-appearance: none;
    appearance: none;
    width: 16px;
    height: 16px;
    border-radius: 50%;
    background: #409eff;
    cursor: pointer;
  }

  .control-group input[type="range"]::-moz-range-thumb {
    width: 16px;
    height: 16px;
    border-radius: 50%;
    background: #409eff;
    cursor: pointer;
    border: none;
  }

  .value-display {
    font-size: 14px;
    color: #909399;
    text-align: right;
  }

  /* 保存按钮 */
  .save-btn {
    padding: 12px 20px;
    margin-top: 20px;
    border: none;
    border-radius: 21px;
    background-color: #409eff;
    color: #fff;
    font-size: 14px;
    font-weight: 500;
    cursor: pointer;
    transition: all 0.3s;
  }

  .save-btn:hover {
    background-color: #66b1ff;
  }

  .p-20 {
    padding: 20px;
  }

  .operate-tabs {
    display: flex;
    margin-bottom: 16px;
  }

  .border {
    border: 1px solid #dcdfe6;
  }
</style>
</file>

<file path="src/components/layout/NavBar.vue">
<template>
  <div class="navbar">
    <div class="logo">
      <slot name="logo">{{ textMap.title }}</slot>
    </div>
    <div class="ie-actions">
      <input type="file" ref="fileInput" @change="onFileSelected" style="display:none" accept="image/*" />

      <button class="ie-btn" @click="handleUpload">
        <svg width="14" height="14" viewBox="0 0 1024 1024" style="margin-right:4px;fill:currentColor">
          <path
            d="M544 253.696V704h-64V247.296L237.248 490.048 192 444.8 512 128l320 316.8-45.248 45.248L544 253.696zM160 832h704a32 32 0 1 1 0 64H160a32 32 0 1 1 0-64z" />
        </svg>
        {{ textMap.upload }}
      </button>

      <span class="ie-divider"></span>

      <button 
        class="ie-btn ie-btn-icon" 
        style="margin-right:8px; padding: 0 8px;" 
        title="撤销" 
        @click="handleUndo" 
        :disabled="!state.canUndo"
      >
        <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
          <path d="M9 14 4 9l5-5"/>
          <path d="M4 9h10.5a5.5 5.5 0 0 1 5.5 5.5v0a5.5 5.5 0 0 1-5.5 5.5H11"/>
        </svg>
      </button>
      
      <button 
        class="ie-btn ie-btn-icon" 
        style="margin-right:8px; padding: 0 8px;" 
        title="重做" 
        @click="handleRedo" 
        :disabled="!state.canRedo"
      >
        <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
          <path d="M15 14l5-5-5-5"/>
          <path d="M20 9H9.5A5.5 5.5 0 0 0 4 14.5v0A5.5 5.5 0 0 0 9.5 20H13"/>
        </svg>
      </button>
      <button class="ie-btn" style="margin-right:8px;" @click="handleReset">还原</button>
      <button class="ie-btn ie-primary" @click="handleSave">{{ textMap.save }}</button>
    </div>
  </div>
</template>

<script setup>
import { inject, ref } from 'vue';
import { useEditorState } from '@/composables/useEditorState'; 
import { toast } from '@/utils/toast'; 
 

const { state } = useEditorState();

const canvasAPI = inject('canvasAPI');
const fileInput = ref(null);

const props = defineProps({
  textMap: {
    type: Object,
    default: () => ({}),
  },
});

const handleUpload = () => {
  fileInput.value.click();
};

const onFileSelected = (e) => {
  const file = e.target.files?.[0];
  if (file) {
    // 检查 inject 的 API 是否存在
    if (!canvasAPI || !canvasAPI.initImage) { 
      toast.error('画布尚未初始化');
      return;
    }
    const url = URL.createObjectURL(file);
    
    // 调用 canvasAPI 中的方法
    canvasAPI.initImage(url); 
    
    e.target.value = '';
  }
};

const handleSave = () => {
  if (canvasAPI && canvasAPI.save) {
    canvasAPI.save(); 
  } else {
    toast.error('导出功能未实现');
  }
};

const handleUndo = () => {
  // 调用 canvasAPI 中的方法
  if (canvasAPI && canvasAPI.undo) {
    canvasAPI.undo();
  }
};

const handleRedo = () => {
  // 调用 canvasAPI 中的方法
  if (canvasAPI && canvasAPI.redo) {
    canvasAPI.redo();
  }
};

const handleReset = () => {
  // 调用 canvasAPI 中的方法
  if (canvasAPI && canvasAPI.reset) {
    canvasAPI.reset();
  }
};
</script>

<style scoped>
.navbar {
  background: #fff;
  border-bottom: 1px solid #e4e7ed;
  display: flex;
  align-items: center;
  justify-content: space-between;
  padding: 0 20px;
}

.logo {
  font-weight: bold;
  font-size: 16px;
  color: #333;
}
</style>
</file>

<file path="src/components/modules/adjust/AdjustCrop.vue">
<template>
  <div class="tool-group">
    <div class="tool-item" :class="{ 'is-expanded': isExpanded }" @click="handleToggle">
      <div class="left">
        <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"
          stroke-linecap="round" stroke-linejoin="round" style="margin-right: 8px;">
          <path d="M6 2v14a2 2 0 0 0 2 2h14" />
          <path d="M18 22V8a2 2 0 0 0-2-2H2" />
        </svg>
        <span>裁剪/旋转</span>
      </div>
      <div class="right-icon">
        <svg class="arrow" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"
          stroke-linecap="round" stroke-linejoin="round">
          <path d="m9 18 6-6-6-6" />
        </svg>
      </div>
    </div>

    <div v-if="isExpanded" class="tool-content">

      <div class="ratio-grid">
        <div class="ratio-item" @click="handleSetRatio(null, true)">
          <div class="icon-box">
            <svg width="16" height="16" viewBox="0 0 24 24" style="fill: currentColor">
              <path
                d="M12 5V1L7 6l5 5V7c3.31 0 6 2.69 6 6s-2.69 6-6 6-6-2.69-6-6H4c0 4.42 3.58 8 8 8s8-3.58 8-8-3.58-8-8-8z" />
            </svg>
          </div>
          <span>初始化</span>
        </div>

        <div class="ratio-item" :class="{ active: currentRatio === 'original' }" @click="handleSetRatio('original')">
          <div class="shape-rect" style="width: 14px; height: 14px; border:1px solid #666"></div>
          <span>原比例</span>
        </div>

        <div class="ratio-item" :class="{ active: currentRatio === 'free' }" @click="handleSetRatio(null)">
          <div class="shape-rect dashed"></div>
          <span>自由比例</span>
        </div>

        <div class="ratio-item" :class="{ active: isManualActive }" @click="handleManualSelect">
          <div class="icon-box">
            <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5">
              <path stroke-dasharray="4 4" d="M4 4h16v16H4z" />
              <path fill="currentColor" stroke="none" d="M14 14l3.5 8 1.5-3.5 3.5-1.5-8-3.5z" />
            </svg>
          </div>
          <span>手动选区</span>
        </div>

        <div class="ratio-item" :class="{ active: isRatioMatch(1) }" @click="handleSetRatio(1)">
          <div class="shape-rect square"></div>
          <span>1:1</span>
        </div>

        <div class="ratio-item" :class="{ active: isRatioMatch(3 / 2) }" @click="handleSetRatio(3 / 2)">
          <div class="shape-rect" style="width: 12px; height: 8px;"></div>
          <span>3:2</span>
        </div>

        <div class="ratio-item" :class="{ active: isRatioMatch(2 / 3) }" @click="handleSetRatio(2 / 3)">
          <div class="shape-rect" style="width: 8px; height: 12px;"></div>
          <span>2:3</span>
        </div>

        <div class="ratio-item" :class="{ active: isRatioMatch(4 / 3) }" @click="handleSetRatio(4 / 3)">
          <div class="shape-rect" style="width: 16px; height: 12px;"></div>
          <span>4:3</span>
        </div>

        <div class="ratio-item" :class="{ active: isRatioMatch(3 / 4) }" @click="handleSetRatio(3 / 4)">
          <div class="shape-rect" style="width: 12px; height: 16px;"></div>
          <span>3:4</span>
        </div>

        <div class="ratio-item" :class="{ active: isRatioMatch(16 / 9) }" @click="handleSetRatio(16 / 9)">
          <div class="shape-rect" style="width: 16px; height: 9px;"></div>
          <span>16:9</span>
        </div>

        <div class="ratio-item" :class="{ active: isRatioMatch(9 / 16) }" @click="handleSetRatio(9 / 16)">
          <div class="shape-rect" style="width: 9px; height: 16px;"></div>
          <span>9:16</span>
        </div>
      </div>

      <div class="custom-input-box">
        <div class="input-header">
          <span>自定义</span>
          <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="#666" stroke-width="2"
            stroke-linecap="round" stroke-linejoin="round" style="cursor: pointer">
            <circle cx="12" cy="12" r="3"></circle>
            <path
              d="M19.4 15a1.65 1.65 0 0 0 .33 1.82l.06.06a2 2 0 0 1 0 2.83 2 2 0 0 1-2.83 0l-.06-.06a1.65 1.65 0 0 0-1.82-.33 1.65 1.65 0 0 0-1 1.51V21a2 2 0 0 1-2 2 2 2 0 0 1-2-2v-.09A1.65 1.65 0 0 0 9 19.4a1.65 1.65 0 0 0-1.82.33l-.06.06a2 2 0 0 1-2.83 0 2 2 0 0 1 0-2.83l.06-.06a1.65 1.65 0 0 0 .33-1.82 1.65 1.65 0 0 0-1.51-1H3a2 2 0 0 1-2-2 2 2 0 0 1 2-2h.09A1.65 1.65 0 0 0 4.6 9a1.65 1.65 0 0 0-.33-1.82l-.06-.06a2 2 0 0 1 0-2.83 2 2 0 0 1 2.83 0l.06.06a1.65 1.65 0 0 0 1.82.33H9a1.65 1.65 0 0 0 1-1.51V3a2 2 0 0 1 2-2 2 2 0 0 1 2 2v.09a1.65 1.65 0 0 0 1 1.51 1.65 1.65 0 0 0 1.82-.33l.06-.06a2 2 0 0 1 2.83 0 2 2 0 0 1 0 2.83l-.06.06a1.65 1.65 0 0 0-.33 1.82V9a1.65 1.65 0 0 0 1.51 1H21a2 2 0 0 1 2 2 2 2 0 0 1-2 2h-.09a1.65 1.65 0 0 0-1.51 1z">
            </path>
          </svg>
        </div>

        <div class="input-controls">
          <div class="input-wrapper">
            <input type="number" v-model.number="cropW" class="ie-input" @change="onWidthChange">
            <span class="suffix">W</span>
          </div>

          <div class="link-icon" @click="toggleRatioLock">
            <svg v-if="isRatioLocked" width="16" height="16" viewBox="0 0 24 24" fill="none"
              stroke="var(--ie-primary-color)" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
              <path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71" />
              <path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71" />
            </svg>
            <svg v-else width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="#909399" stroke-width="2"
              stroke-linecap="round" stroke-linejoin="round" style="opacity: 0.6">
              <path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71" />
              <path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71" />
              <line x1="4" y1="4" x2="20" y2="20" stroke="#909399" />
            </svg>
          </div>

          <div class="input-wrapper">
            <input type="number" v-model.number="cropH" class="ie-input" @change="onHeightChange">
            <span class="suffix">H</span>
          </div>
        </div>
      </div>

      <div class="rotate-actions">
        <div class="action-btn" title="向左旋转90°" @click="rotate(-90)">
          <svg width="20" height="20" viewBox="-1 -1 26 26" fill="none" stroke="currentColor" stroke-width="2"
            stroke-linecap="round" stroke-linejoin="round">
            <path d="M3 12a9 9 0 1 0 9-9 9.75 9.75 0 0 0-6.74 2.74L3 8" />
            <path d="M3 3v5h5" />
          </svg>
        </div>
        <div class="action-btn" title="向右旋转90°" @click="rotate(90)">
          <svg width="20" height="20" viewBox="-1 -1 26 26" fill="none" stroke="currentColor" stroke-width="2"
            stroke-linecap="round" stroke-linejoin="round">
            <path d="M21 12a9 9 0 1 1-9-9 9.75 9.75 0 0 1 6.74 2.74L21 8" />
            <path d="M21 3v5h-5" />
          </svg>
        </div>
        <div class="divider"></div>
        <div class="action-btn" title="水平翻转" @click="flip('X')">
          <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"
            stroke-linecap="round" stroke-linejoin="round">
            <path d="M12 5v14" />
            <path d="M8 9l-3 3 3 3" />
            <path d="M16 9l3 3-3 3" />
          </svg>
        </div>
        <div class="action-btn" title="垂直翻转" @click="flip('Y')">
          <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"
            stroke-linecap="round" stroke-linejoin="round">
            <path d="M5 12h14" />
            <path d="M9 8l3-3 3 3" />
            <path d="M9 16l3 3 3-3" />
          </svg>
        </div>
      </div>

      <div class="confirm-row">
        <button class="ie-btn ie-primary full-btn" @click="handleApply">应用</button>
        <button class="ie-btn full-btn" @click="handleCancel">取消</button>
      </div>
    </div>
  </div>
</template>

<script setup>
import { ref, watch, onMounted, onUnmounted, computed, nextTick } from 'vue';
import { fabric } from 'fabric';

import {
  startCrop,
  confirmCrop,
  setCropRatio,
  currentSelectionDims,
  isRatioLocked,
  currentAspectRatio, // 确保引入了此变量
  setCropBoxSize,
  rotateActive,
  flipActive,
  startManualSelection,
  isManualCropping,
  cropObject,
  openCropPanel,
  closeCropPanel,
} from './useCanvasCrop';

const props = defineProps({
  isExpanded: {
    type: Boolean,
    default: false
  }
});
const emit = defineEmits(['toggle']);

const currentRatio = ref('free');
const cropW = ref(0);
const cropH = ref(0);

// 监听来自逻辑层的尺寸变化
watch(currentSelectionDims, (newVal) => {
  if (newVal && (newVal.width !== 0 || newVal.height !== 0)) {
    cropW.value = newVal.width;
    cropH.value = newVal.height;
  }
});

watch(() => props.isExpanded, (val) => {
  if (val) {
    nextTick(() => {
      startCrop(null);
      updateInputFromCanvas();
    });
  } else {
    closeCropPanel();
  }
});

const handleToggle = () => {
  emit('toggle');
};

const handleCancel = () => {
  emit('toggle');
};

const handleApply = () => {
  confirmCrop();
  emit('toggle');
};

const isRatioMatch = (r) => {
  if (currentRatio.value === 'original') return false;
  if (!currentAspectRatio.value) return false;
  return Math.abs(currentAspectRatio.value - r) < 0.01;
};

const handleSetRatio = (ratio, isReset = false) => {
  if (isReset) {
    currentRatio.value = 'free';
    startCrop(null);
  } else if (ratio === 'original') {
    currentRatio.value = 'original';
    const activeObj = cropObject.value?.canvas?.getObjects().find(o => o.type === 'image');
    if (activeObj) {
      setCropRatio(activeObj.width / activeObj.height);
    }
  } else if (ratio === null) {
    currentRatio.value = 'free';
    setCropRatio(null);
  } else {
    currentRatio.value = ratio;
    setCropRatio(ratio);
  }
  nextTick(() => {
    updateInputFromCanvas();
  });
};

// ============================================
// 新增/修改：输入框联动计算逻辑
// ============================================

// 获取当前有效的计算比例
const getActiveRatio = () => {
  // 1. 如果当前选中的是数字比例 (如 1.5, 0.75 等)，直接返回
  if (typeof currentRatio.value === 'number') {
    return currentRatio.value;
  }
  // 2. 如果当前选中的是 'original'，则使用逻辑层计算出的真实比例
  if (currentRatio.value === 'original' && currentAspectRatio.value) {
    return currentAspectRatio.value;
  }
  // 3. 自由比例返回 null
  return null;
};

// 宽度变化时
const onWidthChange = () => {
  const ratio = getActiveRatio();
  // 如果有锁定比例，且宽度有效
  if (ratio && cropW.value > 0) {
    // 宽 = 高 * 比例  =>  高 = 宽 / 比例
    cropH.value = Math.round(cropW.value / ratio);
  }
  // 应用到画布
  applyInputSize();
};

// 高度变化时
const onHeightChange = () => {
  const ratio = getActiveRatio();
  // 如果有锁定比例，且高度有效
  if (ratio && cropH.value > 0) {
    // 宽 = 高 * 比例
    cropW.value = Math.round(cropH.value * ratio);
  }
  // 应用到画布
  applyInputSize();
};

// 将输入框的值应用到 Canvas 选区
const applyInputSize = () => {
  if (cropW.value > 0 && cropH.value > 0) {
    setCropBoxSize(cropW.value, cropH.value);
  }
};

const toggleRatioLock = () => {
  if (isRatioLocked.value) {
    handleSetRatio(null);
  } else {
    // 如果是从自由比例点击锁定，则锁定当前输入的比例
    if (cropW.value && cropH.value) {
      const currentR = cropW.value / cropH.value;
      currentRatio.value = currentR;
      setCropRatio(currentR);
    }
  }
};

// ============================================

const isManualActive = computed(() => isManualCropping.value);

const updateInputFromCanvas = () => {
  if (cropObject.value) {
    const w = Math.round(cropObject.value.getScaledWidth());
    const h = Math.round(cropObject.value.getScaledHeight());

    cropW.value = w;
    cropH.value = h;
    if (currentRatio.value !== 'free' && currentRatio.value !== 'original' && typeof currentRatio.value === 'number') {
      const currentRealRatio = w / h;
      const targetRatio = currentRatio.value;
      if (Math.abs(currentRealRatio - targetRatio) > 0.02) {
        currentRatio.value = 'free';
        setCropRatio(null);
      }
    }
  }
};

const handleManualSelect = () => {
  currentRatio.value = 'manual'; // 1. 将 UI 状态设为 manual，清除“原比例”和“自由比例”的高亮
  setCropRatio(null);            // 2. 核心修复：调用逻辑层方法，将比例锁定设为 null，从而清除 1:1、3:2 等项的高亮
  startManualSelection()
};

const rotate = (angle) => {
  rotateActive(angle);
  setTimeout(updateInputFromCanvas, 50);
};
const flip = (axis) => flipActive(axis);

onMounted(() => {
  if (props.isExpanded) {
    openCropPanel();
    nextTick(() => {
      startCrop(null);
      updateInputFromCanvas();
    });
  }

  const checkCanvas = setInterval(() => {
    const canvasInstance = cropObject.value?.canvas;
    if (canvasInstance) {
      canvasInstance.on('object:scaling', updateInputFromCanvas);
      canvasInstance.on('object:modified', updateInputFromCanvas);
      canvasInstance.on('object:moving', updateInputFromCanvas);
      clearInterval(checkCanvas);
    }
  }, 100);
});

onUnmounted(() => {
  const canvasInstance = cropObject.value?.canvas;
  if (canvasInstance) {
    canvasInstance.off('object:scaling', updateInputFromCanvas);
    canvasInstance.off('object:modified', updateInputFromCanvas);
    canvasInstance.off('object:moving', updateInputFromCanvas);
  }

  if (props.isExpanded) {
    closeCropPanel();
  }
});
</script>

<style scoped>
/* 保持所有样式不变 */
.ratio-grid {
  display: grid;
  grid-template-columns: repeat(3, 1fr);
  gap: 8px;
  margin-bottom: 16px;
}

.ratio-item {
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  padding: 10px 4px;
  border: 1px solid #f2f2f2;
  border-radius: 6px;
  cursor: pointer;
  font-size: 12px;
  color: #666;
  background: #fff;
  transition: all 0.2s;
  height: 60px;
}

.ratio-item:hover {
  background-color: #f9f9f9;
  border-color: #dcdfe6;
}

.ratio-item.active {
  border-color: var(--ie-primary-color);
  color: var(--ie-primary-color);
  background-color: #ecf5ff;
}

.icon-box {
  display: flex;
  align-items: center;
  justify-content: center;
  margin-bottom: 6px;
}

.shape-rect {
  border: 1px solid currentColor;
  margin-bottom: 6px;
  box-sizing: border-box;
}

.shape-rect.dashed {
  border-style: dashed;
  width: 14px;
  height: 14px;
}

.shape-rect.square {
  width: 14px;
  height: 14px;
}

.custom-input-box {
  background-color: #f8f9fa;
  border: none;
  border-radius: 6px;
  padding: 10px;
  margin-bottom: 12px;
}

.input-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  font-size: 13px;
  color: #333;
  margin-bottom: 8px;
}

.input-controls {
  display: flex;
  align-items: center;
  justify-content: space-between;
}

.input-wrapper {
  position: relative;
  width: 38%;
}

.ie-input {
  text-align: center;
  padding-right: 20px;
  font-weight: 500;
  color: #333;
}

.suffix {
  position: absolute;
  right: 6px;
  top: 50%;
  transform: translateY(-50%);
  color: #c0c4cc;
  font-size: 12px;
  pointer-events: none;
}

.link-icon {
  width: 24px;
  display: flex;
  justify-content: center;
  cursor: pointer;
}

.rotate-actions {
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: 20px;
  padding: 0 10px;
}

.action-btn {
  width: 36px;
  height: 36px;
  display: flex;
  align-items: center;
  justify-content: center;
  border-radius: 6px;
  cursor: pointer;
  color: #606266;
  font-size: 18px;
  background-color: #f5f7fa;
  transition: all 0.2s;
}

.action-btn:hover {
  background-color: #e6e8eb;
  color: #333;
}

.divider {
  width: 1px;
  height: 20px;
  background-color: #eee;
}

.confirm-row {
  display: flex;
  gap: 10px;
}

.full-btn {
  flex: 1;
}
</style>
</file>

<file path="src/components/modules/adjust/useCanvasCrop.js">
// src/components/modules/adjust/useCanvasCrop.js
import { ref, shallowRef, toRaw } from "vue";
import { fabric } from "fabric";

// 1. 引入通用规范工具
import { getLogicRect, animateRebound, constrainObjectToRect } from '@/composables/useConstraint';
import { renderHighResSnapshot } from '@/composables/useOffscreenHelper';

// === 状态变量 ===
const cropObject = shallowRef(null);
const isManualCropping = ref(false);
const isCropping = ref(false);
const isRatioLocked = ref(false);
const currentAspectRatio = ref(null);

// 用于实时向 UI 传递当前选区/裁剪框的宽高
const currentSelectionDims = ref({ width: 0, height: 0 });

// 内部引用
let canvasRef = null;
let saveHistoryFn = null;
let zoomToRectFn = null;

// 内部变量
let selectionRect = null;
let maskRect = null;
let selectionStartX = 0;
let selectionStartY = 0;
let aspectRatioValue = null;
let savedWheelListeners = [];

// 拖拽图片相关变量
let isDraggingImage = false;
let dragLastX = 0;
let dragLastY = 0;

// 标志位：是否正在应用裁剪
let isApplyingCrop = false;

export const registerCropModule = (canvas, saveHistory, zoomToRect) => {
  canvasRef = canvas;
  saveHistoryFn = saveHistory;
  zoomToRectFn = zoomToRect;
};

// =========================================================
// 辅助工具
// =========================================================

const updateCurrentDims = (obj) => {
  if (!obj || !canvasRef?.value) return;
  const rect = getLogicRect(obj, canvasRef.value);
  currentSelectionDims.value = {
    width: Math.round(rect.width),
    height: Math.round(rect.height)
  };
};

const preventZoomWheel = (opt) => {
  if (!opt || !opt.e) return;
  opt.e.preventDefault();
  opt.e.stopPropagation();
  if (opt.e.stopImmediatePropagation) opt.e.stopImmediatePropagation();
};

// =========================================================
// 拖动图片的核心逻辑 (集成通用回弹)
// =========================================================
const onCropMouseDown = (opt) => {
  if (!canvasRef?.value || !cropObject.value) return;
  const target = opt.target;
  // 必须点击在剪裁框上（作为容器）
  if (target !== cropObject.value) return;

  const activeObj = canvasRef.value.getActiveObject();
  if (activeObj && activeObj.__corner) return;

  // 开始拖动图片
  isDraggingImage = true;
  const pointer = canvasRef.value.getPointer(opt.e);
  dragLastX = pointer.x;
  dragLastY = pointer.y;
  canvasRef.value.defaultCursor = 'move';
};

const onCropMouseMove = (opt) => {
  if (!isDraggingImage || !canvasRef?.value) return;
  const canvas = canvasRef.value;
  const pointer = canvas.getPointer(opt.e);
  const deltaX = pointer.x - dragLastX;
  const deltaY = pointer.y - dragLastY;

  const bgImage = canvas.getObjects().find(o => o.type === 'image');

  if (bgImage) {
    // 自由拖拽，暂不约束，依靠 mouseUp 时的回弹
    bgImage.left += deltaX;
    bgImage.top += deltaY;
    bgImage.setCoords();
  }

  dragLastX = pointer.x;
  dragLastY = pointer.y;
  canvas.requestRenderAll();
};

const onCropMouseUp = () => {
  if (isDraggingImage) {
    if (canvasRef?.value && cropObject.value) {
      const bgImage = canvasRef.value.getObjects().find(o => o.type === 'image');
      if (bgImage) {
        // 【核心升级】使用通用动画回弹，确保图片始终填满裁剪框
        animateRebound(bgImage, cropObject.value, canvasRef.value);
      }
    }

    isDraggingImage = false;
    if (canvasRef?.value) canvasRef.value.defaultCursor = 'default';
  }
};

// =========================================================
// 面板开关
// =========================================================
export const openCropPanel = () => {
  if (!canvasRef?.value) return;
  if (isCropping.value) return;

  isApplyingCrop = false;

  const canvas = canvasRef.value;
  canvas.fire('zoom:change', { from: 'crop-module' });

  if (canvas.__eventListeners && canvas.__eventListeners['mouse:wheel']) {
    savedWheelListeners = [...canvas.__eventListeners['mouse:wheel']];
    canvas.off('mouse:wheel');
  }
  canvas.on('mouse:wheel', preventZoomWheel);

  isCropping.value = true;
};

export const closeCropPanel = () => {
  if (!canvasRef?.value) return;
  const canvas = canvasRef.value;

  if (isApplyingCrop) {
    if (isManualCropping.value) endManualSelectionMode();
    isCropping.value = false;
    return;
  }

  if (isManualCropping.value) {
    endManualSelectionMode();
  }

  cancelCrop();
  isCropping.value = false;

  canvas.discardActiveObject();
  canvas.requestRenderAll();
  canvas.fire('zoom:change');
};

// =========================================================
// 约束裁剪框 (保持在图片范围内)
// 注意：裁剪框的约束逻辑特殊（Box inside Image），与 Resize（Image inside Box）相反
// 因此保留了部分特定的尺寸检查逻辑，但位置修正可复用逻辑
// =========================================================
export const constrainCrop = (activeObj) => {
  if (!canvasRef?.value || !activeObj) return;
  const canvas = canvasRef.value;

  const bgImage = canvas.getObjects().find((o) => o.type === "image");
  if (!bgImage) return;

  const bgRect = getLogicRect(bgImage, canvas);
  const bgWidth = bgRect.width;
  const bgHeight = bgRect.height;
  const bgLeft = bgRect.left;
  const bgTop = bgRect.top;

  let currentScaleX = activeObj.scaleX;
  let currentScaleY = activeObj.scaleY;

  // 1. 尺寸约束：裁剪框不能比图片大
  let cropCurrentWidth = activeObj.width * currentScaleX;
  let cropCurrentHeight = activeObj.height * currentScaleY;
  let sizeChanged = false;

  if (cropCurrentWidth > bgWidth + 0.5) {
    currentScaleX = bgWidth / activeObj.width;
    sizeChanged = true;
  }
  if (cropCurrentHeight > bgHeight + 0.5) {
    currentScaleY = bgHeight / activeObj.height;
    sizeChanged = true;
  }
  if (sizeChanged) {
    activeObj.set({ scaleX: currentScaleX, scaleY: currentScaleY });
    activeObj.setCoords();
  }

  // 2. 位置约束：裁剪框必须在图片内部
  // 计算边界
  const finalCropWidth = activeObj.getScaledWidth();
  const finalCropHeight = activeObj.getScaledHeight();

  // 限制左上角坐标
  const minLeft = bgLeft;
  const maxLeft = bgLeft + bgWidth - finalCropWidth;
  const minTop = bgTop;
  const maxTop = bgTop + bgHeight - finalCropHeight;

  let newLeft = Math.max(minLeft, Math.min(activeObj.left, maxLeft));
  let newTop = Math.max(minTop, Math.min(activeObj.top, maxTop));

  activeObj.set({ left: newLeft, top: newTop });
  activeObj.setCoords();

  updateCurrentDims(activeObj);
  canvas.requestRenderAll();
};

// =========================================================
// 取消裁剪 (清理)
// =========================================================
export const cancelCrop = (shouldRender = true) => {
  if (canvasRef?.value && cropObject.value) {
    const rawObj = toRaw(cropObject.value);

    // 解绑拖拽图片事件
    canvasRef.value.off('mouse:down', onCropMouseDown);
    canvasRef.value.off('mouse:move', onCropMouseMove);
    canvasRef.value.off('mouse:up', onCropMouseUp);

    canvasRef.value.remove(rawObj);
    cropObject.value = null;
    isDraggingImage = false;

    if (shouldRender) {
      canvasRef.value.renderAll();
    }
  }
};

// ... (手动选区逻辑保持不变) ...
export const endManualSelectionMode = () => {
  if (!canvasRef?.value) return;
  const canvas = canvasRef.value;
  canvas.defaultCursor = 'default';
  canvas.hoverCursor = 'move';
  canvas.selection = true;
  canvas.getObjects().forEach(o => {
    if (o !== maskRect && o !== selectionRect) {
      o.selectable = true;
      o.evented = true;
    }
  });
  canvas.off('mouse:down', onSelectionDown);
  canvas.off('mouse:move', onSelectionMove);
  canvas.off('mouse:up', onSelectionUp);
  if (selectionRect) { canvas.remove(selectionRect); selectionRect = null; }
  if (maskRect) { canvas.remove(maskRect); maskRect = null; }
  isManualCropping.value = false;
  canvas.requestRenderAll();
};

const onSelectionDown = (opt) => {
  const canvas = canvasRef.value;
  if (!canvas) return;
  const pointer = canvas.getPointer(opt.e);
  selectionStartX = pointer.x;
  selectionStartY = pointer.y;
  selectionRect = new fabric.Rect({
    left: selectionStartX, top: selectionStartY, width: 0, height: 0,
    fill: 'transparent', stroke: '#fff', strokeWidth: 2, strokeDashArray: [6, 6],
    selectable: false, evented: false
  });
  canvas.add(selectionRect);
  canvas.bringToFront(selectionRect);
};

const onSelectionMove = (opt) => {
  if (!selectionRect || !canvasRef.value) return;
  const pointer = canvasRef.value.getPointer(opt.e);
  let w = Math.abs(pointer.x - selectionStartX);
  let h = Math.abs(pointer.y - selectionStartY);
  let left = selectionStartX;
  let top = selectionStartY;
  if (pointer.x < selectionStartX) left = pointer.x;
  if (pointer.y < selectionStartY) top = pointer.y;
  selectionRect.set({ left, top, width: w, height: h });
  currentSelectionDims.value = { width: Math.round(w), height: Math.round(h) };
  canvasRef.value.requestRenderAll();
};

const onSelectionUp = () => {
  if (!selectionRect) {
    endManualSelectionMode();
    if (cropObject.value) cancelCrop();
    return;
  }
  const box = {
    left: selectionRect.left, top: selectionRect.top,
    width: selectionRect.width, height: selectionRect.height
  };
  endManualSelectionMode();
  if (box.width < 10 || box.height < 10) return;
  startCrop(null, box);
  if (zoomToRectFn) zoomToRectFn(box);
};

export const startManualSelection = () => {
  if (!canvasRef?.value) return;
  if (isManualCropping.value) endManualSelectionMode();
  const canvas = canvasRef.value;
  cancelCrop();
  canvas.getObjects().forEach(o => { o.selectable = false; o.evented = false; });
  maskRect = new fabric.Rect({
    left: -5000, top: -5000, width: 20000, height: 20000,
    fill: 'rgba(0, 0, 0, 0.45)', selectable: false, evented: false, excludeFromExport: true
  });
  canvas.add(maskRect);
  canvas.defaultCursor = 'crosshair';
  canvas.hoverCursor = 'crosshair';
  canvas.selection = false;
  isManualCropping.value = true;
  canvas.on('mouse:down', onSelectionDown);
  canvas.on('mouse:move', onSelectionMove);
  canvas.on('mouse:up', onSelectionUp);
  canvas.requestRenderAll();
};

// ... (setCropRatio 保持不变) ...
export const setCropRatio = (ratio) => {
  if (!canvasRef?.value) return;
  const canvas = canvasRef.value;
  if (ratio === null) {
    isRatioLocked.value = false;
    currentAspectRatio.value = null;
    if (cropObject.value) {
      cropObject.value.set({ lockUniScaling: false });
      canvas.requestRenderAll();
    }
    return;
  }
  isRatioLocked.value = true;
  currentAspectRatio.value = ratio;
  let baseW, baseH, left, top;
  const activeObj = canvas.getObjects().find((obj) => obj.type === "image");
  if (!activeObj) return;

  // 使用 getLogicRect 获取准确的包围盒
  const rect = getLogicRect(activeObj, canvas);
  baseW = rect.width; baseH = rect.height; left = rect.left; top = rect.top;

  const currentRatio = baseW / baseH;
  let newW, newH;
  if (currentRatio > ratio) {
    newH = baseH; newW = newH * ratio; left += (baseW - newW) / 2;
  } else {
    newW = baseW; newH = newW / ratio; top += (baseH - newH) / 2;
  }
  if (cropObject.value) {
    cropObject.value.set({
      width: newW, height: newH, left: left, top: top,
      scaleX: 1, scaleY: 1, lockUniScaling: false
    });
    cropObject.value.setCoords();
    constrainCrop(cropObject.value);
    canvas.requestRenderAll();
  } else {
    startCrop(ratio, { left, top, width: newW, height: newH });
  }
};

// =========================================================
// startCrop
// =========================================================
export const startCrop = (aspectRatio = null, customBox = null) => {
  if (!canvasRef?.value) return;
  const canvas = canvasRef.value;
  if (isManualCropping.value) endManualSelectionMode();

  aspectRatioValue = aspectRatio || null;
  let activeObj = canvas.getObjects().find((obj) => obj.type === "image");
  if (!activeObj) return;

  cancelCrop();

  const rect = getLogicRect(activeObj, canvas);
  let width, height, left, top;

  if (customBox) {
    width = customBox.width; height = customBox.height; left = customBox.left; top = customBox.top;
  } else {
    const imgWidth = rect.width; const imgHeight = rect.height;
    width = imgWidth * 1; height = imgHeight * 1;
    if (aspectRatio) {
      height = width / aspectRatio;
      if (height > imgHeight) {
        height = imgHeight; width = height * aspectRatio;
      }
      isRatioLocked.value = true; currentAspectRatio.value = aspectRatio;
    } else {
      isRatioLocked.value = false; currentAspectRatio.value = null;
    }
    left = rect.left + (imgWidth - width) / 2;
    top = rect.top + (imgHeight - height) / 2;
  }

  const cropZone = new fabric.Rect({
    left: left, top: top, width: width, height: height,
    fill: "transparent", stroke: "#409eff", strokeWidth: 2,
    cornerColor: "white", cornerStrokeColor: "#409eff", cornerSize: 12,
    transparentCorners: false, lockRotation: true, hasRotatingPoint: false,
    lockUniScaling: false,
    lockMovementX: true,
    lockMovementY: true
  });
  if (aspectRatio) cropZone.set("height", width / aspectRatio);

  canvas.add(cropZone);
  canvas.setActiveObject(cropZone);
  cropObject.value = cropZone;
  canvas.renderAll();
  updateCurrentDims(cropZone);
  constrainCrop(cropZone);

  // 绑定拖图事件
  canvas.on('mouse:down', onCropMouseDown);
  canvas.on('mouse:move', onCropMouseMove);
  canvas.on('mouse:up', onCropMouseUp);
};

// =========================================================
// 确认裁剪 (高清重制版)
// =========================================================
export const confirmCrop = async () => {
  if (!canvasRef?.value || !cropObject.value) return Promise.resolve();
  const canvas = canvasRef.value;
  const cropRect = cropObject.value;
  const bgImage = canvas.getObjects().find((o) => o.type === "image");
  if (!bgImage) { cancelCrop(); return Promise.resolve(); }

  isApplyingCrop = true;

  // 1. 获取裁剪区域的逻辑信息
  const cropLogicRect = getLogicRect(cropRect, canvas);
  const bgLogicRect = getLogicRect(bgImage, canvas);

  // 2. 计算目标导出尺寸 (基于原图分辨率)
  // 如果图片被缩放了(scale=0.5), 我们希望裁剪出来的图是基于原图大小的，所以目标尺寸要除以 scale
  const scaleFactor = bgImage.scaleX; // 假设均匀缩放
  const targetW = Math.round(cropLogicRect.width / scaleFactor);
  const targetH = Math.round(cropLogicRect.height / scaleFactor);

  if (targetW <= 0 || targetH <= 0) {
    cancelCrop();
    return Promise.resolve();
  }

  // 临时隐藏裁剪框，避免干扰
  cropRect.visible = false;

  // 3. 使用离屏渲染生成高清裁剪图
  const croppedDataUrl = await renderHighResSnapshot(bgImage, targetW, targetH, (highResImg) => {
    // 3.1 计算相对位置偏移 (使用中心点差值法，抗旋转干扰)
    const cropCenter = cropRect.getCenterPoint();
    const imgCenter = bgImage.getCenterPoint();

    // 计算中心点差距（逻辑像素）
    const diffX = imgCenter.x - cropCenter.x;
    const diffY = imgCenter.y - cropCenter.y;

    // 映射到原图尺度
    const finalDiffX = diffX / scaleFactor;
    const finalDiffY = diffY / scaleFactor;

    // 3.2 设置高分图属性
    highResImg.set({
      originX: 'center', originY: 'center',
      left: targetW / 2 + finalDiffX,
      top: targetH / 2 + finalDiffY,
      scaleX: 1, // 恢复到原图比例
      scaleY: 1,
      angle: bgImage.angle,
      flipX: bgImage.flipX,
      flipY: bgImage.flipY
    });
  });

  cropRect.visible = true;

  return new Promise((resolve) => {
    // 4. 应用回主画布
    bgImage.setSrc(croppedDataUrl, () => {
      cancelCrop(false);

      // 5. 物理重置：将新图片放回画布中心
      bgImage.set({
        originX: "center", originY: "center",
        left: canvas.width / 2, top: canvas.height / 2,
        scaleX: 1, scaleY: 1, // 裁剪后就是 1:1
        angle: 0, flipX: false, flipY: false,
      });
      bgImage.setCoords();
      canvas.centerObject(bgImage);

      // 6. 视口自适应 (Zoom to fit)
      // 让裁剪后的图片在屏幕上显示大小合适
      const paddingFactor = 0.85;
      const zoomToFit = Math.min(
        (canvas.width * paddingFactor) / targetW, // 注意这里用 targetW 可能会很大
        (canvas.height * paddingFactor) / targetH
      );

      // 因为 targetW 是原图尺寸，可能几千像素，我们这里计算的是 Zoom Level
      // 实际上展示时，我们希望它占据屏幕大部分
      // 重新计算：图片现在尺寸是 targetW * 1 * zoomToFit
      // 所以 Zoom 应该是 canvasSize / targetSize

      // 设置新的视口
      canvas.setViewportTransform([1, 0, 0, 1, 0, 0]); // 先重置
      const newZoom = zoomToFit;
      const center = canvas.getCenter();
      canvas.zoomToPoint({ x: center.left, y: center.top }, newZoom);

      isApplyingCrop = false;
      isCropping.value = false;
      canvas.fire('zoom:change', { from: 'crop-confirm' });
      canvas.requestRenderAll();
      if (saveHistoryFn) saveHistoryFn();
      resolve();
    });
  });
};

export const setCropBoxSize = (width, height) => {
  if (!cropObject.value || !canvasRef?.value) return;
  const obj = cropObject.value;
  const oldRealWidth = obj.getScaledWidth();
  const oldRealHeight = obj.getScaledHeight();
  const centerX = obj.left + oldRealWidth / 2;
  const centerY = obj.top + oldRealHeight / 2;
  obj.set({ width: width, height: height, scaleX: 1, scaleY: 1 });
  const newLeft = centerX - width / 2;
  const newTop = centerY - height / 2;
  obj.set({ left: newLeft, top: newTop });
  obj.setCoords();
  constrainCrop(obj);
  canvasRef.value.requestRenderAll();
};

export const rotateActive = (angle) => {
  if (cropObject.value && canvasRef?.value) {
    const canvas = canvasRef.value;
    const bgImage = canvas.getObjects().find((o) => o.type === "image");
    if (bgImage) {
      bgImage.rotate((bgImage.angle || 0) + angle);
      canvas.centerObject(bgImage);
      bgImage.setCoords();
      canvas.renderAll();
      startCrop(aspectRatioValue);
    }
    return true;
  }
  return false;
};

export const flipActive = (axis) => {
  if (cropObject.value && canvasRef?.value) {
    const canvas = canvasRef.value;
    const bgImage = canvas.getObjects().find((o) => o.type === "image");
    if (bgImage) {
      if (axis === "X") bgImage.set("flipX", !bgImage.flipX);
      if (axis === "Y") bgImage.set("flipY", !bgImage.flipY);
      canvas.requestRenderAll();
    }
    return true;
  }
  return false;
};

export {
  cropObject,
  isManualCropping,
  isRatioLocked,
  currentAspectRatio,
  isCropping,
  currentSelectionDims
};
</file>

<file path="src/components/Workspace.vue">
<template>
  <div class="workspace-container">
    <div class="canvas-center" ref="canvasContainer" @contextmenu.prevent="handleRightClick">
      <canvas id="c"></canvas>
    </div>

    <FloatingObjectMenu />

    <CanvasContextMenu :visible="showContextMenu" :position="contextMenuPos" @close="closeContextMenu"
      @paste="handleMenuPaste" />

    <ShortcutsPanel :visible="showShortcuts" @close="showShortcuts = false" />

    <div class="zoom-controls">
      <button class="ie-btn ie-btn-circle" title="快捷键列表" @click="showShortcuts = true">
        <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"
          stroke-linecap="round" stroke-linejoin="round">
          <rect x="2" y="4" width="20" height="16" rx="2" ry="2"></rect>
          <path d="M6 8h.01"></path>
          <path d="M10 8h.01"></path>
          <path d="M14 8h.01"></path>
          <path d="M18 8h.01"></path>
          <path d="M6 12h.01"></path>
          <path d="M18 12h.01"></path>
          <path d="M7 16h10"></path>
          <path d="M12 12v-1"></path>
        </svg>

      </button>

      <div class="divider"></div>

      <button class="ie-btn ie-btn-circle" title="缩小" @click="handleZoomOut">
        <svg viewBox="0 0 1024 1024" width="16" height="16">
          <path d="M128 544h768a32 32 0 1 0 0-64H128a32 32 0 1 0 0 64z" fill="currentColor" />
        </svg>
      </button>

      <span class="zoom-text" @click="handleReset" title="点击重置为100%">
        {{ zoomPercentage }}%
      </span>

      <button class="ie-btn ie-btn-circle" title="放大" @click="handleZoomIn">
        <svg viewBox="0 0 1024 1024" width="16" height="16">
          <path
            d="M480 480H160a32 32 0 0 0 0 64h320v320a32 32 0 0 0 64 0V544h320a32 32 0 0 0 0-64H544V160a32 32 0 0 0-64 0v320z"
            fill="currentColor" />
        </svg>
      </button>
    </div>
  </div>
</template>

<script setup>
import { onMounted, inject, ref, computed, onUnmounted, unref } from 'vue';
import FloatingObjectMenu from "./common/FloatingObjectMenu.vue";
import CanvasContextMenu from "./common/CanvasContextMenu.vue";
import { useObjectActions } from "@/composables/useObjectActions";
import { useKeyboardShortcuts } from "@/composables/useKeyboardShortcuts";
import ShortcutsPanel from "@/components/common/ShortcutsPanel.vue";

const props = defineProps({
  imageUrl: {
    type: String,
    default: ''
  },
});

const canvasAPI = inject('canvasAPI');
const canvasContainer = ref(null);
const pastePosition = ref(null);
const showShortcuts = ref(false);

// 计算属性
const zoomPercentage = computed(() => {
  return canvasAPI?.zoom?.value ? Math.round(canvasAPI.zoom.value * 100) : 100;
});

// 操作处理
const handleZoomIn = () => canvasAPI?.zoomIn && canvasAPI.zoomIn();
const handleZoomOut = () => canvasAPI?.zoomOut && canvasAPI.zoomOut();
const handleReset = () => canvasAPI?.zoomReset && canvasAPI.zoomReset();

const updateZoomState = () => {
  const fabricCanvas = canvasAPI?.canvas?.value;
  if (fabricCanvas && canvasAPI.zoom) {
    canvasAPI.zoom.value = fabricCanvas.getZoom();
  }
};

// === 右键菜单逻辑 ===
const actions = useObjectActions();
useKeyboardShortcuts(actions);
const showContextMenu = ref(false);
const contextMenuPos = ref({ x: 0, y: 0 });

const closeContextMenu = () => {
  showContextMenu.value = false;
};

const onGlobalClick = () => {
  if (showContextMenu.value) closeContextMenu();
};

const handleRightClick = (e) => {
  if (e.target.closest('.floating-wrapper')) return;

  contextMenuPos.value = { x: e.clientX, y: e.clientY };

  const canvas = unref(canvasAPI.canvas);
  if (canvas) {
    const pointer = canvas.getPointer(e);
    pastePosition.value = pointer;
  }

  showContextMenu.value = true;
};

const handleMenuPaste = () => {
  actions.pasteActive(pastePosition.value);
};

onMounted(() => {
  window.addEventListener('click', onGlobalClick);
  if (canvasAPI && canvasAPI.init) {
    const width = canvasContainer.value.clientWidth || 1900;
    const height = canvasContainer.value.clientHeight || 1000;
    canvasAPI.init('c', width, height);

    const fabricCanvas = canvasAPI.canvas.value;
    if (fabricCanvas) {
      fabricCanvas.on('zoom:change', updateZoomState);
      fabricCanvas.on('mouse:wheel', updateZoomState);
    }
  } else {
    console.error('CanvasAPI not found.');
  }
});

onUnmounted(() => {
  const fabricCanvas = canvasAPI?.canvas?.value;
  if (fabricCanvas) {
    fabricCanvas.off('zoom:change', updateZoomState);
    fabricCanvas.off('mouse:wheel', updateZoomState);
  }
  window.removeEventListener('click', onGlobalClick);
});
</script>

<style scoped>
.workspace-container {
  width: 100%;
  height: 100%;
  display: flex;
  justify-content: center;
  align-items: center;
  position: relative;
  background-color: #f0f2f5;
  overflow: hidden;
}

.canvas-center {
  box-shadow: 0 0 20px rgba(0, 0, 0, 0.1);
  width: 95%;
  height: 95%;
  display: flex;
  justify-content: center;
  align-items: center;
}

.zoom-controls {
  position: absolute;
  bottom: 20px;
  right: 20px;
  background: white;
  padding: 8px 12px;
  border-radius: 24px;
  display: flex;
  align-items: center;
  gap: 8px;
  box-shadow: 0 2px 12px rgba(0, 0, 0, 0.1);
  z-index: 100;
}

.zoom-text {
  font-size: 13px;
  color: #606266;
  min-width: 45px;
  text-align: center;
  user-select: none;
  font-variant-numeric: tabular-nums;
  cursor: pointer;
  transition: color 0.2s;
}

.zoom-text:hover {
  color: var(--ie-primary-color);
}

/* ✅ 修复3: 必须添加按钮样式，否则按钮是透明的或者看不到 */
.ie-btn {
  border: none;
  background: transparent;
  cursor: pointer;
  color: #606266;
  transition: all 0.2s;
  display: flex;
  align-items: center;
  justify-content: center;
  padding: 0;
}

.ie-btn:hover {
  color: var(--ie-primary-color);
  /* 或者您的主题色 */
  background-color: #ecf5ff;
}

.ie-btn-circle {
  width: 32px;
  height: 32px;
  border-radius: 50%;
}

.zoom-controls .divider {
  width: 1px;
  height: 16px;
  background: #ebeef5;
  margin: 0 4px;
}
</style>
</file>

<file path="src/components/modules/adjust/AdjustResize.vue">
<template>
  <div class="tool-group">
    <div class="tool-item" :class="{ 'is-expanded': isExpanded }" @click="handleToggle">
      <div class="left">
        <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"
          stroke-linecap="round" stroke-linejoin="round" style="margin-right: 8px;">
          <path d="M15 3h6v6" />
          <path d="M9 21H3v-6" />
          <path d="M21 3l-7 7" />
          <path d="M3 21l7-7" />
        </svg>
        <span>调整尺寸</span>
      </div>
      <div class="right-icon">
        <svg class="arrow" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"
          stroke-linecap="round" stroke-linejoin="round">
          <path d="m9 18 6-6-6-6" />
        </svg>
      </div>
    </div>

    <div v-if="isExpanded" class="tool-content">

      <div class="preset-grid">
        <div class="preset-item custom-item" :class="{ active: isCustomMode }" @click="selectCustomMode">
          <span>自定义</span>
          <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"
            stroke-linecap="round" stroke-linejoin="round">
            <rect x="3" y="3" width="18" height="18" rx="2" ry="2"></rect>
            <line x1="12" y1="8" x2="12" y2="16"></line>
            <line x1="8" y1="12" x2="16" y2="12"></line>
          </svg>

        </div>

        <div v-for="(preset, index) in presets" :key="index" class="preset-item"
          :class="{ active: activePresetIndex === index }" @click="selectPreset(preset, index)">
          <span class="preset-name">{{ preset.label }}</span>
          <span class="preset-dim">{{ preset.w }}×{{ preset.h }}</span>
        </div>
      </div>

      <div class="resize-input-box">

        <div class="input-controls">
          <div class="input-wrapper">
            <input type="number" v-model.number="width" class="ie-input" @input="onInputChanged">
            <span class="suffix">W</span>
          </div>

          <div class="link-icon-btn" @click="toggleAdaptive" :title="isAdaptive ? '锁定比例' : '自由比例'">
            <svg v-if="isAdaptive" width="16" height="16" viewBox="0 0 24 24" fill="none"
              stroke="var(--ie-primary-color)" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
              <path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path>
              <path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path>
            </svg>
            <svg v-else width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="#999" stroke-width="2"
              stroke-linecap="round" stroke-linejoin="round" style="opacity: 0.6">
              <path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path>
              <path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path>
              <line x1="4" y1="4" x2="20" y2="20" stroke="#999"></line>
            </svg>
          </div>

          <div class="input-wrapper">
            <input type="number" v-model.number="height" class="ie-input" @input="onInputChanged">
            <span class="suffix">H</span>
          </div>
        </div>

        <div class="switch-row">
          <div class="ie-switch" :class="{ 'is-checked': isAdaptive }" @click="toggleAdaptive">
            <span class="ie-switch-core"></span>
          </div>
          <span class="switch-label">锁定长宽比 (保真模式)</span>
        </div>

        <!-- <div class="reset-row">
           <span class="reset-link" @click="resetToOriginal">恢复原图尺寸</span>
        </div> -->

      </div>

      <div class="action-buttons">
        <button class="ie-btn ie-primary full" @click="handleApply">应用修改</button>
        <button class="ie-btn full" @click="handleCancel">取消</button>
      </div>

    </div>
  </div>
</template>

<script setup>
import { ref, inject, watch, onMounted, onUnmounted, nextTick, computed } from 'vue';
import { registerResizeModule, getCurrentSize, applyResize, startPreview, updatePreview, stopPreview } from './useCanvasResize';

const props = defineProps({
  isExpanded: { type: Boolean, default: false }
});

const emit = defineEmits(['toggle']);
const canvasAPI = inject('canvasAPI');

// === 状态定义 ===
const width = ref(0);
const height = ref(0);
const isAdaptive = ref(true);
const originalRatio = ref(1);
const activePresetIndex = ref(-1);
const isInternalUpdate = ref(false); // 防止循环更新

// 预设数据 (可根据需要扩展)
const presets = [
  { label: '方形主图', w: 800, h: 800 },
  { label: 'Temu服装图', w: 1340, h: 1785 },
  { label: '方形主图', w: 1000, h: 1000 },
  { label: '竖图主图', w: 750, h: 1000 },
  { label: '方形主图', w: 500, h: 500 },
  { label: '竖图主图', w: 1000, h: 1200 },
  { label: 'Youtube视频封面', w: 1280, h: 720 },
  { label: 'Pinterest帖子', w: 750, h: 1120 },
  { label: 'Facebook封面', w: 851, h: 315 },
];

const isCustomMode = computed(() => activePresetIndex.value === -1);

// === 核心逻辑：获取当前应遵循的比例 ===
// 对应表格逻辑：如果是预设，用预设比例；如果是自定义，用原图比例
const currentTargetRatio = computed(() => {
  if (activePresetIndex.value >= 0) {
    const p = presets[activePresetIndex.value];
    return p.h !== 0 ? (p.w / p.h) : 1;
  } else {
    return originalRatio.value;
  }
});

// === 初始化 ===
const initSize = () => {
  if (canvasAPI && canvasAPI.canvas) {
    registerResizeModule(canvasAPI.canvas, canvasAPI.saveHistory);
    const size = getCurrentSize();

    if (size.height > 0) {
      originalRatio.value = size.width / size.height;
    }

    width.value = size.width;
    height.value = size.height;
    activePresetIndex.value = -1; // 默认选中自定义
    isAdaptive.value = true;      // 默认开启保真

    // 立即启动预览 (显示蓝色虚线框)
    nextTick(() => {
      startPreview(width.value, height.value, !isAdaptive.value);
    });
  }
};

// === 交互逻辑 ===

const selectCustomMode = () => {
  activePresetIndex.value = -1;
  // 切换到自定义时，恢复到原图尺寸，或者保持当前输入但切换比例基准
  // 这里选择：重置回原图尺寸，符合直觉
  resetToOriginal();
};

const selectPreset = (preset, index) => {
  activePresetIndex.value = index;
  // 选中预设 -> 立即应用预设数值
  isInternalUpdate.value = true;
  width.value = preset.w;
  height.value = preset.h;
  // 选中预设通常意味着用户希望遵循该比例，所以自动开启保真
  isAdaptive.value = true;
  nextTick(() => {
    isInternalUpdate.value = false;
    updatePreviewBox(); // 更新预览
  });
};

const toggleAdaptive = () => {
  isAdaptive.value = !isAdaptive.value;
  // 打开开关瞬间，根据当前 Width 和 目标比例 修正 Height
  if (isAdaptive.value && width.value > 0) {
    isInternalUpdate.value = true;
    height.value = Math.round(width.value / currentTargetRatio.value);
    nextTick(() => {
      isInternalUpdate.value = false;
      updatePreviewBox();
    });
  } else {
    // 修改点 2：如果是关闭保真（进入拉伸模式），也立即刷新预览，触发图片拉伸效果
    updatePreviewBox();
  }
};

const resetToOriginal = () => {
  const size = getCurrentSize();
  width.value = size.width;
  height.value = size.height;
  // 恢复原尺寸预览
  updatePreviewBox();
};

// === 监听输入 (实现表格矩阵逻辑) ===

// 监听宽度变化
watch(width, (newW) => {
  if (isInternalUpdate.value) return;

  // 表格逻辑 1 & 3 & 5: 保真开启 -> 自动计算高度
  if (isAdaptive.value && newW > 0) {
    isInternalUpdate.value = true;
    height.value = Math.round(newW / currentTargetRatio.value);
    nextTick(() => { isInternalUpdate.value = false; });
  }
  // 表格逻辑 2 & 4: 保真关闭 -> 高度不变 (导致变形)
});

// 监听高度变化
watch(height, (newH) => {
  if (isInternalUpdate.value) return;

  if (isAdaptive.value && newH > 0) {
    isInternalUpdate.value = true;
    width.value = Math.round(newH * currentTargetRatio.value);
    nextTick(() => { isInternalUpdate.value = false; });
  }
});

// === 预览更新 ===
// 只要输入变化，就通知 canvas 更新虚线框
const onInputChanged = () => {
  updatePreviewBox();
};

const updatePreviewBox = () => {
  if (width.value > 0 && height.value > 0) {
    // 修改点 3：传入拉伸状态 (!isAdaptive.value)
    updatePreview(width.value, height.value, !isAdaptive.value);
  } else {
    stopPreview();
  }
};

// 监听展开状态
watch(() => props.isExpanded, (val) => {
  if (val) initSize();
  else stopPreview();
});

// === 应用与取消 ===
const handleApply = () => {
  // 修改点 4：传入拉伸状态
  applyResize(width.value, height.value, !isAdaptive.value);
  emit('toggle');
};

const handleCancel = () => {
  stopPreview();
  emit('toggle');
}

const handleToggle = () => {
  emit('toggle');
};

onMounted(() => {
  if (props.isExpanded) initSize();
});

onUnmounted(() => stopPreview());
</script>

<style scoped>
/* Grid 布局实现矩阵效果 */
.preset-grid {
  display: grid;
  grid-template-columns: 1fr 1fr;
  /* 两列 */
  gap: 8px;
  margin-bottom: 16px;
  max-height: 280px;
  overflow-y: auto;
}

.preset-item {
  background-color: #f5f7fa;
  padding: 10px;
  border-radius: 6px;
  font-size: 13px;
  color: #606266;
  cursor: pointer;
  border: 1px solid transparent;
  display: flex;
  flex-direction: column;
  /* 垂直排列文字 */
  align-items: center;
  justify-content: space-between;
  text-align: center;
  transition: all 0.2s;
}

.preset-item:hover {
  background-color: #e6f7ff;
  border-color: #c0c4cc;
}

.preset-item.active {
  background-color: #ecf5ff;
  color: var(--ie-primary-color);
  border-color: var(--ie-primary-color);
  font-weight: 500;
}

/* 自定义项特殊样式 */
.custom-item {
  flex-direction: row;
  /* 横向 */
  grid-column: span 2;
  /* 占满一行 */
  background-color: #fff;
  border: 1px dashed #dcdfe6;
}

.custom-item.active {
  border-style: solid;
}

.preset-name {
  font-weight: 500;
  margin-bottom: 2px;
}

.preset-dim {
  font-size: 11px;
  color: #909399;
}

/* 输入框区域样式优化 */
.resize-input-box {
  background-color: #fff;
  padding: 4px 0;
}

.input-controls {
  display: flex;
  align-items: center;
  justify-content: space-between;
  margin-bottom: 8px;
}

.input-wrapper {
  position: relative;
  width: 40%;
}

.ie-input {
  text-align: center;
  padding-right: 20px;
  font-weight: bold;
  color: #333;
  width: 100%;
  border: 1px solid #dcdfe6;
  border-radius: 4px;
  height: 32px;
  font-size: 13px;
}

.ie-input:focus {
  border-color: var(--ie-primary-color);
  outline: none;
}

.suffix {
  position: absolute;
  right: 6px;
  top: 50%;
  transform: translateY(-50%);
  color: #c0c4cc;
  font-size: 11px;
  pointer-events: none;
}

.link-icon-btn {
  cursor: pointer;
  padding: 4px;
  border-radius: 4px;
}

.link-icon-btn:hover {
  background-color: #f0f0f0;
}

.switch-row {
  display: flex;
  align-items: center;
  justify-content: center;
  margin-bottom: 12px;
}

.switch-label {
  font-size: 12px;
  color: #606266;
  margin-left: 8px;
  cursor: pointer;
}

.ie-switch {
  position: relative;
  display: inline-flex;
  align-items: center;
  width: 32px;
  height: 16px;
  border-radius: 10px;
  background-color: #dcdfe6;
  cursor: pointer;
  transition: background-color 0.3s;
}

.ie-switch.is-checked {
  background-color: var(--ie-primary-color);
}

.ie-switch-core {
  position: absolute;
  top: 2px;
  left: 2px;
  border-radius: 100%;
  width: 12px;
  height: 12px;
  background-color: #fff;
  transition: all 0.3s;
}

.ie-switch.is-checked .ie-switch-core {
  left: 100%;
  margin-left: -14px;
}

.reset-row {
  text-align: center;
  margin-bottom: 10px;
}

.reset-link {
  font-size: 12px;
  color: #909399;
  cursor: pointer;
  text-decoration: underline;
}

.reset-link:hover {
  color: var(--ie-primary-color);
}

.action-buttons {
  display: flex;
  gap: 10px;
}

.full {
  flex: 1;
}

.tool-item:hover .arrow {
  transform: translateX(2px);
  transition: transform 0.2s;
}

.tool-content {
  padding: 16px;
  border: 1px solid #eee;
  border-top: none;
}
</style>
</file>

<file path="src/style.css">
/* 1. 移除全局的 @import './reset.css'; 防止污染宿主环境 */
/* @import './reset.css'; */

/* 2. 将原先 :root 里的变量移到容器内，变成局部变量 */
.image-editor-sdk-container {

  /* === 1. 基础盒子设定 === */
  position: relative;
  width: 100%;
  height: 100%;
  box-sizing: border-box;
  overflow: hidden;

  /* === 2. 应用变量 === */
  font-family: var(--ie-font-family);
  background-color: var(--ie-bg-color);
  color: var(--ie-text-color);

  /* 字体优化 */
  -webkit-font-smoothing: antialiased;
  -moz-osx-font-smoothing: grayscale;
  /* 覆盖可能居中的 body 样式 */

  /* 确保容器内的所有元素继承 box-sizing */
  *,
  *::before,
  *::after {
    box-sizing: border-box;
    scrollbar-width: thin;
    scrollbar-color: rgba(144, 147, 153, 0.3) transparent;
  }

  /* === 链接样式 (Scope 化) === */
  a {
    font-weight: 500;
    color: #646cff;
    text-decoration: inherit;
  }

  a:hover {
    color: #535bf2;
  }

  /* === 标题样式 === */
  h1 {
    font-size: 3.2em;
    line-height: 1.1;
    margin: 0;
    /* 移除默认边距 */
  }

  /* === 按钮样式 (Scope 化，只影响编辑器内的 button) === */
  button {
    border-radius: 8px;
    border: 1px solid transparent;
    padding: 0.6em 1.2em;
    font-size: 1em;
    font-weight: 500;
    font-family: inherit;
    background-color: #1a1a1a;
    cursor: pointer;
    transition: border-color 0.25s;
    outline: none;
    margin: 0;
    /* 移除默认边距 */
  }

  button:hover {
    border-color: #646cff;
  }

  /* 针对亮色模式的适配 (如果宿主是亮色) */
  @media (prefers-color-scheme: light) {
    --ie-text-color: #213547;
    --ie-bg-color: #ffffff;

    a:hover {
      color: #747bff;
    }

    button {
      background-color: #f9f9f9;
    }
  }

  /* === IE UI Kit (组件库样式) === */
  .ie-actions {
    display: flex;

  }

  /* 1. 按钮增强 */
  .ie-btn {
    display: inline-flex;
    justify-content: center;
    align-items: center;
    height: 28px;
    padding: 0 12px;
    font-size: 13px;
    border-radius: 4px;
    border: 1px solid var(--ie-border-color);
    background-color: #fff;
    color: #606266;
    cursor: pointer;
    transition: .2s;
    outline: none;
  }

  .ie-btn:hover {
    color: var(--ie-primary-color);
    border-color: #c6e2ff;
    background-color: #ecf5ff;
  }

  .ie-btn:disabled {
    color: #c0c4cc;
    cursor: not-allowed;
    background-color: #fff;
    border-color: #ebeef5;
  }

  .ie-btn.ie-primary {
    color: #fff;
    background-color: var(--ie-primary-color);
    border-color: var(--ie-primary-color);
  }

  .ie-btn.ie-primary:hover {
    background-color: #66b1ff;
    border-color: #66b1ff;
  }

  .ie-btn-circle {
    width: 32px;
    padding: 0;
    border-radius: 50%;
  }

  /* 2. 输入框 */
  .ie-input {
    height: 32px;
    line-height: 32px;
    padding: 0 8px;
    border: 1px solid var(--ie-border-color);
    border-radius: 4px;
    color: #606266;
    background-color: #ffffff;
    width: 100%;
    box-sizing: border-box;
    appearance: textfield;
    font-size: 13px;
    /* 统一字体 */
  }

  /* 隐藏原生旋转按钮 */
  .ie-input::-webkit-outer-spin-button,
  .ie-input::-webkit-inner-spin-button {
    -webkit-appearance: none;
    margin: 0;
  }

  /* Firefox */
  .ie-input[type=number] {
    -moz-appearance: textfield;
  }

  .ie-input:focus {
    border-color: var(--ie-primary-color);
    outline: none;
  }

  /* 3. 分割线 */
  .ie-divider {
    width: 1px;
    height: 1em;
    margin: 6px 8px;
    background: var(--ie-border-color);
    display: inline-block;
    vertical-align: middle;
  }

  /* === 工具栏布局样式 === */

  .tool-list {
    display: flex;
    flex-direction: column;
    gap: 12px;
  }

  .tool-group {
    display: flex;
    flex-direction: column;
  }

  .tool-item {
    display: flex;
    align-items: center;
    justify-content: space-between;
    padding: 0 16px;
    height: 50px;
    background-color: #f5f7fa;
    border-radius: 8px;
    cursor: pointer;
    color: #333;
    font-size: 14px;
    transition: all 0.2s ease;
    user-select: none;
  }

  .tool-item:hover {
    background-color: #e6e8eb;
    transform: translateY(-1px);
  }

  .tool-item.is-expanded {
    background-color: #ecf5ff;
    color: var(--ie-primary-color);
    border-bottom-left-radius: 0;
    border-bottom-right-radius: 0;
  }

  .tool-item .left {
    display: flex;
    align-items: center;
    gap: 12px;
  }

  .tool-item .right-icon {
    display: flex;
    align-items: center;
    justify-content: center;
    min-width: 20px;
  }

  .tool-item .arrow {
    font-size: 14px;
    color: #909399;
    transition: transform 0.3s;
  }

  .tool-item.is-expanded .arrow {
    transform: rotate(90deg);
    color: var(--ie-primary-color);
  }

  .tool-content {
    background-color: #fff;
    padding: 16px;
    border: 1px solid #eee;
    border-top: none;
    border-bottom-left-radius: 8px;
    border-bottom-right-radius: 8px;
    box-shadow: 0 2px 12px 0 rgba(0, 0, 0, 0.05);
    animation: slideDown 0.2s ease-out;
    color: #333;
    /* 确保文字颜色正确 */
  }

  /* 动画 */
  @keyframes slideDown {
    from {
      opacity: 0;
      transform: translateY(-5px);
    }

    to {
      opacity: 1;
      transform: translateY(0);
    }
  }

  .status-dot {
    width: 8px;
    height: 8px;
    background-color: var(--ie-primary-color);
    border-radius: 50%;
  }

  .is-loading {
    animation: rotating 2s linear infinite;
    color: var(--ie-primary-color);
  }

  @keyframes rotating {
    from {
      transform: rotate(0deg);
    }

    to {
      transform: rotate(360deg);
    }
  }
}

/* === toast 提示 (它通常挂载在 body 上，所以放在容器外面) === */
/* 如果 toast 逻辑改为挂载到容器内，也可以移进去 */
.ie-toast {
  position: fixed;
  top: 20px;
  left: 50%;
  transform: translateX(-50%);
  background: rgba(0, 0, 0, 0.7);
  color: white;
  padding: 8px 16px;
  border-radius: 4px;
  font-size: 14px;
  z-index: 9999;
  animation: ie-fade-in 0.3s;
  pointer-events: none;
  /* 防止遮挡点击 */
}

@keyframes ie-fade-in {
  from {
    opacity: 0;
    transform: translate(-50%, -10px);
  }

  to {
    opacity: 1;
    transform: translate(-50%, 0);
  }
}

/* === 全局滚动条样式 (Global Scrollbar) === */

/* 1. 设置滚动条整体宽高 */
::-webkit-scrollbar {
  width: 6px;
  /* 纵向滚动条宽度 */
  height: 6px;
  /* 横向滚动条高度 */
}

/* 2. 滚动条轨道 (可选，通常设为透明) */
::-webkit-scrollbar-track {
  background: transparent;
}

/* 3. 滚动条滑块 */
::-webkit-scrollbar-thumb {
  background: rgba(144, 147, 153, 0.3);
  /* 默认颜色，半透明灰色 */
  border-radius: 4px;
  /* 圆角 */
  transition: background 0.3s;
}

/* 4. 滑块悬停状态 (交互反馈) */
::-webkit-scrollbar-thumb:hover {
  background: rgba(144, 147, 153, 0.5);
  /* 悬停时加深 */
}

/* === 定义一个工具类：用于隐藏滚动条但保留滚动功能 === */
/* 使用方法：在标签上加 class="hide-scrollbar" */
.hide-scrollbar {
  scrollbar-width: none;
  /* Firefox */
  -ms-overflow-style: none;
  /* IE 10+ */
}

.hide-scrollbar::-webkit-scrollbar {
  display: none;
  /* Chrome/Safari/Webkit */
}

.ie-slider::-webkit-slider-thumb {
  -webkit-appearance: none;
  appearance: none;
  width: 16px;
  height: 16px;
  border-radius: 50%;
  background: var(--ie-primary-color); /* 关键：使用主题色变量 */
  cursor: pointer;
  border: 2px solid white;
  box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
  margin-top: -6px; /* 调整垂直对齐 */
}

/* Firefox 浏览器 */
.ie-slider::-moz-range-thumb {
  width: 16px;
  height: 16px;
  border: 2px solid white;
  border-radius: 50%;
  background: var(--ie-primary-color); /* 关键：使用主题色变量 */
  cursor: pointer;
  box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
}

/* 修正滑块轨道颜色 (可选，视全局样式而定) */
.ie-slider::-webkit-slider-runnable-track {
  height: 4px;
  background: #e4e7ed; /* 轨道背景色 */
  border-radius: 2px;
}

/* ... 原有内容保持不变 ... */

/* === 通用小号数字输入框 (修复背景色与隐藏箭头) === */
.ie-small-input {
  background-color: #ffffff; /* 1. 强制白色背景 */
  color: #606266;            /* 2. 标准文字颜色 */
  border: 1px solid #dcdfe6;
  border-radius: 4px;
  text-align: center;
  outline: none;
  transition: border-color 0.2s;
  width: 50px;
  /* Firefox 移除箭头 */
  -moz-appearance: textfield; 
}

.ie-small-input:focus {
  border-color: var(--ie-primary-color);
}

/* Chrome, Safari, Edge, Opera 移除箭头 */
.ie-small-input::-webkit-outer-spin-button,
.ie-small-input::-webkit-inner-spin-button {
  -webkit-appearance: none;
  margin: 0;
}

/* === 标准化数值输入框 (配合 Slider 使用) === */
  /* 宪法 6.2 规定：固定宽 50px，高 28px */
  .ie-input-number {
    width: 50px;
    height: 28px;
    padding: 0;
    border: 1px solid var(--ie-border-color);
    border-radius: 4px;
    text-align: center;
    font-size: 12px;
    color: #606266;
    background-color: #ffffff;
    outline: none;
    transition: border-color 0.2s;
    appearance: textfield; /* 标准属性 */
    -moz-appearance: textfield; /* Firefox */
  }

  .ie-input-number:focus {
    border-color: var(--ie-primary-color);
  }

  /* 移除 Webkit 浏览器的原生箭头 */
  .ie-input-number::-webkit-outer-spin-button,
  .ie-input-number::-webkit-inner-spin-button {
    -webkit-appearance: none;
    margin: 0;
  }
</file>

<file path="src/components/layout/EditorLayout.vue">
<template>
  <div class="image-editor-sdk-container">
    <NavBar :textMap="textMap" class="layout-header" />

    <div class="layout-body">
      <LeftSidebar class="layout-sidebar" />

      <ToolPanel class="layout-panel" />

      <Workspace :imageUrl="imageUrl" class="layout-workspace" />
    </div>
    <LoadingOverlay />
  </div>
</template>

<script setup>
import { provide, ref, watch } from 'vue';
import { useCanvas } from '../../composables/useCanvas';
import NavBar from './NavBar.vue';
import LeftSidebar from './LeftSidebar.vue';
import ToolPanel from '../panels/ToolPanel.vue';
import Workspace from '../Workspace.vue';
import LoadingOverlay from '@/components/common/LoadingOverlay.vue';
const sdkContainer = ref(null);

// === 1. 定义组件接口 (Props & Emits) ===
const props = defineProps({
  // 初始图片链接
  imageUrl: {
    type: String,
    default: 'https://wallpaperm.cmcm.com/21f96d39cffd296c2dd2f0cf9cf65c9b.jpg'
  },
  // 文本映射表
  textMap: {
    type: Object,
    default: () => ({
      upload: '打开图片',
      save: '保存',
      title: '大秘美图'
    })
  },
  // 全局配置（如 AI 后端地址）
  config: {
    type: Object,
    default: () => ({
      aiBaseUrl: 'http://localhost:3000/ai', // 默认值
    })
  }
});

const emit = defineEmits(['save']); // 定义保存事件

// === 2. Provide 配置给子组件 ===
// 这样 AdjustRembg.vue 等组件可以通过 inject('editorConfig') 获取配置
provide('editorConfig', props.config);

// === 3. 初始化 Canvas 逻辑 ===
const {
  init,
  initImage,
  addImage,
  toggleDrawing,
  exportMask,
  replaceActiveImage,
  canvas,
  zoom,
  zoomIn,
  zoomOut,
  zoomReset,
  zoomToRect,
  addText,
  rotateActive,
  flipActive,
  undo,
  redo,
  saveHistory
} = useCanvas();

// === 4. 监听图片变化 ===
watch(() => props.imageUrl, (newUrl) => {
  if (newUrl && canvas.value) {
    initImage(newUrl);
  }
});

// 封装初始化方法，以便在 Canvas 准备好后加载初始图片
const handleInit = (id, width, height) => {
  init(id, width, height); // 调用原始 init

  // 如果有传入图片，延迟加载
  if (props.imageUrl) {
    setTimeout(() => {
      initImage(props.imageUrl);
    }, 100);
  }
};

// 【新增】还原到初始状态的方法
const handleReset = () => {
  // 确保有初始图片 URL 且 initImage 方法可用
  if (props.imageUrl && initImage) {
    // 调用 useCanvas 的 initImage 方法，传入初始 URL
    // 这会清空画布、重置历史记录并加载初始图片
    initImage(props.imageUrl);
  }
};

// 保存图片
const handleExport = () => {
  // 1. 取消选中状态
  canvas.value?.discardActiveObject();
  canvas.value?.renderAll();

  // 2. 获取 Base64
  const dataURL = canvas.value?.toDataURL({ format: 'png' });

  // 3. 抛出事件给父组件
  emit('save', dataURL);
};

// === 5. 组装 API 对象 ===
const api = {
  canvas,
  init: handleInit,
  zoom,
  zoomIn,
  zoomOut,
  zoomReset,
  zoomToRect,
  initImage,
  addImage,
  toggleDrawing,
  exportMask,
  replaceActiveImage,
  rotateActive,
  flipActive,
  undo,
  redo,
  saveHistory,
  addText: (text) => addText(text),
  exportImg: () => canvas.value?.toDataURL({ format: 'png' }),
  getActiveImgSrc: () => canvas.value?.getActiveObject()?.getSrc(),
  clearPaths: () => {
    const paths = canvas.value?.getObjects().filter(o => o.type === 'path');
    canvas.value?.remove(...paths);
  },
  save: handleExport,
  reset: handleReset
};

// === 向下分发 ===
provide('canvasAPI', api);
defineExpose({
  save: handleExport,
  undo,
  redo,
  canvas: canvas
})
</script>

<style scoped>
/* 修改类名，避免过于通用的 layout-container */
.image-editor-sdk-container {
  display: flex;
  flex-direction: column;
  /* 改为 100% 以适应父容器，而不是强制全屏 */
  height: 100%;
  width: 100%;
  overflow: hidden;
  background-color: #fff;
  position: relative;
}

.layout-header {
  height: 50px;
  flex-shrink: 0;
  z-index: 20;
  border-bottom: 1px solid #e4e7ed;
  /* 确保有边界 */
}

.layout-body {
  display: flex;
  flex: 1;
  overflow: hidden;
  position: relative;
}

.layout-sidebar {
  width: 72px;
  flex-shrink: 0;
  z-index: 10;
}

.layout-panel {
  width: 300px;
  flex-shrink: 0;
  z-index: 10;
}

.layout-workspace {
  flex: 1;
  background-color: #f0f2f5;
  position: relative;
  min-width: 0;
}
</style>
</file>

<file path="src/composables/useCanvas.js">
import { ref, shallowRef, markRaw, toRaw, unref } from "vue";
import { fabric } from "fabric";
// ✨ 引入 routeToObject 用于路由跳转
import { useEditorState, ZOOM_PADDING } from "./useEditorState";

import {
    registerCropModule,
    constrainCrop,
    cropObject,
    cancelCrop,
    rotateActive as rotateCrop,
    flipActive as flipCrop
} from "@/components/modules/adjust/useCanvasCrop";

export function useCanvas() {
  const canvas = shallowRef(null);
  // ✨ 获取 routeToObject
  const { setHistoryState, setActiveTool, setSidebarDisabled, routeToObject } = useEditorState();
  const zoom = ref(1);

  // 交互状态变量
  let isPotentialClick = false;
  let dragStartPoint = null;

  // === 历史记录 ===
  const history = [];
  let historyIndex = -1;
  let historyProcessing = false;

  const saveHistory = () => {
    if (!canvas.value || historyProcessing) return;
    if (historyIndex < history.length - 1) {
      history.splice(historyIndex + 1);
    }
    const json = JSON.stringify(
        canvas.value.toJSON(["id", "selectable", "name", "isMainImage", "isPuzzleImage", "cellIndex", "isMaskObject"])
    );
    history.push(json);
    historyIndex++;
    if (history.length > 50) {
      history.shift();
      historyIndex--;
    }
    updateStoreHistory();
  };

  const updateStoreHistory = () => {
    setHistoryState(historyIndex > 0, historyIndex < history.length - 1);
  };

  // === 撤销 (Undo) ===
  const undo = () => {
    if (!canvas.value || historyIndex <= 0 || historyProcessing) return;

    if (cropObject.value) cancelCrop();

    historyProcessing = true;
    historyIndex--;
    const content = history[historyIndex];

    canvas.value?.loadFromJSON(content, () => {
      canvas.value?.renderAll();
      historyProcessing = false;
      updateStoreHistory();
    });
  };

  // === 重做 (Redo) ===
  const redo = () => {
    if (!canvas.value || historyIndex >= history.length - 1 || historyProcessing) return;

    if (cropObject.value) cancelCrop();

    historyProcessing = true;
    historyIndex++;
    const content = history[historyIndex];

    canvas.value?.loadFromJSON(content, () => {
      canvas.value?.renderAll();
      historyProcessing = false;
      updateStoreHistory();
    });
  };

  const zoomToRect = (rect, minZoomLimit = 0.1) => {
    if (!canvas.value) return;
    const width = canvas.value.width;
    const height = canvas.value.height;

    let targetZoom = Math.min(width / rect.width, height / rect.height) * ZOOM_PADDING;
    targetZoom = Math.max(minZoomLimit, Math.min(targetZoom, 50));

    const rectCenterX = rect.left + rect.width / 2;
    const rectCenterY = rect.top + rect.height / 2;

    const panX = (width / 2) - (rectCenterX * targetZoom);
    const panY = (height / 2) - (rectCenterY * targetZoom);

    canvas.value.setViewportTransform([targetZoom, 0, 0, targetZoom, panX, panY]);
    zoom.value = targetZoom;
    canvas.value.requestRenderAll();
  };

    const handleSelection = (target) => {
      // 🔍 Debug 日志 1: 看看函数有没有被触发
    console.log('1. handleSelection triggered. Target:', target);
        // 1. 点击空白处 -> 进入残影模式
        if (!target) {
          console.log('Target is null, disabling sidebar'); // Log
            setSidebarDisabled(true);
            return;
        }
console.log('2. Target Type:', target.type);
        // 2. 过滤特殊对象 (遮罩、不导出对象)
        if (target.isMaskObject || target.excludeFromExport) {
            return;
        }

        // 3. ✨ 过滤多选 (ActiveSelection)
        // 根据你的要求 "不需要多选"，这里检测到多选直接返回，不做任何路由跳转
        // 侧边栏保持上一次的状态，或者你可以选择在这里 setSidebarDisabled(true)
        if (target.type === 'activeSelection') {
             console.log('[Router] Multi-selection ignored.');
             return; 
        }

        // 4. ✨ 核心：将整个 target 对象传给 State
        // State 层会分析 target.type 或 target.customTab，决定跳到哪个 Tool + 哪个 Tab
        const routed = routeToObject(target);
        console.log('3. Routing result:', routed);
        // 5. 兜底逻辑：如果选中的对象在路由表里没配置（比如背景控制点）
        // 我们至少要保证侧边栏是“可用”的，而不是禁用的
        if (!routed) {
            setSidebarDisabled(false);
        }
    };

  // === 初始化与事件 ===
  const init = (id, width, height) => {
    console.log("init canvas", id, width, height);
    const c = new fabric.Canvas(id, {
      width: width,
      height: height,
      backgroundColor: "#f3f3f3",
      preserveObjectStacking: true,
      fireRightClick: true,
      stopContextMenu: false
    });
    canvas.value = markRaw(c);

    registerCropModule(canvas, saveHistory, zoomToRect);

    const checkConstraint = () => {
      if (cropObject.value) {
        constrainCrop(toRaw(cropObject.value));
      }
    };
    c.on("object:modified", (e) => {
      checkConstraint();
      if (e.target && e.target.type !== "rect") saveHistory();
    });
    c.on("object:added", (e) => {
      if (e.target && e.target.type !== "rect") saveHistory();
    });
    c.on("object:removed", (e) => {
      if (e.target && e.target.type !== "rect") saveHistory();
    });

    // ✨ 交互消歧：按下时记录坐标
    c.on("mouse:down", (opt) => {
        isPotentialClick = true;
        const pointer = c.getPointer(opt.e);
        dragStartPoint = { x: pointer.x, y: pointer.y };
    });

    // ✨ 交互消歧：移动时检测阈值
    c.on("mouse:move", (opt) => {
        if (!isPotentialClick) return;
        const pointer = c.getPointer(opt.e);
        const dist = Math.sqrt(
            Math.pow(pointer.x - dragStartPoint.x, 2) +
            Math.pow(pointer.y - dragStartPoint.y, 2)
        );
        if (dist > 5) { // 阈值 5px
            isPotentialClick = false; // 判定为拖拽
        }
    });

    // ✨ 路由触发点 1: 点击松开 (主要交互)
   c.on("mouse:up", (opt) => {
        if (!isPotentialClick || c.isDrawingMode || cropObject.value) return;
        const target = c.getActiveObject();
        handleSelection(target);
    });

    // ✨ 路由触发点 2: 选区创建 (处理 API 调用 setActiveObject 或 框选)
    // 确保非点击产生的选中也能触发路由
   // 触发点 2: API 调用 (如 addText) 或 框选
    c.on("selection:created", (e) => {
        if (!isPotentialClick && (e.target || (e.selected && e.selected.length > 0))) { 
         handleSelection(e.target || e.selected[0]);
    }
    });
    
    // ✨ 路由触发点 3: 选区更新 (例如从单选变为多选)
    c.on("selection:updated", (e) => {
        handleSelection(e.target);
    });

    // ✨ 路由触发点 4: 选区清除 (进入残影)
    c.on("selection:cleared", () => {
        setSidebarDisabled(true);
    });

    // Zoom 事件
    const canvasEl = c.upperCanvasEl;
    canvasEl.addEventListener(
      "wheel",
      (e) => {
        e.preventDefault();
        e.stopPropagation();
        const delta = e.deltaY;
        let newZoom = c.getZoom();
        newZoom *= 0.999 ** delta;
        if (newZoom > 50) newZoom = 50;
        if (newZoom < 0.1) newZoom = 0.1;
        c.zoomToPoint({ x: e.offsetX, y: e.offsetY }, newZoom);
        zoom.value = newZoom;
      },
      { passive: false }
    );

    saveHistory();
  };

  // === 通用 API ===
  const addImage = (url) => {
    fabric.Image.fromURL(
      url,
      (img) => {
        const canvasWidth = canvas.value.width;
        const canvasHeight = canvas.value.height;
        if (img.width > canvasWidth || img.height > canvasHeight) {
          const scale = Math.min(canvasWidth / img.width, canvasHeight / img.height) * ZOOM_PADDING;
          img.scale(scale);
        }
        
        // 设置基础属性
        img.set({
          isMainImage: true,
          id: 'main-image'
        });
        
        zoom.value = canvas.value.getZoom();
        historyProcessing = true;
        
        canvas.value?.add(img);
        canvas.value?.centerObject(img);
        
        // ✨ 关键：触发选中事件，让系统自动路由到 (Adjust -> Filter)
        canvas.value?.setActiveObject(img); 
        
        historyProcessing = false;
        saveHistory();
        canvas.value.fire('image:updated');
      },
      { crossOrigin: "anonymous" }
    );
  };

  const setZoom = (value) => {
    if (!canvas.value) return;
    let newZoom = value;
    if (newZoom > 50) newZoom = 50;
    if (newZoom < 0.1) newZoom = 0.1;
    const center = canvas.value.getCenter();
    canvas.value.zoomToPoint({ x: center.left, y: center.top }, newZoom);
    zoom.value = newZoom;
  };

  const zoomIn = () => setZoom(zoom.value + 0.1);
  const zoomOut = () => setZoom(zoom.value - 0.1);
  const zoomReset = () => setZoom(1);

  const initImage = (url) => {
    if (!canvas.value) return;
    historyProcessing = true;
    canvas.value.clear();
    canvas.value.setBackgroundColor("#f3f3f3", () => {
      canvas.value.renderAll();
    });
    historyProcessing = false;
    history.length = 0;
    historyIndex = -1;
    updateStoreHistory();
    addImage(url);
  };

  const rotateActive = (angle) => {
    const handled = rotateCrop(angle);
    if (!handled) {
      const activeObj = canvas.value?.getActiveObject();
      if (activeObj) {
        activeObj.rotate((activeObj.angle || 0) + angle);
        canvas.value.requestRenderAll();
        saveHistory();
      }
    }
  };

  const flipActive = (axis) => {
    const handled = flipCrop(axis);
    if (!handled) {
      const activeObj = canvas.value?.getActiveObject();
      if (activeObj) {
        if (axis === "X") activeObj.set("flipX", !activeObj.flipX);
        if (axis === "Y") activeObj.set("flipY", !activeObj.flipY);
        canvas.value.requestRenderAll();
      }
    }
  };

  const toggleDrawing = (enable) => {
    if (!canvas.value) return;
    canvas.value.isDrawingMode = enable;
    if (enable) {
      const brush = new fabric.PencilBrush(canvas.value);
      brush.color = "rgba(255, 0, 0, 0.5)";
      brush.width = 30;
      canvas.value.freeDrawingBrush = brush;
    }
  };

  const exportMask = () => {
    if (!canvas.value) return null;
    const originalBg = canvas.value.backgroundColor;
    const objects = canvas.value.getObjects();

    objects.forEach((obj) => {
      if (obj.type === "path" || obj.isMaskObject) {
        obj._originalStroke = obj.stroke;
        obj._originalFill = obj.fill;
        obj.set({ stroke: "#ffffff", fill: "#ffffff" });
      } else {
        obj._originalOpacity = obj.opacity;
        obj.set({ opacity: 0 });
      }
    });

    canvas.value.setBackgroundColor("#000000", null);
    canvas.value.renderAll();

    const dataURL = canvas.value.toDataURL({ format: "png", multiplier: 1 });

    objects.forEach((obj) => {
      if (obj.type === "path" || obj.isMaskObject) {
        obj.set({
          stroke: obj._originalStroke,
          fill: obj._originalFill
        });
      } else {
        obj.set({ opacity: obj._originalOpacity ?? 1 });
      }
    });

    canvas.value.setBackgroundColor(originalBg, null);
    canvas.value.renderAll();

    return dataURL;
  };

  const replaceActiveImage = (newUrl) => {
    const activeObj = canvas.value?.getActiveObject();
    if (!activeObj || activeObj.type !== "image") return;
    activeObj.setSrc(
      newUrl,
      () => {
        canvas.value.renderAll();
        saveHistory();
        canvas.value.fire('image:updated');
      },
      { crossOrigin: "anonymous" }
    );
  };

const addText = (textStr = "双击编辑") => {
    if (!canvas.value) return;
    
    const text = new fabric.IText(textStr, {
      left: 100,
      top: 100,
      fontSize: 40,
      fill: "#333",
      // ✨ 进阶用法演示（可选）：
      // 如果你想让这个特定的文本创建时直接跳到 "颜色" Tab，可以解开下面这行注释：
      // customTab: 'color' 
    });
    
    canvas.value.add(text);
    
    // ✨ 关键：这行代码会触发 fabric 的 'selection:created' 事件
    // 进而触发 handleSelection -> routeToObject -> 自动跳转到 Text 面板的 Style Tab
    canvas.value.setActiveObject(text);
    
    canvas.value.requestRenderAll(); // 刷新画布
    saveHistory(); // 记录历史
  };

  return {
    canvas,
    zoom,
    init,
    initImage,
    addImage,
    zoomIn,
    zoomOut,
    zoomReset,
    zoomToRect,
    setZoom,
    undo,
    redo,
    saveHistory,
    toggleDrawing,
    exportMask,
    replaceActiveImage,
    addText,
    rotateActive,
    flipActive
  };
}
</file>

</files>
